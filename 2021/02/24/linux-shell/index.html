<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lhV5cabuw1R5ZNw3egkRBdP3yiHpIpX4_8SvcqwxYAc">
  <meta name="baidu-site-verification" content="code-abAwAH8nFB">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ylab324.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="💲">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Shell">
<meta property="og:url" content="https://ylab324.github.io/2021/02/24/linux-shell/">
<meta property="og:site_name" content="Debbie">
<meta property="og:description" content="💲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f4b2.png?v8">
<meta property="og:image" content="https://i.loli.net/2020/06/08/DEpRWVLrby8qOxI.png">
<meta property="og:image" content="https://i.loli.net/2020/06/08/Yu5AzgHGvN7VdpS.png">
<meta property="article:published_time" content="2021-02-23T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-18T03:31:53.457Z">
<meta property="article:author" content="ylab324">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="shell">
<meta property="article:tag" content="script">
<meta property="article:tag" content="bash">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f4b2.png?v8">


<link rel="canonical" href="https://ylab324.github.io/2021/02/24/linux-shell/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ylab324.github.io/2021/02/24/linux-shell/","path":"2021/02/24/linux-shell/","title":"Linux Shell"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux Shell | Debbie</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Debbie</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">所记更为简略，系备忘性质。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">启动环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">6.</span> <span class="nav-text">算术运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">7.</span> <span class="nav-text">条件判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">8.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E7%AB%AF%E6%89%93%E5%8D%B0"><span class="nav-number">9.</span> <span class="nav-text">终端打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">10.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%8F%B7%E5%92%8C%E8%BD%AC%E4%B9%89"><span class="nav-number">11.</span> <span class="nav-text">引号和转义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-number">12.</span> <span class="nav-text">模式扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sed%E5%85%A5%E9%97%A8"><span class="nav-number">14.</span> <span class="nav-text">sed入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#awk%E5%85%A5%E9%97%A8"><span class="nav-number">15.</span> <span class="nav-text">awk入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">16.</span> <span class="nav-text">行操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vim"><span class="nav-number">17.</span> <span class="nav-text">Vim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="nav-number">18.</span> <span class="nav-text">调试脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">19.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">19.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E5%A0%86%E6%A0%88"><span class="nav-number">19.2.</span> <span class="nav-text">目录堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C%E6%A0%B8%E5%AE%9E"><span class="nav-number">19.3.</span> <span class="nav-text">校验和核实</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read%E5%91%BD%E4%BB%A4"><span class="nav-number">19.4.</span> <span class="nav-text">read命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">19.5.</span> <span class="nav-text">生成任意大小的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="nav-number">19.6.</span> <span class="nav-text">压缩归档文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mktemp%E5%91%BD%E4%BB%A4"><span class="nav-number">19.7.</span> <span class="nav-text">mktemp命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap%E5%91%BD%E4%BB%A4"><span class="nav-number">19.8.</span> <span class="nav-text">trap命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E5%91%BD%E4%BB%A4-shopt%E5%91%BD%E4%BB%A4"><span class="nav-number">19.9.</span> <span class="nav-text">set命令,shopt命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xargs"><span class="nav-number">19.10.</span> <span class="nav-text">xargs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-number">19.11.</span> <span class="nav-text">其他命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">20.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">21.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ylab324"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ylab324</p>
  <div class="site-description" itemprop="description">All I want out of life is a bit of peace and happiness. That's all.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:fghrle@gmail.com" title="E-Mail → mailto:fghrle@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ylab324.github.io/2021/02/24/linux-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ylab324">
      <meta itemprop="description" content="All I want out of life is a bit of peace and happiness. That's all.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Debbie">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Shell
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-24T00:00:00+08:00">2021-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><span class="github-emoji"><span>💲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  </p>
<span id="more"></span>


<h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><ul>
<li><p>session  </p>
<p>  当我们登录系统后，bash程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的shell环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的shell环境。确切的启动顺序依赖于要运行的shell会话类型。有两种shell会话类型：一个是登录shell会话，另一个是非登录shell会话。    </p>
<p>  登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/profile</td>
<td align="left">应用于所有用户的全局配置脚本</td>
</tr>
<tr>
<td align="left">~/.bash_profile</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
<tr>
<td align="left">~/.bash_login</td>
<td align="left">如果文件 ~/.bash_profile 没有找到，bash会尝试读取这个脚本</td>
</tr>
<tr>
<td align="left">~/.profile</td>
<td align="left">如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash会试图读取这个文件。这是基于Debian发行版的默认配置，比方说Ubuntu</td>
</tr>
</tbody></table>
<p>  非登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/bash.bashrc</td>
<td align="left">应用于所有用户的全局配置文件</td>
</tr>
<tr>
<td align="left">~/.bashrc</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
</tbody></table>
<p>  在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。  </p>
</li>
<li><p>启动选项  </p>
<p>  为了方便debug，有时在启动Bash的时候，可以加上启动参数。<br>  <code>-n</code> - 不运行脚本，只检查是否有语法错误<br>  <code>-v</code> - 输出每一行语句运行结果前，会先输出该行语句<br>  <code>-x</code> - 每一个命令处理之前，先输出该命令，再执行该命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bash -n scriptname  </span><br><span class="line">$ bash -v scriptname  </span><br><span class="line">$ bash -x scriptname  </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量分类  </p>
<p>  环境变量：<code>env</code>或<code>printenv</code>命令，可以显示所有环境变量；<code>set</code>命令可显示所有变量（包括环境变量和自定义变量），以及所有的Bash函数。<br>  自定义变量：局部变量、全局变量。<br>  变量命名规则：  </p>
<ul>
<li>变量名可由字母数字字符（字母和数字）和下划线字符组成  </li>
<li>变量名的第一个字符必须是一个字母或一个下划线  </li>
<li>变量名中不允许出现空格和标点符号  </li>
</ul>
</li>
<li><p>读取变量  </p>
<p>  读取变量的时候，直接在变量名前加上<code>$</code>就可以了。读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如 $a 也可以写成 ${a} 。这种写法可以用于变量名与其他字符连用的情况。<br>  如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。  </p>
</li>
<li><p>删除变量  </p>
<p>  <code>unset</code>命令用来删除一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> NAME  </span><br></pre></td></tr></tbody></table></figure>
<p>  这个命令不是很有用。因为不存在的Bash变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。<br>  所以，删除一个变量，也可以将这个变量设成空字符串:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">''</span>  </span><br><span class="line">$ foo=  </span><br></pre></td></tr></tbody></table></figure>
<p>  上面两种写法，都是删除了变量foo。  </p>
</li>
<li><p>输出变量：<code>export</code>命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NAME=value</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令执行后，当前shell及随后新建的子shell，都可以读取变量<code>$NAME</code>。子shell如果修改继承的变量，不会影响父shell。  </p>
</li>
<li><p>特殊变量（包含位置参数）  </p>
<ul>
<li><code>$?</code> - 上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果是非零，上一个命令执行失败  </li>
<li><code>$$</code> - 当前shell的进程ID  </li>
<li><code>$_</code> - 上一个命令的最后一个参数  </li>
<li><code>$!</code> - 最近一个后台执行的异步命令的进程ID  </li>
<li><code>$0</code> - 当前shell的名称，脚本文件名  </li>
<li><code>$1</code>到<code>$9</code> - 对应脚本的第一个参数到第九个参数。通过参数展开方式可以访问的参数个数多于9个。只要指定一个大于9的数字，用花括号括起来就可以，例如 ${10}、${55}、${211} 等  </li>
<li><code>$-</code> - 当前shell的启动参数  </li>
<li><code>$#</code> - 参数的总和  </li>
<li><code>$@</code> - 全部的参数。当它被用双引号引起来的时候， 它把每一个位置参数展开成一个由双引号引起来的分开的字符串  </li>
<li><code>$*</code> - 全部的参数。当它被用双引号引起来的时候，展开成一个由双引号引起来的字符串，包含了所有的位置参数，每个位置参数由shell变量<code>$IFS</code>值的第一个字符分隔开，默认为空格，但是可以自定义  </li>
</ul>
</li>
</ul>
<ul>
<li><p>变量的默认值  </p>
<ul>
<li><code>${varname:-word}</code>：如果变量varname存在且不为空，则返回它的值，否则返回word。它的目的是返回一个默认值，比如${count:-0}表示变量count不存在时返回0。  </li>
<li><code>${varname:=word}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word。它的目的是设置变量的默认值，比如${count:=0}表示变量count不存在时返回0，且将count设为0。  </li>
<li> <code>${varname:+word}</code>：上面语法的含义是，如果变量名存在且不为空，则返回word，否则返回空值。它的目的是测试变量是否存在，比如${count:+1}表示变量count存在时返回1（表示true），否则返回空值。  </li>
<li> <code>${varname:?message}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行。如果省略了message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如${count:?”undefined!”}表示变量count未定义时就中断执行，抛出错误，返回给定的报错信息undefined!。  </li>
</ul>
<p>  上面四种语法如果用在脚本中，变量名的部分可以用数字1到9，表示脚本的参数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=<span class="variable">${1:?"filename missing."}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  上面代码出现在脚本中，1表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。  </p>
</li>
<li><p>其他  </p>
<ul>
<li><code>declare</code> - 声明一些特殊类型的变量，为变量设置一些限制。  </li>
<li><code>readonly</code> - 等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。  </li>
<li><code>let</code> - 声明变量时，可以直接执行算术表达式：    <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> foo=1+2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>Bash 函数定义的语法有两种。    <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果函数与脚本、别名同名，优先级：别名&gt;函数&gt;脚本。  </li>
<li>参数变量：与脚本的参数变量是一致的。  </li>
<li>调用时，就直接写函数名，参数跟在函数名后面。  </li>
<li>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。  </li>
<li>函数里面可以用<code>local</code>命令声明局部变量。  </li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>创建数组  </p>
<p>  逐个赋值：ARRAY[INDEX]=value<br>  一次性赋值：ARRAY=(value1 value2 … valueN)  </p>
<p>  定义数组时，可以使用通配符：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mp3s=( *.mp3 )</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，将当前目录的所有MP3文件，放进一个数组。  </p>
<p>  还可以通过指定下标，把值赋给数组中的特定元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)  </span><br></pre></td></tr></tbody></table></figure>
<p>  先用<code>declare -a</code>命令声明一个数组，也是可以的：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -a ARRAYNAME</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>read -a</code>命令则是将用户的命令行输入，读入一个数组：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -a dice</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令将用户的命令行输入，读入数组dice。  </p>
</li>
<li><p>读取数组  </p>
<p>  读取单个元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${array[i]}</span>   <span class="comment"># i 是索引</span></span><br></pre></td></tr></tbody></table></figure>
<p>  读取所有成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>是数组的特殊索引，表示返回数组的所有成员。  </p>
<p>  遍历数组:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">${names[@]}</span>"</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>放不放在双引号之中，是有差别的。  </p>
<p>  拷贝一个数组的最方便方法，就是写成下面这样：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]}</span>"</span> )</span><br></pre></td></tr></tbody></table></figure>
<p>  这种写法也可以用来为新数组添加成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]" diving )</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>默认位置  </p>
<p>  如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用0号位置。  </p>
</li>
<li><p>数组的长度  </p>
<p>  要想知道数组的长度（即一共包含多少成员），可以使用下面两种语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">${#array[*]}</span></span><br><span class="line"><span class="variable">${#array[@]}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>提取数组序号  </p>
<p>  <code>${!array[@]}</code>或<code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。  </p>
</li>
<li><p>提取数组成员  </p>
<p>  <code>${array[@]:position:length}</code>的语法可以提取数组成员。<br>  如果省略长度参数length，则返回从指定位置开始的所有成员。  </p>
</li>
<li><p>追加数组成员  </p>
<p>  数组末尾追加成员，可以使用<code>+=</code>赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ foo=(a b c)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">$ foo+=(d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>删除数组  </p>
<p>  删除一个数组成员，使用<code>unset</code>命令：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">unset</span> foo[2]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  将某个成员设为空值，可以从返回值中“隐藏”这个成员。<br>  直接将数组变量赋值为空字符串，相当于“隐藏”数组的第一个成员。<br>  <code>unset ArrayName</code>可以清空整个数组。  </p>
</li>
<li><p>关联数组  </p>
<p>  关联数组使用字符串而不是整数作为数组索引。<br>  <code>declare -A</code>可以声明关联数组。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A colors</span><br><span class="line">$ colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">$ colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">$ colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有<code>-A</code>选项的<code>declare</code>命令声明创建。  </p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串的长度  </p>
<p>  获取字符串长度的语法如下：<code>${#varname}</code>。  </p>
</li>
<li><p>子字符串  </p>
<p>  字符串提取子串的语法如下：<code>${varname:offset:length}</code>。<br>  这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello=<span class="string">'abcdefg'</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${hello:2:3}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果省略length，则从位置offset开始，一直返回到字符串的结尾。<br>  如果offset为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格，以防止与<code>${variable:-word}</code>的变量的设置默认值语法混淆。此时还可以指定length，length可以是正值，也可以是负值（负值不能超过offset的长度）。  </p>
</li>
<li><p>切割和替换  </p>
<ul>
<li><p>字符串头部的模式匹配  </p>
<p>  <code>${variable#pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable##pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ myPath=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath#/*/}</span></span><br><span class="line">cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath##/*/}</span></span><br><span class="line">long.file.name</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/#pattern/string}</code> - 将头部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/#JPG/jpg}</span></span><br><span class="line">jpg.JPG</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串尾部的模式匹配  </p>
<p>  <code>${variable%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable%%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%.*}</span></span><br><span class="line">/home/cam/book/long.file</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%%.*}</span></span><br><span class="line">/home/cam/book/long</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/%pattern/string}</code> - 将尾部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/%JPG/jpg}</span></span><br><span class="line">JPG.jpg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>任意位置的模式匹配  </p>
<p>  <code>${variable/pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配<br>  <code>${variable//pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/foo/bar}</span></span><br><span class="line">/home/cam/bar/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path//foo/bar}</span></span><br><span class="line">/home/cam/bar/bar.name</span><br></pre></td></tr></tbody></table></figure>

<p>  如果省略了string部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/.*/}</span></span><br><span class="line">/home/cam/foo/foo</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>改变大小写  </p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">${parameter,,}</td>
<td align="left">把 parameter 的值全部展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter,}</td>
<td align="left">仅仅把 parameter 的第一个字符展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter^^}</td>
<td align="left">把 parameter 的值全部转换成大写字母</td>
</tr>
<tr>
<td align="left">${parameter^}</td>
<td align="left">仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><ul>
<li><p>算术表达式  </p>
<p>  <code>((...))</code>语法可以进行整数的算术运算：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ((foo = 5 + 5))</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
<p>  如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。<br>  <code>$((...))</code>的圆括号中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。<br>  如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名，如果不存在同名变量，Bash 就会将其作为空值，而<code>$((...))</code>会将空值当做0。  </p>
<p>  逗号<code>，</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((foo = <span class="number">1</span> + <span class="number">2</span>, <span class="number">3</span> * <span class="number">4</span>))</span><br><span class="line">12</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>数值的进制  </p>
<p>  指定不同的数基  </p>
<table>
<thead>
<tr>
<th align="left">表示法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">number</td>
<td align="left">默认情况下，没有任何表示法的数字被看做是十进制数（以10为底）</td>
</tr>
<tr>
<td align="left">0number</td>
<td align="left">在算术表达式中，以零开头的数字被认为是八进制数</td>
</tr>
<tr>
<td align="left">0xnumber</td>
<td align="left">十六进制表示法</td>
</tr>
<tr>
<td align="left">base#number</td>
<td align="left">base进制的数</td>
</tr>
</tbody></table>
<p>  其他进制转换为10进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">0</span>xff))  </span><br><span class="line">255  </span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2#11111111</span>))  </span><br><span class="line">255</span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">8#11</span>))</span><br><span class="line">9</span><br><span class="line">$ <span class="built_in">printf</span> %d 0xFF</span><br><span class="line">$ ((num=8<span class="comment">#123))</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${num}</span></span><br><span class="line">83</span><br></pre></td></tr></tbody></table></figure>
<p>  10进制转换为其他进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=16;65536"</span> | bc <span class="comment"># 利用bc计算器。echo "obase=进制;值" | bc</span></span><br><span class="line">10000</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=8;65536"</span> | bc</span><br><span class="line">200000</span><br><span class="line">$ <span class="built_in">printf</span> %x 15</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ul>
<li><p>位运算  </p>
</li>
<li><p>逻辑运算  </p>
</li>
<li><p>赋值运算  </p>
</li>
<li><p>求值运算  </p>
</li>
<li><p><code>expr</code>命令  </p>
<p>  <code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 3 + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令支持变量替换：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ foo=3</span><br><span class="line">$ expr <span class="variable">$foo</span> + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令也不支持非整数参数。  </p>
</li>
<li><p><code>let</code>命令  </p>
<p>  <code>let</code>命令用于将算术运算的结果，赋予一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> x=2+3</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  注意，x=2+3这个式子里面不能有空格，如果包含空格，需要使用引号。  </p>
<p>  <code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> <span class="string">"v1 = 1"</span> <span class="string">"v2 = v1++"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$v1</span>,<span class="variable">$v2</span></span><br><span class="line">2,1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p><code>if</code>结构  </p>
<ul>
<li><p>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">	commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>test</code>命令  </p>
<p>  <code>if</code>结构的判断条件，一般使用<code>test</code>命令，有三种形式：  </p>
<ol>
<li><code>test expression</code>  </li>
<li><code>[ expression ]</code>  </li>
<li><code>[[ expression ]]</code>  </li>
</ol>
<p>  上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。  </p>
</li>
<li><p>判断表达式  </p>
<ol>
<li><p>文件判断</p>
<p>文件系统相关测试：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回TRUE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f $var</td>
<td align="left">给定的变量包含正常的文件路径或文件名</td>
</tr>
<tr>
<td align="left">-x $var</td>
<td align="left">给定的变量包含的文件可执行</td>
</tr>
<tr>
<td align="left">-d $var</td>
<td align="left">给定的变量包含的是目录</td>
</tr>
<tr>
<td align="left">-e $var</td>
<td align="left">给定的变量包含的文件存在</td>
</tr>
<tr>
<td align="left">-c $var</td>
<td align="left">给定的变量包含的是一个字符设备文件的路径</td>
</tr>
<tr>
<td align="left">-b $var</td>
<td align="left">给定的变量包含的是一个块设备文件的路径</td>
</tr>
<tr>
<td align="left">-w $var</td>
<td align="left">给定的变量包含的文件可写</td>
</tr>
<tr>
<td align="left">-r $var</td>
<td align="left">给定的变量包含的文件可读</td>
</tr>
<tr>
<td align="left">-L $var</td>
<td align="left">给定的变量包含的是一个符号链接</td>
</tr>
</tbody></table>
</li>
<li><p>字符串判断</p>
<p>字符串表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回True</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">string不为null</td>
</tr>
<tr>
<td align="left">-n string</td>
<td align="left">字符串string的长度大于零</td>
</tr>
<tr>
<td align="left">-z string</td>
<td align="left">字符串string的长度为零</td>
</tr>
<tr>
<td align="left">string1 = string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 == string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 != string2</td>
<td align="left">string1和string2不相同</td>
</tr>
<tr>
<td align="left">string1 &gt; string2</td>
<td align="left">string1排列在string2之后</td>
</tr>
<tr>
<td align="left">string1 &lt; string2</td>
<td align="left">string1排列在string2之前</td>
</tr>
</tbody></table>
</li>
<li><p>整数判断</p>
<p>整形表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果为真…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">integer1 -eq integer2</td>
<td align="left">integer1等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ne integer2</td>
<td align="left">integer1不等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -le integer2</td>
<td align="left">integer1小于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -lt integer2</td>
<td align="left">integer1小于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ge integer2</td>
<td align="left">integer1大于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -gt integer2</td>
<td align="left">integer1大于integer2</td>
</tr>
</tbody></table>
</li>
<li><p>综合表达式</p>
<p>逻辑操作符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">测试</th>
<th align="left">[[]] and (())</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND</td>
<td align="left">-a</td>
<td align="left">&amp;&amp;</td>
</tr>
<tr>
<td align="left">OR</td>
<td align="left">-o</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">NOT</td>
<td align="left">!</td>
<td align="left">!</td>
</tr>
</tbody></table>
</li>
<li><p>正则判断</p>
<p><code>[[ string =~ regex ]]</code>  </p>
<p>上面的语法中，<code>regex</code>是一个正则表达式，<code>=~</code>是正则比较运算符。  </p>
<p>举个例子：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">INT=-5</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$INT</span>"</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is an integer."</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is not an integer."</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>算术判断</p>
<p>Bash还提供了<code>((...))</code>作为算术条件，进行算术运算的判断。</p>
<p>注意，算术判断不需要使用<code>test</code>命令，而是直接使用<code>((...))</code>结构。这个结构的返回值，决定了判断的真伪。</p>
<p>算术条件<code>((...))</code>也可以用于变量赋值：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">if</span> (( foo = 5 ));<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"foo is <span class="variable">$foo</span>"</span>; <span class="keyword">fi</span></span><br><span class="line">foo is 5</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>case</code>结构  </p>
<p>  语法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></tbody></table></figure>

<p>  <code>case</code>的匹配模式可以使用各种通配符，下面是一些例子：  </p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a)</td>
<td align="left">若单词为”a”，则匹配</td>
</tr>
<tr>
<td align="left">a|b)</td>
<td align="left">若单词为”a”或”b”，则匹配</td>
</tr>
<tr>
<td align="left">[[:alpha:]])</td>
<td align="left">若单词是一个字母字符，则匹配</td>
</tr>
<tr>
<td align="left">???)</td>
<td align="left">若单词只有3个字符，则匹配</td>
</tr>
<tr>
<td align="left">*.txt)</td>
<td align="left">若单词以”.txt”字符结尾，则匹配</td>
</tr>
<tr>
<td align="left">*)</td>
<td align="left">匹配任意单词。把这个模式作为case命令的最后一个模式，是一个很好的做法，可以捕获到任意一个与先前模式不匹配的数值；也就是说，捕获到任何可能的无效值</td>
</tr>
</tbody></table>
<p>  执行多个动作：<br>  Bash 4.0之后允许匹配多个条件，这时可以用<code>;;&amp;</code>终止每个条件块。<br>  条件语句结尾添加了<code>;;&amp;</code>以后，在匹配一个条件之后，并没有退出<code>case</code>结构，而是继续判断下一个条件。  </p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p><code>while</code>循环  </p>
<p>  <code>while</code>循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>until</code>循环  </p>
<p>  <code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件（判断条件失败），就不断循环执行指定的语句。一旦符合判断条件，就退出循环。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">until condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  一般来说，<code>until</code>用得比较少，完全可以统一都是用<code>while</code>。  </p>
</li>
<li><p><code>for...in</code>循环  </p>
<p>  <code>for...in</code>循环用于遍历列表的每一项。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>for</code>循环  </p>
<p>  <code>for</code>循环还支持 C 语言的循环语法。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号<code>$</code>。  </p>
</li>
<li><p><code>break</code>, <code>continue</code>  </p>
</li>
<li><p><code>select</code>结构  </p>
<p>  <code>select</code>结构主要用来生成简单的菜单。它的语法与<code>for...in</code>循环基本一致。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name</span><br><span class="line">[<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="终端打印"><a href="#终端打印" class="headerlink" title="终端打印"></a>终端打印</h2><p><code>echo</code>是用于终端打印的基本命令。  </p>
<p>另一个可用于终端打印的命令是<code>printf</code>:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4.2f\n"</span> 2 James 90.9989</span><br></pre></td></tr></tbody></table></figure>

<p>彩色输出：<br><img src="https://i.loli.net/2020/06/08/DEpRWVLrby8qOxI.png" alt="shell颜色语法.png"><br><img src="https://i.loli.net/2020/06/08/Yu5AzgHGvN7VdpS.png" alt="shell涉及的颜色.png"><br>每种颜色都有对应的颜色码。比如：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37。<br>要打印彩色文本，可输入如下命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>\e[1;31m</code>将颜色设为红色，<code>\e[0m</code>将颜色重新置回。  </p>
<p>要设置彩色背景，经常使用的颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>


<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li><p>重定向  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /bin/usr 2&gt; ls-error.txt <span class="comment">#重定向标准错误</span></span><br><span class="line">$ ls -l /bin/usr &amp;&gt; ls-output.txt <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; temp.txt <span class="comment">#把echo命令的输出写入文件前，temp.txt中的内容首先会被清空</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt;&gt; temp.txt <span class="comment">#这种方法会将文本追加到目标文件中</span></span><br><span class="line">$ &gt; ls-output.txt <span class="comment">#如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>cat</code> </p>
<p>  <code>cat</code>命令读取一个或多个文件，然后复制它们到标准输出。<br>  如果<code>cat</code>没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，它正在等待我们输入数据。下一步，输入<code>Ctrl-d</code>来告诉<code>cat</code>，在标准输入中，它已经到达文件末尾<code>EOF</code>。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>管道线  </p>
<p>  使用管道操作符<code>|</code>，一个命令的标准输出可以通过管道送至另一个命令的标准输入。  </p>
</li>
</ul>
<ul>
<li><p>过滤器  </p>
<p>  管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /bin /usr/bin | sort | uniq | less</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | wc -l</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">$ <span class="built_in">echo</span> `who | awk <span class="string">'{print $1}'</span> | sort | uniq` | sed <span class="string">'s/ /, /g'</span> &gt; file.txt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>head</code>/<code>tail</code> - 打印文件开头部分/结尾部分  </p>
<p>  默认打印10行，通过<code>-n</code>参数指定打印的行数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/bin | tail -n 5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>tail</code>有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时被写入。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></tbody></table></figure>
<p>  通过<code>-f</code>参数，<code>tail</code>命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入<code>Ctrl+c</code>。  </p>
</li>
<li><p><code>tee</code> - 从<code>stdin</code>读取数据，并同时输出到<code>stdout</code>和文件<br>  为了和我们的管道隐喻保持一致，Linux提供了一个叫做<code>tee</code>的命令，这个命令制造了一个”tee”，安装到我们的管道上，<code>tee</code>程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含<code>tee</code>命令，在<code>grep</code>过滤管道线的内容之前，来捕捉整个目录列表到文件ls.txt。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h2><ul>
<li><p>引号  </p>
<ul>
<li><p><strong>单引号</strong>：  </p>
<p>无视所有特殊字符，原样输出，所有字符在它眼里都是普通字符，比如星号<code>*</code>、美元符号<code>$</code>、反斜杠<code>\</code>等；单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>
</li>
<li><p><strong>双引号</strong>: </p>
<p>无视文件通配符，但<code>$</code>、<code>\</code>和<code>`</code>会起作用。</p>
<p>双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通符号。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*"</span></span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，通配符<code>*</code>是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。</p>
<p>但是三个特殊字符除外：美元符号<code>$</code>、反引号<code>`</code>和反斜杠<code>\</code>。这三个字符在双引号之中，依然有特殊含义，会被Bash自动扩展。</p>
<p>双引号还有一个作用，就是保存原始命令的输出格式：</p>
<p>单行输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">二月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</span><br></pre></td></tr></tbody></table></figure>

<p>原始格式输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="subst">$(cal)</span>"</span></span><br><span class="line">	二月 2021         </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">	1  2  3  4  5  6  </span><br><span class="line">7  8  9 10 11 12 13  </span><br><span class="line">14 15 16 17 18 19 20  </span><br><span class="line">21 22 23 24 25 26 27  </span><br><span class="line">28                    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>转义  </p>
<p>  某些字符在Bash里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$data</span></span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，输出$date不会有任何结果，因为<code>$</code>是一个特殊字符。<br>  如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做”转义”(escape)。  </p>
<p>  反斜杠除了用于转义，还可以表示一些不可打印的字符：<br>  <code>\a</code> - 响铃<br>  <code>\b</code> - 退格<br>  <code>\n</code> - 换行<br>  <code>\r</code> - 回车<br>  <code>\t</code> - 制表符<br>  如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a\tb</span><br><span class="line">atb</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\tb"</span></span><br><span class="line">a	b</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，命令行直接输出不可打印字符<code>\t</code>，Bash不能正确解析。必须把它们放在引号之中，然后使用<code>echo</code>命令的<code>-e</code>参数。  </p>
<p>  换行符是一个特殊字符，表示命令的结束，Bash收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash会将其当做空格处理，从而可以将一行命令写成多行。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv \</span><br><span class="line">/path/to/foo \</span><br><span class="line">/path/to/bar</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv /path/to/foo /path/to/bar</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>Bash的模式扩展：<br>    shell接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元，然后，shell会扩展词元里面的特殊字符，扩展完后才会调用相应的命令。  </p>
<ul>
<li><p>波浪线扩展  </p>
<p>  自动扩展成当前用户的主目录。  </p>
</li>
<li><p><code>?</code>字符扩展  </p>
<p>  代表文件路径里面的任意单个字符，不包括空字符。  </p>
</li>
<li><p><code>*</code>字符扩展  </p>
<p>  代表文件路径里面的任意数量的任意字符，包括零个字符。  </p>
</li>
<li><p>方括号扩展  </p>
<p>  1、匹配括号之中的任意一个字符。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。<br>  2、方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如[a-c]等同于[abc]，[0-9]匹配[0123456789]。  </p>
<p>  举例：  </p>
<pre><code>  [a-z]：所有小写字母；  
  [a-zA-Z]：所有小写字母与大写字母；  
  [a-zA-Z0-9]：所有小写字母、大写字母与数字；  
  [abc]*：所有以a、b、c字符之一开头的文件名；  
  program.[co]：文件program.c与文件program.o；  
  BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。  
</code></pre>
<p>  这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如[!a-zA-Z]表示匹配非英文字母的字符，[!1-3]表示排除1、2和3。  </p>
</li>
<li><p>大括号扩展  </p>
<p>  表示分别扩展成大括号<code>{...}</code>里面的所有值，各个值之间使用逗号分隔。比如{1,2,3}扩展成1 2 3。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d{a,e,i,o,u}g</span><br><span class="line">dag deg dig dog dug</span><br></pre></td></tr></tbody></table></figure>
<p>  1、大括号内部的逗号前后不能有空格，否则，大括号扩展会失效。  </p>
<p>  2、逗号前面可以没有值，表示扩展的第一项为空。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp a.log{,.bak}</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp a.log a.log.bak</span><br></pre></td></tr></tbody></table></figure>
<p>  3、大括号可以嵌套。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {j{p,pe}g,png}</span><br><span class="line">jpg jpeg png</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a{A{1,2},B{3,4}}b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></tbody></table></figure>
<p>  4、大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/{cat,b*}</span><br><span class="line">/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...</span><br></pre></td></tr></tbody></table></figure>
<p>  基本等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/cat;<span class="built_in">echo</span> /bin/b*</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展，等同于执行两条<code>echo</code>命令。  </p>
<p>  由于大括号扩展<code>{...}</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。  </p>
<p>  不存在 a.txt 和 b.txt 时：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [ab].txt</span><br><span class="line">[ab].txt</span><br><span class="line">$ <span class="built_in">echo</span> {a,b}.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></tbody></table></figure>

<p>  5、大括号扩展有一个简写形式<code>{start..end}</code>，表示扩展成一个连续序列。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}</span><br><span class="line">a b c</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式支持逆序：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {c..a}</span><br><span class="line">c b a</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式可以嵌套使用，形成复杂的扩展：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .{mp{3,4},m4{a,b,p,v}}</span><br><span class="line">.mp3 .mp4 .m4a .m4b .m4p .m4v</span><br></pre></td></tr></tbody></table></figure>

<p>  6、大括号扩展的常见用途：<br>  新建一系列目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir {2007..2009}-{01..12}</span><br></pre></td></tr></tbody></table></figure>
<p>  用于for循环：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..4}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果整数前面有前导0，扩展输出的每一项都有前导0：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {01..5}</span><br><span class="line">01 02 03 04 05</span><br><span class="line">$ <span class="built_in">echo</span> {001..5}</span><br><span class="line">001 002 003 004 005</span><br></pre></td></tr></tbody></table></figure>

<p>  7、这种简写形式还可以使用第二个双点号<code>(start..end..step)</code>，用来指定扩展的步长：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {0..8..2}</span><br><span class="line">0 2 4 6 8</span><br></pre></td></tr></tbody></table></figure>
<p>  多个简写形式连用，会有循环处理的效果：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}{1..3}</span><br><span class="line">a1 a2 a3 b1 b2 b3 c1 c2 c3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>变量扩展  </p>
<p>  Bash将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值。变量名除了放在美元符号后面，也可以放在<code>${}</code>里面。<br>  <code>${!string*}</code>或<code>${!string@}</code>返回所有匹配给定字符串string的变量名。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${!S*}</span></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，${!S*}扩展成所有以S开头的变量名。  </p>
</li>
<li><p>子命令扩展  </p>
<p>  <code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(date)</span><br><span class="line">Tue Jan 12 10:56:55 CST 2021</span><br><span class="line">$ file $(ls /usr/bin/* | grep zip)</span><br></pre></td></tr></tbody></table></figure>
<p>  还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `date`</span><br><span class="line">Tue Jan 12 10:58:51 CST 2021</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>$(...)</code>可以嵌套，比如：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(ls $(<span class="built_in">pwd</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>  利用子shell生成一个独立的进程：<br>  子shell本身就是独立的进程。可以使用<code>()</code>操作符来定义一个子shell：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>;</span><br><span class="line">(<span class="built_in">cd</span> /bin; ls);</span><br><span class="line"><span class="built_in">pwd</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  当命令在子shell中执行时，不会对当前shell有任何影响；所有的改变仅限于子shell内。例如，当用cd命令改变子shell的当前目录时，这种变化不会反映到主shell环境中。  </p>
</li>
<li><p>算术扩展  </p>
<p>  <code>$((...))</code>可以扩展成整数运算的结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符类  </p>
<p>  比如：<code>[[:digit:]]</code>匹配任意数字 0-9。  </p>
<p>  使用注意点：<br>  1、通配符是先解释，再执行。<br>  2、文件名扩展在不匹配时，会原样输出。<br>  3、只适用于单层路径。所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符<code>/</code>。  </p>
<pre><code>  如果要匹配子目录里面的文件，可以写成下面这样：  
</code></pre>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls */*.txt</span><br></pre></td></tr></tbody></table></figure>
<p>  4、文件名可以使用通配符。这时引用文件名，需要把文件名放在单引号里面。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch <span class="string">'fo*'</span></span><br><span class="line">$ ls</span><br><span class="line">fo*</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>量词语法  </p>
<p>  量词语法用来控制模式匹配的次数。它只有在Bash的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob on</span><br></pre></td></tr></tbody></table></figure>
<p>  量词语法有下面几个：<br>  <code>?(pattern-list)</code> - 匹配零个或一个模式<br>  <code>*(pattern-list)</code> - 匹配零个或多个模式<br>  <code>+(pattern-list)</code> - 匹配一个或多个模式<br>  <code>@(pattern-list)</code> - 只匹配一个模式<br>  <code>!(pattern-list)</code> - 匹配零个或一个以上的模式，但不匹配单独一个的模式  </p>
<p>  <code>shopt</code>命令可以调整Bash的行为。它有好几个参数跟通配符扩展有关。<br>  <code>shopt</code>命令的使用方法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>shell本身不支持正则表达式，使用正则表达式的是shell命令和工具。<br>正则表达式基本上是一种“表达式”， 只要工具程序支持这种表达式，那么该工具程序就可以用来作为正则表达式的字串处理之用。 例如 <code>vi</code>, <code>egrep</code>, <code>awk</code> , <code>sed</code>, <code>perl</code>, <code>less</code> 等等工具，因为她们有支持正则表达式， 所以，这些工具就可以使用正则表达式的特殊字符来进行字串的处理。但例如 <code>find</code>, <code>cp</code>, <code>ls</code>, <code>rm</code> 等系统命令一般并未支持正则表达式， 所以就只能使用 Bash 自己本身的通配符而已。</p>
<p>正则表达式元字符由以下字符组成：<br><code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>{ }</code> <code>-</code> <code>?</code> <code>*</code> <code>+</code> <code>( )</code> <code>|</code> <code>\</code>  </p>
<p>其他所有字符都被认为是原义字符。在个别情况下，反斜杠会被用来创建元序列，元字符也可以被转义为原义字符，而不是解释为元字符。<br>注意：正如我们所见到的，当 shell 执行展开的时候，许多正则表达式元字符，也是对 shell 有特殊 含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要，这样可以阻止 shell 试图展开它们。  </p>
<ol>
<li><p>任何字符  </p>
<p> 圆点字符，用来匹配任意字符。如果我们在正则表达式中包含它，它将会匹配在此位置的任意一个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ grep -h <span class="string">'.zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>锚点  </p>
<p> 在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式只有在文本行的开头或末尾被找到时，才算发生一次匹配。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ grep -h <span class="string">'^zip'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br><span class="line">zipcloak  </span><br><span class="line">zipgrep  </span><br><span class="line">zipinfo  </span><br><span class="line">zipnote  </span><br><span class="line">zipspli  </span><br><span class="line">$ grep -h <span class="string">'zip$'</span> dirlist*.txt  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">unzip  </span><br><span class="line">zip  </span><br><span class="line">$ grep -h <span class="string">'^zip$'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br></pre></td></tr></tbody></table></figure>

<p> 注意正则表达式<code>'ˆ$'</code>（行首和行尾之间没有字符）会匹配空行。  </p>
</li>
<li><p>中括号表达式和字符类  </p>
<p> 通过使用中括号表达式，能够从一个指定的字符集合（包含在不加中括号的情况下会被解释为元字符的字符）中匹配单个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep -h <span class="string">'[bg]zip'</span> dirlist*.txt  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gzip  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。 然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符 是插入字符<code>^</code>，其被用来表示否定；第二个是连字符字符<code>-</code>，其被用来表示一个字符范围。  </p>
</li>
<li><p>否定  </p>
<p> 如果在中括号表示式中的第一个字符是一个插入字符<code>^</code>，则剩余的字符被看作是不会在给定的字符位置出现的字符集合。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ grep -h <span class="string">'[^bg]zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">gunzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个否定的字符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员。<br> 插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。  </p>
</li>
<li><p>传统的字符区域  </p>
</li>
<li><p>POSIX字符集  </p>
<p> POSIX 把正则表达式的实现分成了两类： 基本正则表达式（BRE）和扩展的正则表达式（ERE）。  </p>
<p> BRE 和 ERE 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：  </p>
<p> <code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>*</code>  </p>
<p> 其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:  </p>
<p> <code>( )</code> <code>{ }</code> <code>?</code> <code>+</code> <code>|</code>  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -Eh <span class="string">'^(bz|gz|zip)'</span> dirlist*.txt  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>限定符  </p>
<p> 扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。  </p>
<ul>
<li><code>?</code> - 匹配零个或一个元素  </li>
<li><code>*</code> - 匹配零个或多个元素  </li>
<li><code>+</code> - 匹配一个或多个元素  </li>
<li><code>{}</code> - 匹配特定个数的元素  </li>
</ul>
<p> <code>{}</code>元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：  </p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">意思</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">匹配前面的元素，如果它确切地出现了 n 次</td>
</tr>
<tr>
<td align="left">n,m</td>
<td align="left">匹配前面的元素，如果它至少出现了n次，但是不多于m次</td>
</tr>
<tr>
<td align="left">n,</td>
<td align="left">匹配前面的元素，如果它出现了n次或多于n次</td>
</tr>
<tr>
<td align="left">,m</td>
<td align="left">匹配前面的元素，如果它出现的次数不多于m次</td>
</tr>
</tbody></table>
</li>
</ol>
<p>正则表达式的基本组成部分：  </p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">行起始标记</td>
<td align="left">^tux匹配以tux起始的行</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">行尾标记</td>
<td align="left">tux$匹配以tux结尾的行</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意一个字符</td>
<td align="left">Hack.匹配Hackl和Hacki，但是不匹配Hackl2和Hackil，它只能匹配单个字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">匹配包含在[字符]之中的任意一个字符</td>
<td align="left">coo[kl]匹配cook或cool</td>
</tr>
<tr>
<td align="left">[^]</td>
<td align="left">匹配除[^字符]之外的任意一个字符</td>
<td align="left">9[^01]匹配92、93，但是不匹配91或90</td>
</tr>
<tr>
<td align="left">[-]</td>
<td align="left">匹配[]中指定范围内的任意一个字符</td>
<td align="left">[1-5]匹配从1~5的任意一个数字</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配之前的项1次或0次</td>
<td align="left">colou?r匹配color或colour，但是不能匹配colouur</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配之前的项1次或多次</td>
<td align="left">Rollno-9+匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配之前的项0次或多次</td>
<td align="left">co*l匹配cl、col、coool等</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">创建一个用于匹配的子串</td>
<td align="left">ma(tri)?x匹配max或matrix</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">匹配之前的项n次</td>
<td align="left">[0-9]{3}匹配任意一个三位数，[0-9]{3}可以扩展为[0-9][0-9][0-9]</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">之前的项至少需要匹配n次</td>
<td align="left">[0-9]{2,}匹配任意一个两位或更多位的数字</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">指定之前的项所必须匹配的最小次数和最大次数</td>
<td align="left">[0-9]{2,5}匹配从两位数到五位数之前的任意一个数字</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">交替一一匹配|两边的任意一项</td>
<td align="left">Oct(1st|2nd)匹配Oct 1st或Oct 2nd</td>
</tr>
</tbody></table>
<h2 id="sed入门"><a href="#sed入门" class="headerlink" title="sed入门"></a>sed入门</h2><p>名字 <code>sed</code> 是 stream editor（流编辑器）的简称。  </p>
<p><code>sed</code>地址表示法：  </p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">行号，n是一个正整数</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">最后一行</td>
</tr>
<tr>
<td align="left">/regexp/</td>
<td align="left">所有匹配一个POSIX基本正则表达式的文本行。注意正则表达式通过斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc来指定表达式，这里c就是一个备用字符</td>
</tr>
<tr>
<td align="left">addr1,addr2</td>
<td align="left">从addr1到addr2范围内的文本行，包含地址addr2在内。地址可能是上述任意单独的地址形式</td>
</tr>
<tr>
<td align="left">first~step</td>
<td align="left">匹配由数字first代表的文本行，然后随后的每个在step间隔处的文本行。例如1<del>2是指每个位于偶数行号的文本行，5</del>5则指第五行和之后每五行位置的文本行</td>
</tr>
<tr>
<td align="left">addr1,+n</td>
<td align="left">匹配地址addr1和随后的n个文本行</td>
</tr>
<tr>
<td align="left">addr!</td>
<td align="left">匹配所有的文本行，除了addr之外，addr可能是上述任意的地址形式</td>
</tr>
</tbody></table>
<p><code>sed</code>基本编辑命令：  </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">输出当前的行号。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">在当前行之后追加文本。</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">删除当前行。</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">在当前行之前插入文本。</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">打印当前行。默认情况下，sed程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定-n选项，这个默认的行为能够被忽略。</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">退出sed，不再处理更多的文本行。如果不指定-n选项，输出当前行。</td>
</tr>
<tr>
<td align="left">Q</td>
<td align="left">退出sed，不再处理更多的文本行。</td>
</tr>
<tr>
<td align="left">s/regexp/replacement/</td>
<td align="left">只要找到一个regexp匹配项，就替换replacement的内容。replacement可能包括特殊字符&amp;，其等价于由regexp匹配的文本。另外，replacement可能包括序列\1到\9，其是regexp中相对应的子表达式的内容。在replacement末尾的斜杠之后，可以指定一个可选的标志，来修改s命令的行为。</td>
</tr>
<tr>
<td align="left">y/set1/set2</td>
<td align="left">执行字符转写操作，通过把set1中的字符转变为相对应的set2中的字符。注意不同于tr程序，sed要求两个字符集合具有相同的长度。（y命令不支持字符区域（例如，[a-z]），也不支持POSIX字符集。）</td>
</tr>
</tbody></table>
<p><strong>逆参照</strong>：如果序列<code>\n</code>出现在<code>replacement</code>中，这里<code>n</code>是指从1到9的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来。  </p>
<p><code>s</code>命令的另一个功能是使用<strong>可选标志</strong>，其跟随替代字符串。一个最重要的可选标志是<code>g</code>标志，其指示sed对某个文本行全范围地执行查找和替换操作，不仅仅是对第一个实例，这是默认行为。这里有个例子：  </p>
<p>例子：  </p>
<ul>
<li><p>替换  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/text/replace/g'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p><code>-i</code>可以将替换结果应用于原文件。<br><code>/g</code>意味着<code>sed</code>会替换每一处匹配。  </p>
</li>
<li><p>移除空白行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p>空白行可以用正则表达式<code>^$</code>进行匹配。<br><code>/pattern/d</code>会移除匹配样式的行。  </p>
</li>
<li><p>已匹配字符串标记&amp;<br>在<code>sed</code>中，用<code>&amp;</code>标记匹配样式的字符串，就能够在替换字符串时使用已匹配的内容。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span>  </span><br><span class="line">[this] [is] [an] [example]  </span><br></pre></td></tr></tbody></table></figure>
<p>正则表达式<code>\w\+</code>匹配每一个单词，然后我们用<code>[&amp;]</code>替换它。<code>&amp;</code>对应于之前所匹配到的单词。  </p>
</li>
<li><p>子串匹配标记\1<br><code>&amp;</code>代表匹配给定样式的字符串。但我们也可以匹配给定样式的其中一部分。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1'</span>  </span><br><span class="line">this is 7 <span class="keyword">in</span> a number  </span><br></pre></td></tr></tbody></table></figure>
<p>这条命令将digit 7替换为7。样式中匹配到的子串是7。<code>\(pattern\)</code>用于匹配子串。模式被包括在使用斜线转义过的<code>()</code>中。对于匹配到的第一个子串，其对应的标记是<code>\1</code>，匹配到的第二个子串是<code>\2</code>，往后依次类推。<br>下面的示例中包含了多个匹配：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> seven EIGHT | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1'</span></span><br><span class="line">EIGHT seven</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>组合多个表达式<br>利用管道组合多个<code>sed</code>命令可以用下面的方式代替：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'expression; expression'</span> <span class="comment"># sed 'expression' | sed 'expression'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>引用<br><code>sed</code>表达式通常用单引号来引用。不过也可以使用双引号。双引号会通过对表达式求值来对其进行扩展。当我们想在sed表达式中使用一些变量字符串时，双引号就有用武之地了。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ text=hello</span><br><span class="line">$ <span class="built_in">echo</span> hello world | sed <span class="string">"s/<span class="variable">$text</span>/HELLO/"</span></span><br><span class="line">HELLO world</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>其他例子：替换文本或文件中的字符串<br>用另一个指定的数字替换文件中所有的3位数字：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat sed_data.txt</span><br><span class="line">11 abc 111 this 9 file contains 111 11 88 numbers 0000</span><br><span class="line">$</span><br><span class="line">$ cat sed_data.txt | sed <span class="string">'s/\b[0-9]\{3\}\b/NUMBER/g'</span></span><br><span class="line">11 abc NUMBER this 9 file contains NUMBER 11 88 numbers 0000</span><br></pre></td></tr></tbody></table></figure>
<p>上面的单行命令只替换3位数字。\b[0-9]{3}\b是一个用于匹配3位数字的正则表达式。[0-9]表示从0到9的数字范围。{3}用来匹配3次之前的数字。{3}中的<code>\</code>用于赋予<code>{</code>和<code>}</code>特殊的含义。<code>\b</code>是单词边界标记。  </p>
</li>
</ul>
<h2 id="awk入门"><a href="#awk入门" class="headerlink" title="awk入门"></a>awk入门</h2><p><code>awk</code>脚本的结构基本如下所示：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN{ commands } pattern{ commands } END{ commands }'</span> file  </span><br></pre></td></tr></tbody></table></figure>
<p>一个<code>awk</code>脚本通常由3部分组成：<code>BEGIN</code>语句块、<code>END</code>语句块和能够使用模式匹配的通用语句块。这3个部分是可选的，它们中任何一个部分都可以不出现在脚本中。脚本通常会被包含在单引号或双引号中。  </p>
<p><code>awk</code>命令的工作方式如下所示：<br>执行<code>BEGIN{ commands }</code>语句块中的语句。<br>从文件或<code>stdin</code>中读取一行，然后执行<code>pattern{ commands }</code>。重复这个过程，直到文件全部被读取完毕。<br>当读至输入流(input steam)末尾时，执行<code>END{ commands }</code>语句块。  </p>
<p><code>BEGIN</code>语句块在<code>awk</code>开始从输入流中读取行之前被执行。这是一个可选的语句块，诸如变量的初始化、打印输出表格的表头等语句通常都可以写入<code>BEGIN</code>语句块中。<br><code>END</code>语句块和<code>BEGIN</code>语句块类似。<code>END</code>语句块在<code>awk</code>从输入流中读取完所有的行之后即被执行。像打印所有行的分析结果这类汇总信息，都是在<code>END</code>语句块中实现的常见任务（例如，在比较过所有的行之后，打印出最大数）。它也是一个可选的语句块。<br>最需要的部分就是<code>pattern</code>语句块中的通用命令。这个语句块同样是可选的。如果不提供该语句块，则默认执行<code>{ print }</code>，即打印每一个读取到的行。<code>awk</code>对于读取的每一行，都会执行这个语句块。  </p>
<p>这就像一个用来读取行的<code>while</code>循环，在循环体中提供了相应的语句。<br>每读取一行时，它就会检查该行和提供的样式是否匹配。样式本身可以是正则表达式、条件以及行匹配范围等。如果当前行匹配该样式，则执行<code>{}</code>中的语句。<br>样式是可选的。如果没有提供样式，那么它就会默认所有的行都是匹配的，并执行<code>{}</code>中的语句。  </p>
<p>关于<code>print</code>：<br>当<code>print</code>的参数是以逗号进行分割时，参数打印时则以空格作为定界符；<br>在<code>awk</code>的<code>print</code>语句中，双引号是被当作拼接操作符使用的。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1"-"var2"-"var3; }'</span>  </span><br><span class="line">v1-v2-v3  </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>特殊变量<br>以下是可用于<code>awk</code>的一些特殊变量：  </p>
<ul>
<li><code>NR</code> - 表示记录数量，在执行过程中对应于当前行号  </li>
<li><code>NF</code> - 表示字段数量，在执行过程中对应于当前行的字段数  </li>
<li><code>$0</code> - 这个变量包含执行过程中当前行的文本内容  </li>
<li><code>$1</code> - 这个变量包含第一个字段的文本内容  </li>
<li><code>$2</code> - 这个变量包含第二个字段的文本内容<br>例如：  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3\nline2 f4 f5\nline3 f6 f7"</span> | \</span><br><span class="line">awk <span class="string">'{print "Line no:"NR", No of fields:"NF", $0="$0", $1="$1", $2="$2", $3="$3""}'</span></span><br><span class="line">Line no:1, No of fields:3, <span class="variable">$0</span>=line1 f2 f3, <span class="variable">$1</span>=line1, <span class="variable">$2</span>=f2, <span class="variable">$3</span>=f3</span><br><span class="line">Line no:2, No of fields:3, <span class="variable">$0</span>=line2 f4 f5, <span class="variable">$1</span>=line2, <span class="variable">$2</span>=f4, <span class="variable">$3</span>=f5</span><br><span class="line">Line no:3, No of fields:3, <span class="variable">$0</span>=line3 f6 f7, <span class="variable">$1</span>=line3, <span class="variable">$2</span>=f6, <span class="variable">$3</span>=f7</span><br></pre></td></tr></tbody></table></figure>
可以用<code>print $NF</code>打印一行中最后一个字段，用<code>$(NF-1)</code>打印倒数第二个字段，其他字段依次类推即可。<br><code>awk</code>的<code>printf()</code>函数的语法和C语言中的同名函数一样。可以用这个函数来代替<code>print</code>。  </li>
</ul>
</li>
<li><p>将外部变量值传递给<code>awk</code><br>借助选项<code>-v</code>，可以将外部值（并非来自<code>stdin</code>）传递给<code>awk</code>：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ VAR=10000</span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'{ print VARIABLE }'</span></span><br><span class="line">10000</span><br></pre></td></tr></tbody></table></figure>
<p>还有另一种灵活的方法可以将多个外部变量传递给<code>awk</code>，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var1=<span class="string">"Variable1"</span>; var2=<span class="string">"Variable2"</span></span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ print v1,v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line">Variable1 Variable2</span><br></pre></td></tr></tbody></table></figure>
<p>当输入来自于文件而非标准输入时，使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'{ print v1 v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的方法中，变量之间用空格分隔，以键-值对的形式（v1=$var1 v2=$var2）作为<code>awk</code>的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。  </p>
</li>
<li><p>用<code>getline</code>读取行  </p>
</li>
<li><p>用样式对<code>awk</code>处理的行进行过滤<br>可以为需要处理的行指定一些条件，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR &lt; 5'</span>      <span class="comment"># 行号小于5的行</span></span><br><span class="line">$ awk <span class="string">'NR==1,NR==4'</span> <span class="comment"># 行号在1到4之间的行</span></span><br><span class="line">$ awk <span class="string">'/linux/'</span>     <span class="comment"># 包含样式linux的行（可以用正则表达式来指定样式）</span></span><br><span class="line">$ awk <span class="string">'!/linux/'</span>    <span class="comment"># 不包含样式linux的行</span></span><br></pre></td></tr></tbody></table></figure>
<p>要打印处于start_pattern与end_pattern之间的文本，使用下面的语法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/start_pattern/, /end_pattern/'</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat section.txt</span><br><span class="line">line with pattern1</span><br><span class="line">line with pattern2</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br><span class="line">line with pattern5</span><br><span class="line">$</span><br><span class="line">$ awk <span class="string">'/pa.*3/, /end/'</span> section.txt</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设定字段定界符<br>默认的字段定界符是空格。我们也可以用 <code>-F "delimiter"</code> 明确指定一个定界符。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">'{ print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure>
<p>或者  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN { FS=":" } { print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>从<code>awk</code>中读取命令输出<br>在下面的代码中，<code>echo</code>会生成一个空白行。变量cmdout包含命令grep root /etc/passwd的输出，然后打印包含root的行；<br>将command的输出读入变量output的语法如下：<br>“command” | getline output ;<br>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ "grep root /etc/passwd" | getline cmdout ; print cmdout }'</span>  </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>通过使用<code>getline</code>，能够将外部shell命令的输出读入变量cmdout。</p>
</li>
</ul>
<p>遇到的问题：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/rj042/article/details/72860177"><code>awk</code>中不能使用<code>shell</code>定义的变量，使用<code>-v</code>选项</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34236675/kill-command-doesnt-work-in-awk"><code>kill</code>在<code>awk</code>中无所有</a></li>
</ol>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><p><code>!n</code> - 执行历史文件里面行号为n的命令<br><code>!string</code> - 执行最近一个以指定字符串string开头的命令<br><code>!?string</code> - 执行最近一条包含字符串string的命令<br><code>Alt + .</code> - 插入上一个命令的最后一个词<br><code>Ctrl + k</code> - 剪切光标位置到行尾的文本<br><code>Ctrl + u</code> - 剪切光标位置到行首的文本<br><code>Ctrl + y</code> - 在光标位置粘贴文本<br><code>Ctrl + r</code> - 反向增量搜索。从当前命令行开始，向上增量搜索。意思是在字符输入的同时，bash会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入<code>Ctrl-r</code>来启动增量搜索，接着输入你要寻找的字。当你找到它以后，你可以敲入<code>Enter</code>来执行命令，或者输入<code>Ctrl-j</code>，从历史列表中复制这一行到当前命令行。再次输入<code>Ctrl-r</code>，来找到下一个匹配项（历史列表中向上移动）。输入<code>Ctrl-g</code>或者<code>Ctrl-c</code>，退出搜索。  </p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul>
<li><p>移动光标  </p>
<p>  <code>0</code> - (零按键) 移动到当前行的行首<br>  <code>^</code> - 移动到当前行的第一个非空字符<br>  <code>$</code> - 移动到当前行的末尾  </p>
</li>
<li><p>基本编辑  </p>
<p>  <code>u</code> - 撤销<br>  <code>Ctrl + r</code> - 反撤销  </p>
</li>
<li><p>打开一行  </p>
<p>  <code>o</code> - 当前行的下方打开一行<br>  <code>O</code> - 当前行的上方打开一行  </p>
</li>
<li><p>删除文本  </p>
<p>  <code>d$</code> - 从光标位置开始到当前行的行尾<br>  <code>d0</code> - 从光标位置开始到当前行的行首<br>  <code>d^</code> - 从光标位置开始到文本行的第一个非空字符<br>  <code>dG</code> - 从当前行到文件的末尾  </p>
</li>
<li><p>复制文本  </p>
<p>  <code>y$</code> - 从当前光标位置到当前行的末尾<br>  <code>y0</code> - 从当前光标位置到行首<br>  <code>y^</code> - 从当前光标位置到文本行的第一个非空字符<br>  <code>yG</code> - 从当前行到文件末尾  </p>
</li>
<li><p>连接行  </p>
<p>  <code>J</code>  </p>
</li>
</ul>
<ul>
<li><p>编辑多个文件  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim file1 file2 file3 ...</span><br></pre></td></tr></tbody></table></figure>
<p>  文件之间的切换：  </p>
<p>  从这个文件切换到下一个文件<code>:n</code>；<br>  回到先前的文件<code>:N</code>。  </p>
<p>  查看正在编辑的文件列表，使用<code>:buffers</code>命令。  </p>
<p>  要切换到另一个缓冲区（文件），输入<code>:buffer</code>, 紧跟着你想要编辑的缓冲器编号。  </p>
<p>  跨文件复制粘贴：正常复制粘贴。  </p>
</li>
</ul>
<h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><ul>
<li><p>内建功能  </p>
<p>  <code>set -x</code> - 在执行时显示参数和命令<br>  <code>set +x</code> - 禁止调试<br>  <code>set -v</code> - 当命令进行读取时显示输入<br>  <code>set +v</code> - 禁止打印输入  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：debug.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..6}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">set</span> x</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Script executed"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  在上面的脚本中，仅在<code>-x</code>和<code>+x</code>所限制的区域，echo $i的调试信息才会被打印出来。  </p>
<p>  有一些环境变量常用于调试：<br>  <code>LINENO</code> - 返回它在脚本里面的行号<br>  <code>FUNCNAME</code> - 返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数，以此类推<br>  <code>BASH_SOURCE</code> - 返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本，以此类推，跟变量<code>FUNCNAME</code>是一一对应关系<br>  <code>BASH_LINENO</code> - 返回一个数组，内容是每一轮调用对应的行号  </p>
<p>  <code>${BASH_LINENO[$i]}</code>跟<code>${FUNCNAME[$i]}</code>是一一对应关系，表示<code>${FUNCNAME[$i]}</code>在调用它的脚本文件<code>${BASH_SOURCE[$i+1]}</code>里面的行号</p>
</li>
<li><p>自定义格式  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">DEBUG</span></span>()</span><br><span class="line">{</span><br><span class="line">[ <span class="string">"<span class="variable">$_DEBUG</span>"</span> == <span class="string">"on"</span> ] &amp;&amp; <span class="variable">$@</span> || :</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..10}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  可以将调试功能置为”on”来运行上面的脚本：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>shebang  </p>
<p>  把<code>shebang</code>从<code>#!/bin/bash</code>改成<code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p>
</li>
</ul>
<ul>
<li><p>注释  </p>
<p>  单行注释：<code>#</code><br>  多行注释：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="string">'!'</span></span><br><span class="line">commands</span><br><span class="line">...</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">ps -aux</span><br></pre></td></tr></tbody></table></figure>

<p>用 <code>top</code> 命令动态查看进程。  </p>
<p>中断一个进程<code>Ctrl+c</code>。  </p>
<p>把一个进程放置到后台 (执行)：在程序命令之后，加上<code>&amp;</code>字符：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 <code>jobs</code> 命令，可以看到输出列表：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>进程返回到前台：<br>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 <code>Ctrl-c</code> 来中断它。为了让一个进程返回前台 (foreground)，这样使用 <code>fg</code> 命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">xlogo</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>fg</code> 命令，可以恢复程序到前台运行，或者用 <code>bg</code> 命令把程序移到后台。  </p>
<p>停止一个进程<code>Ctrl+z</code>：输入 <code>Ctrl-z</code>，可以停止一个前台进程。  </p>
<p>通过 <code>kill</code> 命令给进程发送信号。<br>通过 <code>killall</code> 命令给多个进程发送信号。  </p>
<h3 id="目录堆栈"><a href="#目录堆栈" class="headerlink" title="目录堆栈"></a>目录堆栈</h3><ul>
<li><p><code>cd -</code>  </p>
</li>
<li><p><code>pushd</code>, <code>popd</code>  </p>
<p>  希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。<br>  <code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span> dirname</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令会进入目录dirname，并将该目录放入堆栈。<br>  <code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。  </p>
<ul>
<li><p><code>-n</code><br>  表示仅操作堆栈，不改变目录。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">popd</span> -n</span><br></pre></td></tr></tbody></table></figure>
<p>  上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。  </p>
</li>
<li><p>整数参数  </p>
</li>
<li><p>目录参数  </p>
</li>
</ul>
</li>
<li><p><code>dirs</code>  </p>
<p>  <code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。  </p>
<p>  参数：  </p>
<pre><code>  `-c`：清空目录栈。  
  `-l`：用户主目录不显示波浪号前缀，而打印完整的目录。  
  `-p`：每行一个条目打印目录栈，默认是打印在一行。  
  `-v`：每行一个条目，每个条目之前显示位置编号（从0开始）。  
</code></pre>
</li>
</ul>
<h3 id="校验和核实"><a href="#校验和核实" class="headerlink" title="校验和核实"></a>校验和核实</h3><ul>
<li><p><code>md5sum</code>  </p>
<p>  将输出的校验和重定向到一个文件，然后用这个MD5文件核实数据的完整性：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum filename &gt; file_num.md5</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ md5sum -c file_sum.md5</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>sha1sum</code>  </p>
<p>  用法与md5sum类似：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum filename &gt; file_num.sha1</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum -c file_sum.sha1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><p><code>-t</code>参数 - 设置超时秒数<br><code>-p</code>参数 - 指定用户输入的提示信息<br><code>-a</code>参数 - 把用户的输入赋值给一个数组，从零号位置开始<br><code>-n</code>参数 - 指定只读取若干个字符作为变量值，而不是整行读取<br><code>-e</code>参数 - 允许用户输入的时候，使用ReadLine库提供的快捷键，比如自动补全<br>其他参数 - 其他参数功能  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter one or more values &gt; "</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"REPLY = '<span class="variable">$REPLY</span>'"</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"What do you want? </span></span><br><span class="line"><span class="string">    1) AAA</span></span><br><span class="line"><span class="string">    2) BBB</span></span><br><span class="line"><span class="string">    3) CCC</span></span><br><span class="line"><span class="string">    Type your choice: "</span> MyChoice</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MyChoice</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="生成任意大小的文件"><a href="#生成任意大小的文件" class="headerlink" title="生成任意大小的文件"></a>生成任意大小的文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></tbody></table></figure>
<p>该命令会创建一个1MB大小的文件junk.data。<br><code>if</code>代表输入文件(Input File)，<code>of</code>代表输出文件(Output File)，<code>bs</code>代表以字节为单位的块大小(Block Size)，<code>count</code>代表需要被复制的块数。  </p>
<h3 id="压缩归档文件"><a href="#压缩归档文件" class="headerlink" title="压缩归档文件"></a>压缩归档文件</h3><p>选项<code>-a</code>指定从文件扩展名自动判断压缩格式。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cavf archive.tar.gz [FILES]</span><br><span class="line">$ tar -cavf archive.tar.bz2 [FILES]</span><br><span class="line">$ tar -cavf archive.tar.lzma [FILES]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf archive.tar.gz</span><br><span class="line">$ tar -xvf archive.tar.bz2</span><br><span class="line">$ tar -xvf archive.tar.lzma</span><br></pre></td></tr></tbody></table></figure>

<h3 id="mktemp命令"><a href="#mktemp命令" class="headerlink" title="mktemp命令"></a>mktemp命令</h3><p><code>mktemp</code>命令就是为安全创建临时文件而存在的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。  </p>
<p>Bash脚本使用<code>mktemp</code>命令的用法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了确保临时文件创建成功，<code>mktemp</code>命令后面最好使用OR运算符<code>||</code>，保证创建失败时退出脚本。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>mktemp</code>命令的参数：<br><code>-d</code>参数可以创建一个临时目录。<br><code>-p</code>参数可以指定临时文件所在的目录。默认是使用$TMPDIR环境变量指定的目录，如果这个变量没设置，那么使用/tmp目录。<br><code>-t</code>参数可以指定临时文件的文件名模板。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mktemp -t mytemp.XXXXXXX -p <span class="built_in">test</span>/</span><br></pre></td></tr></tbody></table></figure>


<h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h3><p><code>trap</code>命令用来在Bash脚本中响应系统信号。<br><code>trap</code>的命令格式如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> [动作] [信号1] [信号2] ...</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，”动作”是一个Bash命令，”信号”常用的有以下几个。<br>HUP：编号1，脚本与所在的终端脱离联系。<br>INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。<br>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。<br>KILL：编号9，该信号用于杀死进程。<br>TERM：编号15，这是kill命令发出的默认信号。<br>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。  </p>
<p><code>trap</code>命令响应EXIT信号的写法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br></pre></td></tr></tbody></table></figure>
<p>上面命令中，脚本遇到EXIT信号时，就会执行rm -f “$TMPFILE”。  </p>
<p>trap命令的常见使用场景，就是在Bash脚本中指定退出时执行的清理命令。<br>注意，trap命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。  </p>
<p>如果trap需要触发多条命令，可以封装一个Bash函数。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> egress {</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	command3</span><br><span class="line">}</span><br><span class="line"><span class="built_in">trap</span> egress EXIT</span><br></pre></td></tr></tbody></table></figure>


<h3 id="set命令-shopt命令"><a href="#set命令-shopt命令" class="headerlink" title="set命令,shopt命令"></a>set命令,shopt命令</h3><p><strong>set -u</strong> - 遇到不存在的变量就会报错，并停止执行<br><strong>set -x</strong> - 在运行结果之前，先输出执行的那一行命令<br>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。  </p>
<p>Bash的错误处理<br>如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。这种行为很不利于脚本安全和除错。<br>实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> || <span class="built_in">exit</span> 1</span><br></pre></td></tr></tbody></table></figure>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。<br>写法一：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> || { <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; }</span><br></pre></td></tr></tbody></table></figure>
<p>写法二：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>
<p>写法三：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></tbody></table></figure>

<p><strong>set -e</strong><br>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。<br><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。  </p>
<p>还有一种方法是使用command || true，使得该命令即使执行失败，脚本也不会终止执行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">foo || <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，true使得这一行语句总是会执行成功，后面的echo bar会执行。  </p>
<p><strong>set -o pipefail</strong><br><code>set -e</code>有一个例外情况，就是不适用于管道命令。<br>所谓管道命令，就是多个子命令通过管道运算符<code>|</code>组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。<br><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。  </p>
<p><strong>set -E</strong><br>一旦设置了<code>-e</code>参数，会导致函数内的错误不会被<code>trap</code>命令捕获。<br><code>-E</code>参数可以纠正这个行为，使得函数也能继承<code>trap</code>命令。  </p>
<p><strong>其他参数</strong>  </p>
<p><code>set</code>命令总结：<br>上面重点介绍的<code>set</code>命令的几个参数，一般都放在一起使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -Eeuxo pipefail</span><br></pre></td></tr></tbody></table></figure>
<p>建议放在所有Bash脚本的头部。  </p>
<p><code>shopt</code>命令<br><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。<br><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。<br><code>shopt</code>命令的使用方法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>我们可以用管道将一个命令的<code>stdout</code>(标准输出)重定向到另一个命令的<code>stdin</code>(标准输入)。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat foo.txt | grep <span class="string">"test"</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，有些命令只能以命令行参数的形式，而无法通过<code>stdin</code>接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据。  </p>
<p><code>xargs</code>能够处理<code>stdin</code>并将其转换为特定命令的命令行参数；<code>xargs</code>也可以将单行或多行文本输入转换成其他格式，例如单行变多行或是多行变单行。  </p>
<p><code>-d</code>: 为输入指定一个定制的定界符。<br><code>-n</code>: 指定每行最大的参数数量。<br><code>-I</code>: 指定一个替换字符串，对于每一个参数，命令都会被执行一次。  </p>
<p>例子1：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X  </span><br><span class="line">split split split split  </span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2  </span><br><span class="line">split split  </span><br><span class="line">split split  </span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>

<p>例子2：<br>有一个cecho.sh脚本：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：cecho.sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*<span class="string">'#'</span></span><br></pre></td></tr></tbody></table></figure>

<p>有一个args.txt文件：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt  </span><br><span class="line">arg1  </span><br><span class="line">arg2  </span><br><span class="line">arg3  </span><br></pre></td></tr></tbody></table></figure>

<p>试试如下用法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l  </span><br><span class="line">-p arg1 -l <span class="comment">#  </span></span><br><span class="line">-p arg2 -l <span class="comment">#  </span></span><br><span class="line">-p arg3 -l <span class="comment">#  </span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>less</code> - 浏览文件内容<br><code>which</code> - 查找可执行文件的绝对路径<br><code>whereis</code> - 查找命令、二进制文件、man文件、源代码文件<br><code>wc</code> - 打印行数、字数和字节数<br><code>diff/patch</code>    </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ diff -Naur old_file new_file &gt; diff_file  </span><br><span class="line">$ patch &lt; diff_file  </span><br></pre></td></tr></tbody></table></figure>

<p><code>history</code> - 显示历史列表内容<br><code>df</code> - 显示磁盘分区上可以使用的磁盘空间<br><code>du</code> - 显示每个文件和目录的磁盘使用空间 </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ du -sh <span class="comment">#查看当前目录总计容量</span></span><br><span class="line">232G	.</span><br></pre></td></tr></tbody></table></figure>

<p><code>free</code> - 显示内存<br><code>file</code> - 识别文件类型<br><code>sort</code> - 排序文本行<br><code>uniq</code> - 报道或省略重复行<br><code>cut</code> - 从每行中删除文本区域<br><code>paste</code> - 合并文件文本行<br><code>join</code> - 基于某个共享字段来联合两个文件的文本行<br><code>comm</code> - 逐行比较两个有序的文件<br><code>tr</code> - 翻译或删除字符<br><code>grep</code> - 打印匹配行<br><code>ln file link</code> - 创建硬链接<br><code>ln -s item link</code> - 创建链接符号，item可以是一个文件或是一个目录<br>    当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中， <code>ls</code>命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。<br>    当建立符号链接时，你既可以使用绝对路径名，也可用相对路径名。<br>    不同目录，创建链接符号需要绝对地址，否则也是坏链接，会提示找不到文件。<br><code>rsync</code> - 备份/同步<br><code>time</code> - 计算命令执行时间<br><code>find</code> - 在一个目录层次结构中搜索文件<br><code>touch</code> - 更改文件时间<br><code>stat</code> - 显示文件或文件系统状态<br><code>alias</code> - 别名  </p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>date</code> - 获取、设置日期<br><code>sleep</code> - 延时  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/394186543">[Linux资讯] Cshell 怎样实现变量名包含变量名？</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://man.linuxde.net/">Linux命令大全</a>  </li>
<li><a target="_blank" rel="noopener" href="https://www.linuxcool.com/pronunciation">中国程序员最容易读错的单词汇总（带正确发音示范）</a>  </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljlfather/article/details/105106875">Bash Shell 中的 算术运算符、逻辑与或非(&amp; | ！)运算符、整数关系运算符、字符串关系运算符、文件或目录测试运算符</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/shell/" rel="tag"># shell</a>
              <a href="/tags/script/" rel="tag"># script</a>
              <a href="/tags/bash/" rel="tag"># bash</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/19/extract-super-img/" rel="prev" title="Android10 super.img解包方法">
                  <i class="fa fa-chevron-left"></i> Android10 super.img解包方法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/31/jq/" rel="next" title="jq使用">
                  jq使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ylab324</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ylab324","count":false,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/Gantzert_Felixander.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
