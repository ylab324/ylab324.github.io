<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>How to install and initialize Manjaro OS</title>
    <url>/2017/04/03/manjaro-install-and-initial-guide/</url>
    <content><![CDATA[<p>记录一次Manjaro安装流程。</p>
<span id="more"></span>

<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>一、安装系统  </p>
<ol>
<li>df –&gt;确认U盘名称和路径  </li>
<li>umount sdb1 –&gt;卸载已挂载的U盘  </li>
<li>dd if=/home/manjaro-xfce-17.0-stable-x86_64.iso of=/dev/sdb –&gt;dd命令中的目标是sdb，没有标号  </li>
<li>install boot non-free –&gt;对于双显卡驱动，安装的时候boot选择non-free，如果boot default的话，装好系统以后也可以在设置里安装bumblebee  </li>
</ol>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>二、系统初始配置  </p>
<ol>
<li>sudo pacman-mirrors -g –&gt;排列源  </li>
<li>sudo pacman-optimize&amp;&amp;sync –&gt;同步，碎片整理。固态硬盘不能用pacman-optimize  </li>
<li>sudo pacman -Syyu –&gt;升级系统  </li>
<li>sudo nano /etc/pacman.conf –&gt;添加ArchLinuxCN源  </li>
<li>sudo pacman -Syyu –&gt;同步  </li>
<li>sudo pacman -S archlinuxcn-keyring –&gt;导入GPG Key  </li>
</ol>
<h3 id="Basic-Tools"><a href="#Basic-Tools" class="headerlink" title="Basic Tools"></a>Basic Tools</h3><p>三、安装基础软件  </p>
<ol>
<li>sudo pacman -Syu yaourt –&gt;Archlinux的软件包管理工具是Pacman，而yaourt工具可以安装AUR(Archlinux官方不支持)的软件  </li>
<li>yaourt screenfetch –&gt;一个能够在终端显示系统/主题信息的命令行脚本  </li>
<li>yaourt vim –&gt;文本编辑工具  </li>
<li>yaourt lantern –&gt;科学上网工具  </li>
<li>yaourt sogou –&gt;搜狗输入法<br> 进入fcitx config gui异常，还需安装fcitx-configtool；<br> vim ~/.xprofile,添加<br> export GTK_IM_MODULE=fcitx<br> export QT_IM_MODULE=fcitx<br> export XMODIFIERS=”@im=fcitx”<br> 注销重新登录系统<br> 还是不行，执行fcitx -diagnose命令诊断，然后执行对应的修复  </li>
<li>yaourt uget –&gt;Firefox可以通过添加FlashGot插件把uget设置为其默认下载管理器  </li>
<li>yaourt qq –&gt;安装QQ  </li>
<li>yaourt netease –&gt;安装网易云音乐  </li>
<li>yaourt wechat –&gt;安装微信  </li>
<li>安装zsh<br>安装 zsh: sudo pacman -S zsh<br>配置 oh-my-zsh: sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</a><br>更换默认的 shell: chsh -s /bin/zsh<br>重启  </li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/1970/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>把时间当作朋友</title>
    <url>/2017/03/06/be-frd-with-time/</url>
    <content><![CDATA[<p>2月份读完了《把时间当作朋友》这本书，现在才来记录，有点晚了。作者从心智的角度考虑问题，有种醍醐灌顶的感觉。</p>
<span id="more"></span>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>书本的章节编排：  </p>
<ol start="0">
<li>所有人的困境</li>
<li>心智的力量</li>
<li>开启自己的心智</li>
<li>通过管理自己与时间做朋友</li>
<li>开拓自己的心智</li>
<li>小心所谓“成功学”</li>
<li>更多思考</li>
<li>从此时此刻开始改变</li>
</ol>
<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>有一些章节的具体内容现在的我有点忘了，记录一下对我来说比较重要的观点，希望能提醒自己：</p>
<h4 id="1、你永远不是最痛苦的"><a href="#1、你永远不是最痛苦的" class="headerlink" title="1、你永远不是最痛苦的"></a>1、你永远不是最痛苦的</h4><p>针对这个观点作者专门有举例，令人印象深刻。</p>
<h4 id="2、坚持与策略"><a href="#2、坚持与策略" class="headerlink" title="2、坚持与策略"></a>2、坚持与策略</h4><p>这个我觉得有点难度，挑战实在不小。无论你定了多详尽的计划，总会有意外发生，尽管作者已经告诉我把意外当成计划的一部分。尽量像作者一样把计划按照一个星期一个星期的周期来完成吧。</p>
<h4 id="3、控制自己的大脑"><a href="#3、控制自己的大脑" class="headerlink" title="3、控制自己的大脑"></a>3、控制自己的大脑</h4><p>控制自己的大脑，而不是被自己的大脑控制，这就是心智力量的强大之处。这是我读这本书的最大收获。比如起床，不想起床是因为自己被大脑控制了，因为睡觉舒服，大脑想的是舒服，这不是我想的，我想的是起床做事，但是为什么还是起不来？因为大脑控制了我。我有这样的经验：第二天要是有重要的事情必须要按时起床的，临睡前心里面提醒自己明天几点一定要起床做什么事情，第二天往往都能准时起床。因为我控制了自己的大脑，我告诉大脑必须做什么事情，这件事是对我有益的。控制自己的大脑，开启心智强大力量的第一步！</p>
<h4 id="4、记录尴尬"><a href="#4、记录尴尬" class="headerlink" title="4、记录尴尬"></a>4、记录尴尬</h4><p>把自己生活或工作中尴尬的事情记录下来，偶尔看一下，对自己后来的处事态度和方式，都会有警示的作用。</p>
<h4 id="5、提前准备"><a href="#5、提前准备" class="headerlink" title="5、提前准备"></a>5、提前准备</h4><p>这个我不知道说什么好，道理都懂，却依然过不好这一生？多多反思吧！为什么没有提前准备，临时抱佛脚乱阵脚？这个应该还要从计划做起，有计划才有准备！当然，行动是前提！</p>
<h4 id="6、按时打盹，按时清醒"><a href="#6、按时打盹，按时清醒" class="headerlink" title="6、按时打盹，按时清醒"></a>6、按时打盹，按时清醒</h4><p>我觉得我很需要睡眠，如果要做到按时打盹按时清醒，是很需要环境配合的，这个不好执行。</p>
<h4 id="7、马上开始永远都不迟"><a href="#7、马上开始永远都不迟" class="headerlink" title="7、马上开始永远都不迟"></a>7、马上开始永远都不迟</h4><p>是的，所以我马上把购物车清空了。嘻嘻，开玩笑。</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用记录</title>
    <url>/2017/04/16/ubuntu-omg/</url>
    <content><![CDATA[<p>记录一次Ubuntu初始化流程。</p>
<span id="more"></span>

<h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><ul>
<li>检查你的电脑有哪些显卡<br>lspci -k | grep -A 2 -i “VGA”  </li>
<li>查看Ubuntu正在使用哪块显卡<br>System Settings &gt; Details &gt; Overview  </li>
<li>查看哪一个专有驱动是推荐安装的<br>sudo ubuntu-drivers devices  </li>
<li>安装Nvidia专有显卡驱动<br>终端执行software-properties-gtk打开GUI或执行sudo apt-get install nvidia-375直接安装  </li>
<li>切换显卡<br>Dash中打开Nvidia X Server Settings或终端执行命令nvidia-settings，在PRIME Profiles切换  </li>
</ul>
<h3 id="系统基础配置"><a href="#系统基础配置" class="headerlink" title="系统基础配置"></a>系统基础配置</h3><ul>
<li>卸载多余的软件<br>sudo apt-get remove libreoffice-common<br>sudo apt-get remove unity-webapps-common<br>sudo apt-get remove totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install onboard deja-dup imagemagick  </li>
<li>桌面布局<br>gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true<br>gsettings set com.canonical.Unity.Launcher launcher-position Bottom  </li>
<li>更换源<br>sudo vim /etc/apt/sources.list<br>sudo apt-get update<br>sudo apt-get upgrade  </li>
<li>安装基础软件  <ul>
<li>通过源直接安装<br>sudo apt-get install vim<br>sudo apt-get install samba<br>sudo apt-get install chromium<br>sudo apt-get install screenfetch<br>sudo apt-get install git subversion vpnc<br>sudo apt-get install axel uget aria2<br>sudo apt-get install vlc<br>sudo apt-get install okular<br>sudo apt-get install kchmviewer<br>sudo apt-get install mediainfo mediainfo-gui<br>sudo add-apt-repository ppa:webupd8team/sublime-text-3<br>sudo apt-get update<br>sudo apt-get install sublime-text  </li>
<li>安装deb文件<br><a href="https://github.com/geeeeeeeeek/electronic-wechat">微信</a><br><a href="https://music.163.com/#/download">网易云音乐</a><br>sudo apt-get install libqgsttools-p1 libqt5multimedia5-plugins libqt5multimediawidgets5 libqt5libqgtk2<br>sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb<br><a href="https://pinyin.sogou.com/linux/?r=pinyin">搜狗输入法</a><br>sudo apt install libopencc1 fcitx fcitx-libs fcitx-libs-qt fonts-droid-fallback<br>sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb<br><a href="https://github.com/LiuLang/bcloud-packages">百度云盘</a><br>sudo apt-get install gnome-icon-theme-symbolic python3-crypto python3-pyinotify python3-keyring<br>sudo dpkg -i bcloud_3.8.2-1_all.deb<br><a href="https://github.com/getlantern/lantern">蓝灯</a><br>sudo dpkg -i lantern-installer-beta-64-bit.deb<br><a href="https://www.jianguoyun.com/s/downloads/linux">坚果云</a><br>sudo apt-get install python-gtk2 python-notify default-jre-headless<br>sudo dpkg -i nautilus_nutstore_amd64.deb<br><a href="https://community.wps.cn/download/">WPS</a><br>sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb  </li>
</ul>
</li>
<li><a href="https://wiki.ubuntu.org.cn/Gedit%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81">Gedit中文乱码</a><br>sudo apt-get install dconf-editor<br>运行dconf-editor<br>展开/org/gnome/gedit/preferences/encodings<br>Candidate Encodings的value配置为[‘GB18030’, ‘UTF-8’, ‘CURRENT’, ‘ISO-8859-15’, ‘UTF-16’]  </li>
</ul>
<h3 id="Jekyll环境"><a href="#Jekyll环境" class="headerlink" title="Jekyll环境"></a>Jekyll环境</h3><ul>
<li>sudo apt-get install ruby ruby-dev  </li>
<li>gem sources –remove <a href="https://rubygems.org/">https://rubygems.org/</a>  </li>
<li>gem sources -a <a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a>  </li>
<li>gem sources -l  </li>
<li>sudo gem install jekyll bundler  </li>
<li>bundle install  </li>
<li><a href="https://jekyllcn.com/">build&amp;run</a></li>
</ul>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><ul>
<li> <strong>在Linux Mint 18.3上执行sudo gem install jekyll报错：</strong></li>
</ul>
<blockquote>
<p>Building native extensions.  This could take a while…<br>ERROR:  Error installing jekyll:<br>   ERROR: Failed to build gem native extension.</p>
<p>  current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>/usr/bin/ruby2.3 -r ./siteconf20180226-49726-1ijhpau.rb extconf.rb<br>creating Makefile</p>
<p>current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>make “DESTDIR=” clean</p>
<p>current directory: /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser<br>make “DESTDIR=”<br>compiling ruby_http_parser.c<br>In file included from /usr/include/ruby-2.3.0/ruby/ruby.h:36:0,<br>                from /usr/include/ruby-2.3.0/ruby.h:33,<br>                from ruby_http_parser.c:1:<br>/usr/include/ruby-2.3.0/ruby/defines.h:26:19: fatal error: stdio.h: No such file or directory<br>compilation terminated.<br>Makefile:239: recipe for target ‘ruby_http_parser.o’ failed<br>make: *** [ruby_http_parser.o] Error 1</p>
<p>make failed, exit code 2</p>
<p>Gem files will remain installed in /var/lib/gems/2.3.0/gems/http_parser.rb-0.6.0 for inspection.<br>Results logged to /var/lib/gems/2.3.0/extensions/x86_64-linux/2.3.0/http_parser.rb-0.6.0/gem_make.out   </p>
</blockquote>
<p>解决方法：<br>sudo apt-get install build-essential patch ruby-dev zlib1g-dev liblzma-dev libsqlite3-dev</p>
<ul>
<li><strong>VMware Tools工具安装失败，无法复制粘贴（平台：Mint 18.3，VMware 11）</strong><blockquote>
<p>Makefile:120: recipe for target ‘vmhgfs.ko’ failed  </p>
</blockquote>
</li>
</ul>
<p>解决方法：</p>
<ol>
<li><p>Make sure the updates are done:<br>sudo apt-get update</p>
</li>
<li><p>Make sure git is installed<br>sudo apt-get install git</p>
</li>
<li><p>Run the command to get the tools from repository.<br>sudo git clone <a href="https://github.com/rasa/vmware-tools-patches.git">https://github.com/rasa/vmware-tools-patches.git</a></p>
</li>
<li><p>cd to vmware-tools-folder<br>cd vmware-tools-patches</p>
</li>
<li><p>Run the patch<br>sudo ./download-tools.sh</p>
</li>
<li><p>Run the following patch<br>sudo ./untar-and-patch.sh</p>
</li>
<li><p>Run the complie.sh file<br>sudo ./compile.sh<br><a href="https://communities.vmware.com/message/2665867?tstart=0">参考此贴</a></p>
</li>
</ol>
<ul>
<li><p><strong>Windows无法访问Samba服务器，访问被拒绝</strong><br>需要在Samba中创建用户。Ubuntu系统中的用户，和Samba用户是两回事，要将资源共享给系统中的某个用户，必须将该用户添加到Samba中。<a href="https://blog.sina.com.cn/s/blog_6c9d65a10100oobp.html">参考</a><br>用到的命令：smbpasswd。<a href="https://man.linuxde.net/smbpasswd">参考</a>  </p>
</li>
<li><p><strong>安装oh-my-zsh步骤</strong></p>
</li>
</ul>
<ol>
<li>sudo apt-get install zsh //安装</li>
<li>zsh –version //确认是否安装成功</li>
<li>sudo chsh -s $(which zsh) //设置zsh为默认shell</li>
<li>注销重新登录</li>
<li>echo $SHELL //确认zsh是否是默认SHELL</li>
<li>使用curl方式安装oh-my-zsh：sudo sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</a></li>
<li>配置：vim ~/.zshrc</li>
<li>若有中文乱码，再配置：export LANG=zh_CN.UTF-8</li>
<li>使配置生效：source ~/.zshrc</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Chromium的使用两则</title>
    <url>/2017/08/20/settle-chromium/</url>
    <content><![CDATA[<p>Chromium在WIN/Linux平台的一个配置。</p>
<span id="more"></span>

<h4 id="1、解决-Windows-中-Chromium-“缺少-GOOGLE-API-密钥”-和无法登陆账户的问题（转载）"><a href="#1、解决-Windows-中-Chromium-“缺少-GOOGLE-API-密钥”-和无法登陆账户的问题（转载）" class="headerlink" title="1、解决 Windows 中 Chromium “缺少 GOOGLE API 密钥” 和无法登陆账户的问题（转载）"></a>1、解决 Windows 中 Chromium “缺少 GOOGLE API 密钥” 和无法登陆账户的问题（转载）</h4><p>一打开 Chromium，地址栏下方就提示 “缺少 Google API 密钥，因此 Chromium 的部分功能将无法使用”。这直接导致了无法在 Chromium 登录 Google 账户并同步各种信息。  </p>
<p>打开 windows 的 CMD 命令提示符，依次输入以下命令： </p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">setx</span> GOOGLE_API_KEY <span class="string">"no"</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_ID <span class="string">"no"</span></span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_SECRET <span class="string">"no"</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实就是设置这样三个环境变量，值均为“no”。然而这样只是消除了哪行提示而已（对于没有 Google 账户的“良民”们，或许有用），Google 账户还是无法登录。  </p>
<p>在 Debian Jessie 为 Chromium 设置 PepperFlashPlayer 的时候，在 /etc/chromium.d 目录中看到一个 apikeys 文件。打开它，看到里面的内容如下： </p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># API keys assigned to Debian by Google for access to their services like sync and gmail.</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_API_KEY</span>=”AIzaSyCkfPOPZXDKNn8hhgu3JrA62wIgC93d44k”</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_DEFAULT_CLIENT_ID</span>=”811574891467.apps.googleusercontent.com”</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOOGLE_DEFAULT_CLIENT_SECRET</span>=”kdloedMFGdGla2P1zacGjAQh”</span><br></pre></td></tr></tbody></table></figure>

<p>这不就是设置环境变量吗？于是将上述文章中提到的环境变量按照这个 apikeys 文件中的值进行设置，即在 CMD 中执行： </p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">setx</span> GOOGLE_API_KEY AIzaSyCkfPOPZXDKNn<span class="number">8</span>hhgu<span class="number">3</span>JrA<span class="number">62</span>wIgC<span class="number">93</span>d<span class="number">44</span>k</span><br><span class="line"><span class="attribute">setx</span> GOOGLE_DEFAULT_CLIENT_ID <span class="number">811574891467</span>.apps.googleusercontent.com</span><br><span class="line"><span class="attribute">setx</span> GOOGLE_DEFAULT_CLIENT_SECRET kdloedMFGdGla<span class="number">2</span>P<span class="number">1</span>zacGjAQh</span><br></pre></td></tr></tbody></table></figure>

<p>再尝试打开 Chromium，发现提示消失了，Google 账户也能登录了。</p>
<h4 id="2、解决-Mint-中-Chromium-弹窗-“Enter-password-for-keyring-‘Default-keyring’-to-unlock”-的问题"><a href="#2、解决-Mint-中-Chromium-弹窗-“Enter-password-for-keyring-‘Default-keyring’-to-unlock”-的问题" class="headerlink" title="2、解决 Mint 中 Chromium 弹窗 “Enter password for keyring ‘Default keyring’ to unlock” 的问题"></a>2、解决 Mint 中 Chromium 弹窗 “Enter password for keyring ‘Default keyring’ to unlock” 的问题</h4><p>桌面版 Mint 使用 Chromium 会弹窗提示 “Enter password for keyring ‘Default keyring’ to unlock” ，输入 Mint 密码弹窗消失，怎么才能在每次使用 Chromium 的时候让这个弹窗消失？  </p>
<p>关闭 Chromium ，命令行下运行 seahorse ，找到 Passwords -&gt; Default keyring ，右键选 Change Password ，把新密码改为空，重启系统。  </p>
<p>版本：Version 59.0.3071.109 (Developer Build) Built on Ubuntu , running on LinuxMint 18.2 (32-bit)</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitstream or PCM？</title>
    <url>/2017/09/27/bitstream-or-pcm/</url>
    <content><![CDATA[<p>电视上同轴输出的做法。  </p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>USB通道下播放声音格式为AAC的视频文件，同轴输出设置为Auto，功放没有声音，设置成PCM，有声音。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>Auto/PCM的做法是怎样的？Auto的做法这里其实就是Bitstream，PCM就是PCM。<br>Bitstream与PCM差别在哪？如何取舍？为什么一个有声音，一个没有？</p>
<h3 id="讨论精选"><a href="#讨论精选" class="headerlink" title="讨论精选"></a>讨论精选</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>Basically,<br>Bitstream - will send the raw digital audio without processing out of the DVD player so your receiver can process<br>PCM - the player will convert everything to and output as 2 channel PCM<br>So if you want your receiver to process DD and DTS multichannel tracks then you must set the player to Bitstream<br>This PCM/Bitstream option doesn’t effect the players analogue outputs. This is the reason why your analogue outs sounded better than your digital out when its set to PCM.</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>If you select PCM the bluray player will do the decoding and send the sound to the amp. Bitstream will send it in raw format and leave the amp to decode it. PCM would be your safest bet so all audio formats work, but maybe select bitstream and see what happens…</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p><a href="https://www.lifewire.com/what-is-pcm-1846928">链接1</a> <a href="https://www.lifewire.com/blu-ray-audio-bitstream-vs-pcm-1846396">链接2</a><br>The PCM Option<br>If you set the Blu-ray Disc player to output audio as PCM, the player will perform the audio decoding of all Dolby/Dolby TrueHD and DTS/DTS-HD Master Audio - related soundtracks internally and send the decoded audio signal in uncompressed form to your home theater receiver. As a result, your home theater receiver will not have to perform any additional audio decoding before the audio is sent through the amplifier section and the speakers. With this option, the home theater receiver will display the term “PCM” on its front panel display.</p>
<p>The Bitstream Option<br>If you select Bitstream as the HDMI audio output setting for your Blu-ray player, the player will bypass its own internal Dolby and DTS audio decoders and send the undecoded signal to your HDMI-connected home theater receiver.</p>
<p>With this setting, the home theater receiver will do all the audio decoding of the incoming signal. As a result, in this case, the receiver will display Dolby, Dolby TrueHD, DTS, DTS-HD Master Audio, Dolby Atmos, DTS:X, etc…on its front panel display depending on which type of bitstream signal is being decoded.</p>
<p>NOTE: The Dolby Atmos and DTS:X surround sound formats are only available from a Blu-ray Disc player via the Bitstream setting option. There are no Blu-ray Disc players that can decode these formats internally and to PCM and pass that on to a home theater receiver.</p>
<h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><p>what is the difference between connecting a dvd player to amp, having the output mode of dvd player set to bitstream and pcm? how difference these setting will influence the output of sound?</p>
<p><strong>Answer 1:</strong><br>Bitstream is digital output to the amp, it means either optical or coaxial output should be connected to the receiver. The digital to analog conversion will be done by the receiver.</p>
<p>PCM is analog output. Analog output should be connected to the receiver. For DTS etc, your player should have a dts decoder and the 5 channel output should be connected to the receiver’s external decoder inputs.</p>
<p><strong>Answer 2:</strong><br>Doors, you information is only partially correct. PCM is not analog, but digital. Let me explain. </p>
<p>There are lots of confusion between PCM/LPCM and bitstream. This confusion is there because the two refer to completely different things - one is a encoding and storage methodology, while the other is just a transport mechanism. </p>
<p>Pulse Code Modulation or PCM is a digital form of representing analog signals. PCM has two step process - one is called Modulation and other is called Demodulation. In Modulation, an analog signal is sampled at regular intervals and quantisized. For each sample, an available value is chosen using an advanced algorithm. This creates a fully discreet digital signal that can be easily stored and processed. In demodulation, the modulation process is reversed and a high frequency analog signal is created. This is them sent though a filter to remove, what we in audio call, jitter. Modulation is what we know as Analog-to-Digital conversion, and demodulation is what we call Digital-to-Analog conversion. Both your audio CD as well as your DVD store digital data that have been created using PCM. </p>
<p>For a long time, because of the small spaces available for storage (CD, DVD, etc) as well narrow bandwidths available for data transmission, digital data has been stored in lossy compressed form for both audio and video. Such compression always have some loss of data. </p>
<p>Using optical or co-axial connections, these compressed digital data is streamed across from one point to another. Since a bit is the most basic form of digital data, this way of transmission is called bitstreaming. Digital data is streamed using synchronous or asynchronous modes. In computer for example, TCP uses asynchronous mode for data transportation. </p>
<p>Most data streams are sent as packets or frames of data and contain the following information:</p>
<ul>
<li>header</li>
<li>error check</li>
<li>audio or video data</li>
<li>ancillary data</li>
</ul>
<p>The header of each packet contains general information such as the CODEC, sampling frequency, number of channels, CRC protection, etc. On the receiving side, the data is validated for accuracy, and once validated, the actual data is processed as needed.</p>
<p>Over the last few years two things have happened. Storage space has increased, and new transmission methodology have been discovered that have a much higher bandwidth. HDMI 1.3, for example, can carry data at a bandwidth of 340 MHz which equals to 10.2 giga bits per second. In addition HDMI also allows multiplexing of multi data streams over a single physical link. A 192 kHz sampling frequency equates to just 6.144 gigabits per second of transmission speeds. </p>
<p>Now suddenly you could store data with lossless compression, and also transmit multiple channels of data from one place to another at very high speed. </p>
<p>LPCM is a term that is loosely used for both encoding and storage, and of decoding and transmission of lossless video/audio data. LPCM sampling resolutions can go up to 24 bits per sample, while PCM’s resolution is a max of 16 bits. LPCM is generally used in conjunction with WAV files in computers (also FLAC, AIFF etc), and with Blu-Ray, TrueHD, DTS-HD </p>
<p>PCM and bitstream is used in conjunction with traditional formats such as 2 channel stereo, Dolby Digital, DTS, etc. </p>
<p>The question is which one should I use? </p>
<p>If you are using coaxial or optical digital connection, you must use bitstream or what some players call RAW. Many DVD players will have PCM set as default. PCM will not send Dolby Digital or DTS as multi channel sound, but as Stereo PCM through these connections,</p>
<p>HD Audio such as TrueHD, DTS HD etc are stored in compressed form and cannot be transmitted as such. A high end DVD player will, thus, extract such sound from the disc, decode it, and mix it into muti channel PCM. This is then transmitted through HDMI 1.1 or higher connections. You have to ensure that your receiver not only has an HDMI input but should also have the ability to handle the multichannel PCM signal. </p>
<p>Cheers  </p>
<h4 id="五"><a href="#五" class="headerlink" title="五"></a>五</h4><p><a href="https://www.cnblogs.com/lihaiping/p/LPCM.html">拓展1</a> <a href="https://blog.chinaunix.net/uid-9688646-id-1998399.html">拓展2</a>  </p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>讨论部分，网友的回答已经非常明了。  </p>
<ul>
<li>同轴选择Bitstream输出，则TV不做decode，直接把raw data给到功放，功放直接处理raw，比如Dolby的话，按功放面板上info，切到Audio decoder就会看到Dolby；同轴输出选择PCM输出，则TV给到功放的是已经经过处理后得到的PCM，功放info显示的是PCM。我的功放型号是雅马哈RX377。</li>
<li>对于好一点的功放，选Bitstream，听说音效听起来很好，否则保险起见，选PCM，因为大多数的功放都能解PCM。</li>
<li>同轴输出设置为Auto时没声音，是因为功放不支持AAC吗？查看<a href="https://www.yamaha.com.cn/images/products/audio-visual/aduio-family/av-receiver/RX-V377/RX-V377.pdf">功放说明书</a>，没看懂支持不支持AAC。但是用功放直接播放USB里的AAC音乐文件，Audio Decoder显示为AAC，应该能说明AAC是支持的。</li>
<li>播放AAC音源没有声音的问题，原厂处理如下：[what]when audio = aac, spdif select AUTO, AV receiver doesn’t output，[why]AV receiver don’t support AAC raw data，[how]when audio = aac, spdif select AUTO, force SPDIF output PCM。我认为这个处理方法还有待商榷，因为AV receiver看起来是支持AAC的，所以当同轴输出设置为Bitstream时功放无声音的问题，软件层面应该还有更合理的改善的地方，而不是简单地“force SPDIF output PCM”。出于对比方案的做法参考和出货的紧迫时间，就这么处理了！</li>
<li>还有一个问题，功放插上U盘，播放U盘里面的音乐的时候，功放info可正确输出音乐的音频格式（试过了PCM、AAC、WMA），但是视频却不能（这里用TV多媒体通道播放视频，同轴输出到功放，把同轴输出设置为Auto时，info看到的东西除了PCM就是Dolby Digital，我用一个音频格式为wma的视频（这个视频是用格式工厂转码得到的，但是用MediaInfo对比这个视频的音频参数和之前测试的wma音乐的音频参数，文件格式/编码设置ID/编码设置ID/信息都一致）试了，info显示的是PCM），这是功放本身的做法问题吗？</li>
</ul>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>pcm</tag>
        <tag>coax</tag>
        <tag>dolby</tag>
      </tags>
  </entry>
  <entry>
    <title>RDA8501调AQ的几点记录</title>
    <url>/2017/08/24/rda8501-aq/</url>
    <content><![CDATA[<p>记录一次调音频经历，作为在客户端工作的总结。</p>
<span id="more"></span>

<h2 id="最大声音功率"><a href="#最大声音功率" class="headerlink" title="最大声音功率"></a>最大声音功率</h2><p>指音量为100时，喇叭能支持的最大功率，不同的板型使用的功放不同，喇叭不同，最大功率有差别。每个客户输入信号标准不同，一般使用1KHz/-12dB输入。</p>
<ul>
<li>Audio -&gt; Power Limiter<br>PLC: Enable/Disable，用于Audio输出最大值限制<br>Sp Attack: 喇叭输出最大值<br>Hp Attack: 耳机输出最大值（仅限IC  Headphone Output）<br>Lo Attack: Line Out输出最大值</li>
<li>比如调4W的喇叭：</li>
</ul>
<ol>
<li>把音量调至100；</li>
<li>关闭 Audio -&gt; Power Limit –&gt; PLC（PLC主要起限制后端放大的作用）；</li>
<li>调Function –&gt; Curve Setting -&gt; Volume Curve -&gt; Vol.Pt.100，使功率达到4W；</li>
<li>开启PLC，测量此刻的功率值  ，若功率小于4W，增大Audio -&gt; Power Limit –&gt; SP Attack值（趋向于0(0dB)），直到功率等于4W，若功率大于4W，减小SP Attack值（趋向于-240(-30dB)），直到功率等于4W；</li>
<li>增大Vol.Pt.100，测量此刻的功率，若功率稳定在4W，则Vol.Pt.100和SP Attack值可确定，记录Vol.Pt.100值和SP Attack值，若 功率大于4W，说明PLC限幅不够，继续减小SP Attack值，直到功率等于4W ；</li>
<li>重复步骤5进行微调，直到无论怎么增大Vol.Pt.100值，功率都能稳定在4W。若无法准确到4W，可选最接近4W的功率作为最大功率，假设得到Vol.Pt.100值为A；</li>
<li>增大输入。比如换1KHz/-10dB作为输入，如果此刻功率大于4W，假设功率为B（B&gt;4W），则继续减小SP Attack值（按最小单位微调）到C，量的此刻功率为D（此时D应该小于等于4W），则折中选择一个最接近4W的功率值（B或D），如果选择B值，则步骤6得到的Vol.Pt.100 和SP Attack为最优解，如果选择 D 值，有可能Vol.Pt.100 = A时候量到的功率与A减小几个单位后量到的功率一样，这个时候还需减小 A 值（原因是 PLC 限制得太多了）；</li>
<li>记录Vol.Pt.100值【subcustomer_setting.h】和SP Attack【board_config.h】。<br><img src="https://i.loli.net/2018/02/27/5a9513cb88b4b.png"></li>
</ol>
<h2 id="音量曲线"><a href="#音量曲线" class="headerlink" title="音量曲线"></a>音量曲线</h2><p>  指电视机各个音量点的功率，因客户要求而异。要求制作音量曲线不可有明显突变，各个通道的曲线尽量接近。每个客户输入信号标准不同，一般使用1KHz/-12dB输入。步骤如下：</p>
<ol>
<li>调最大功率</li>
<li>依次调Function –&gt; Curve Setting -&gt; Volume Curve -&gt; Vol.Pt各个点，使每个音量点测量得到的功率基本满足客户要求，调试时注意Vol.Pt 值跟Function –&gt; Curve Setting -&gt; Volume Curve -&gt; OSD Volume Value值匹配；</li>
<li>记录每个Vol.Pt 值【subcustomer_setting.h】。</li>
</ol>
<h2 id="频响曲线"><a href="#频响曲线" class="headerlink" title="频响曲线"></a>频响曲线</h2><p>指音响系统对输入信号的反应和辨别能力。比如一台好的音响，他的频率响应范围是20赫兹到20000赫兹。那么当一个包含有20-20000赫兹的音频信号的音乐进来之后，它就会有足够深的低频下潜和非常出色的高频表现；假如你把这个信号输入给一台比较烂的音响（我们假设它只有100-12000的频率响应范围），那么比这个范围低或者高的信号音响就无法处理和播放，你就会感觉这个音乐很窄，缺乏表现力。当然频率响应还有一些别的必须要参考的标准，比如在某个频段，响应的情况如何，这里略过。（百度）。<br>参考Mstar V56方案频响曲线图：<br><img src="https://i.loli.net/2018/02/27/5a9515719cdc8.png"><br>与V56相比，8501方案的频响曲线低频段部分（20Hz~150Hz）没有作抑制，如不能满足客户要求，可自行调整频响曲线。</p>
<p>频响曲线涉及的调试内容是Audio -&gt; EQ和Audio -&gt; PEQ，调频响曲线一般先调EQ，再通过PEQ进行微调。</p>
<ul>
<li>EQ 主要作用于特定频率范围的信号强度，当需要调节频率范围内的曲线趋势时，可以调EQ，EQ在工厂菜单里可供调试的项目有EQ Band、Gain、Frequency、Q Factor。<ul>
<li>EQ Band: 目前有7段</li>
<li>Gain: 设置EQ Band的增益，范围 -50<del>50（-12dB</del>12dB）</li>
<li>Frequency: 调节EQ band 的中心频率，范围 20Hz~20KHz</li>
<li>Q Factor: 调节EQ band 的影响频宽 0.1(宽)~5.0(窄)</li>
</ul>
</li>
<li>PEQ用于EQ Band不满足要求时，对特定频率进行补偿使用。<ul>
<li>Center Frequency: 设置中心频率</li>
<li>Q Factor: 调节EQ band 的影响频宽 0.1(宽)~5.0(窄)</li>
<li>Gain Step: 设置EQ Band的增益，范围 -50<del>50（-12dB</del>12dB）<br>【app_data_setting.c、subcustomer_setting.c】</li>
</ul>
</li>
</ul>
<h2 id="AVL（即AVC、输入灵敏度）"><a href="#AVL（即AVC、输入灵敏度）" class="headerlink" title="AVL（即AVC、输入灵敏度）"></a>AVL（即AVC、输入灵敏度）</h2><p>客户一般有要求输入幅度范围下把声音功率限定在特定功率内的指标，AVL用于控制输入信号的强弱（限制芯片输入）。</p>
<ul>
<li>AVL Mode：Enable（开启AVL功能），Disable（关闭AVL功能）；AVL功能默认关闭，做输入灵敏度测试的时候先打开AVL功能；Audio -&gt; AVL -&gt; AVL Mode与OSD -&gt; SOUND上的 Auto Volume 功能一致</li>
<li>Attack Rate：控制压抑以及还原速度（时间）的比例</li>
<li>Active Time：超过Limite Level时，每隔Active Time调整一次增益，每次减小0.1dB，直到降到Limite Level</li>
<li>Limiter：当输入信号超过Limite Level时开始压抑</li>
<li>Pullup Gain：当信号小于-12dB时候，会依照Pullup Gain的定义将信号放大（但是放大信号容易失真，建议设置0dB）<br>【app_data_setting.c】</li>
</ul>
<p>下图为V56方案AVL曲线图，蓝线为Disable AVL时候的曲线，黄线为Enable AVL时候的曲线：<br><img src="https://i.loli.net/2018/02/27/5a95159ee5bbe.png"><br>与V56相比，HK8501方案AVL曲线没有过零点，输入为0时，仍有3mV~4mV的输出，目前无解。如下图：<br><img src="https://i.loli.net/2018/02/27/5a9515bfe2d90.png"></p>
<h2 id="高低音"><a href="#高低音" class="headerlink" title="高低音"></a>高低音</h2><p>即OSD -&gt; SOUND上的Treble/Bass，不同客户对声音模式的要求可能不同，一般是增益范围的差别。下图较高的红线（AB线）对应Treble=100，Bass=100，较低的红线（CD线）对应Treble=0，Bass=0，增益范围在±6dB~±8dB，每一根线都是Treble和Bass作用叠加的效果图：<br><img src="https://i.loli.net/2018/02/27/5a9515e332cbe.png">  </p>
<p>调试点主要有A、B、C、D四个，标准是增益范围，即A到C的增益差，B到D的增益差，有以下几种情况：</p>
<ol>
<li>如需使A点向下移，即需减小Bass=100时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益）,<br><img src="https://i.loli.net/2018/02/27/5a95166f73d1e.png"><br>如需使A点向上移，同理；</li>
<li>如需使C点向上移，即需增大Bass=0时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f67a2d.png"><br>如需使C点向下移，同理；</li>
<li>如需使B点向下移，即需减小Treble=100时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f671a4.png"><br>如需使B点向上移，同理；</li>
<li>如需使D点向上移，即需增大Treble=0时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f6ce43.png"><br>如需使D点向下移，同理.</li>
</ol>
<p>高低音的修改内容主要是Treble/Bass曲线表【subcustomer_setting.c】。</p>
<h2 id="声音模式"><a href="#声音模式" class="headerlink" title="声音模式"></a>声音模式</h2><p>即OSD -&gt; SOUND上的四种音效模式，不同的声音模式是突出不同的声音特点，有的突出低音，有的突出高音，有的是突出人声部分。参考下图：<br><img src="https://i.loli.net/2018/02/27/5a9516de46c4f.png"><br>不同的音效模式Treble值和Bass值不同，所以增益不同，可以修改OSD -&gt; SOUNG上Treble/Bass的默认值【app_data_setting.c】，在客户对OSD -&gt; SOUNG上Treble/Bass的默认值有要求的情况下，只能调整Treble/Bass曲线【subcustomer_setting.c】。</p>
<h2 id="分离度"><a href="#分离度" class="headerlink" title="分离度"></a>分离度</h2><p>通道间串音分离度测量的是其他通道保持输入信号的情况下对本通道的影响。<br><img src="https://i.loli.net/2018/02/27/5a9516de2dfc1.png"></p>
<h2 id="失真度"><a href="#失真度" class="headerlink" title="失真度"></a>失真度</h2><p><img src="https://i.loli.net/2018/02/27/5a9516de38c7e.png"></p>
<h2 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h2><p>信噪比是作为调制频率的 1KHz 音频信号的输出功率或电压与背景噪声的功率或电压之比，用分贝（ dB）表示。<br><img src="https://i.loli.net/2018/02/27/5a9516de40ee6.png"></p>
<h2 id="增益差"><a href="#增益差" class="headerlink" title="增益差"></a>增益差</h2><p>指测量扬声器左右通道信号幅度不等性。<br><img src="https://i.loli.net/2018/02/27/5a9516de414d7.png"></p>
<h2 id="耳机频响-耳机失真-耳机信噪比-耳机增益差"><a href="#耳机频响-耳机失真-耳机信噪比-耳机增益差" class="headerlink" title="耳机频响/耳机失真/耳机信噪比/耳机增益差"></a>耳机频响/耳机失真/耳机信噪比/耳机增益差</h2><p>HK8501方案耳机跟喇叭共用一路，所以耳机项目的这几个测试结果跟喇叭一样。</p>
<h2 id="AV-Out频响-失真-信噪比-增益差"><a href="#AV-Out频响-失真-信噪比-增益差" class="headerlink" title="AV Out频响/失真/信噪比/增益差"></a>AV Out频响/失真/信噪比/增益差</h2><p>HK8501方案AV Out跟喇叭/耳机硬件上不是同一路。。。</p>
<h2 id="AV-Out音频输出幅度"><a href="#AV-Out音频输出幅度" class="headerlink" title="AV Out音频输出幅度"></a>AV Out音频输出幅度</h2><p>带AV Out端子的板卡需要测试这一项目。【board_config.c】</p>
<h2 id="唇音同步"><a href="#唇音同步" class="headerlink" title="唇音同步"></a>唇音同步</h2><p>即声音图像同步（AV Sync）<br>Audio –&gt; Misc. -&gt; Lipsync：调整 AV Sync，范围为 -200ms~200ms<br>【app_data_setting.c】</p>
<h2 id="谐波失真"><a href="#谐波失真" class="headerlink" title="谐波失真"></a>谐波失真</h2><p>谐波失真是音频通道的非线性引起的正弦波信号的谐波分量。<br>。。。</p>
<h2 id="总谐波失真"><a href="#总谐波失真" class="headerlink" title="总谐波失真"></a>总谐波失真</h2><p>总谐波失真是输出信号谐波失真的有效值与总输出信号的有效值之比，用百分数表示。<br>。。。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>测量声音相关参数时需220V交流供电；</li>
<li>测试过程中，无特殊要求一般把声音参数设置为标准，环绕声关闭，相关音效处理功能关闭（特殊测试项目除外），这个在测试前需跟测试人员进行有效沟通；</li>
<li>AQ调试优先级说明：<ul>
<li>先调频响；</li>
<li>高低音&gt; 声音模式；</li>
<li>最大声音功率 &gt; 声音曲线 &gt; 失真度；</li>
<li>AVL、信噪比、分离度、增益差这几个一般在频响之后。</li>
</ul>
</li>
</ul>
<p>以上所有的曲线图仅参考，实际效果会因客户标准，板卡，功放，喇叭规格不同而存在差异。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>audio</tag>
        <tag>aq</tag>
      </tags>
  </entry>
  <entry>
    <title>搭个梯子</title>
    <url>/2018/01/03/fanqiang/</url>
    <content><![CDATA[<p>没有谷歌是在很不方便，搜索，玩游戏，备份相片、通讯录什么的都很麻烦。</p>
<span id="more"></span>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul>
<li><p>购买VPS<br>  百度了一圈，觉得比较划算的还是Bandwagon或者Vultr（Vultr可付支付宝，搬瓦工没了解）。我用的是Vultr，直接充钱，最低充10美元。最低套餐是2.5美元/月，这个比较缺货。好像日本新加坡的主机比较热门，不过也听说容易被墙。当时买2.5的时候只有美国NYC和迈阿密有售。我选了个迈阿密的，至于体验如何？对于YouTube没有太大的需求，用一加3T联通卡，ShadowsocksAPK测试，Ping值一般250~400ms。如果你也选择Vultr，可以点击我的<a href="https://www.vultr.com/?ref=7243025">邀请链接</a>，这样大家都可以得到10刀的优惠。</p>
</li>
<li><p>部署云主机<br>  选VC2，选服务器，选系统。我选的是 Ubuntu 16.04 i386，其他默认，创建服务器。这样就可以得到服务器IP，用户名和密码。</p>
</li>
</ul>
<h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul>
<li><p>安装Shadowsocks服务端<br>  先SSH登陆服务器，然后安装Shadowsocks。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install python</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install python-setuptools</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>配置Shadowsocks<br>  vim /etc/shadowsocks/config.json</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"你的服务器IP地址"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:端口号,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"你的Shadowsocks密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>启动Shadowsocks</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">sudo ssserver -c <span class="regexp">/etc/</span>shadowsocks.json -d start</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>把Shadowsocks加入开机启动项<br>  编辑/etc/rc.local文件</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>rc.local</span><br></pre></td></tr></tbody></table></figure>
<p>  在 exit 0 这一行的上边加入如下内容</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>ssserver –c <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="上网冲浪"><a href="#上网冲浪" class="headerlink" title="上网冲浪"></a>上网冲浪</h2><p>Shadowsocks软件下载安装与登录即可，至此翻墙工作基本完成。<br>下载地址：<br><a href="https://github.com/shadowsocks/shadowsocks-android">Android</a><br><a href="https://github.com/shadowsocks/shadowsocks-windows">windows</a></p>
<h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><p>曾试过用得好好的突然就挂了，服务器能连上也能Ping通，换了个端口号重启就行了。端口冲突吗？</p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>google</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>纯手动吹风机</title>
    <url>/2018/01/22/lmao/</url>
    <content><![CDATA[<p>精彩段子收集。</p>
<span id="more"></span>

<h4 id="银教授"><a href="#银教授" class="headerlink" title="银教授"></a><a href="https://weibo.com/qiaoyinrong">银教授</a></h4><ul>
<li>想起当年求婚的画面，现在还历历在目，当时是女友生日，她吃着蛋糕，突然吃到一粒钻戒，随机害羞地对我说：“我愿意嫁给你。”后来我们就结婚了，毕竟，我无法拒绝一个自己掏钱买戒指藏在蛋糕里的女孩</li>
<li>我在佛前苦苦求了几千年，只想问佛一个问题：我在佛前苦苦求了几千年？</li>
<li>我在佛前苦苦求了几千年，后面一个排队的拍拍我的肩膀：“哥你求完没？”</li>
<li>“你必须要很努力，才能看起来毫不费力。” “那我为什么不直接毫不费力呢？”</li>
<li>这些年我一直在退步，幸运的是，我背对着目标。</li>
<li>老师：你为什么迟到？我：正义都会迟到，我就不能了？</li>
<li>面试官：“说说你为什么擅长这项工作？”我：“说实话，我不擅长。” “那你擅长什么？” “擅长说实话。”  </li>
<li>有一天我求佛了，偶然发现这个佛是假的，是仿佛。  </li>
<li>刚看完消息就被对方撤回，有一种不小心看到对方走光的感觉，只好假装没看到。  </li>
<li>有时想无故请人吃饭，给对方一种困惑的感觉。  </li>
<li>单身汉给宠物花钱，就像恋爱的人给对象花钱，爱意总归要有个去向。  </li>
</ul>
<h4 id="那个洞是他的家"><a href="#那个洞是他的家" class="headerlink" title="那个洞是他的家"></a><a href="https://weibo.com/u/5187109870">那个洞是他的家</a></h4><ul>
<li>动物学校开课，大象迟到了。老师生气地说：“你为什么现在才来？干脆别来算了。”大象说：“真象可能会迟到，但永远不会缺席。”</li>
</ul>
<h4 id="小驴吃火烧"><a href="#小驴吃火烧" class="headerlink" title="小驴吃火烧"></a><a href="https://weibo.com/u/1046610712">小驴吃火烧</a></h4><ul>
<li>我欺负同桌后觉得很开心，换位思考了一下，我坐到他后面，欺负他一样很开心。</li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>lmao</tag>
      </tags>
  </entry>
  <entry>
    <title>EDID</title>
    <url>/2017/09/04/edid/</url>
    <content><![CDATA[<p>(这特么写的啥？<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>20200910)<br>还有一些一直没搞懂，先记一部分下来。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>PC：在任意分辨率下，连接电脑主机GeForce GTX750，显示Unsupported。多次实验。主机重启后画面能正常出来，但仍然无法读取EDID。测试了4台主机（其他3台显卡型号不确定），只有一台正常。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>搜集到以下资讯：</p>
<blockquote>
<ul>
<li>显示设备生产由于切割成本等原因都是1366X768，而视频讯号都是1360X768</li>
<li>知乎问题：《为什么说 1366 * 768 是「反人类」的分辨率？》<br>回答1：这个分辨率，横向不能被4整除。在一些情况下不适合使用。影响是，这个分辨率单行扫描不能32位字节对齐。而我们知道主流机器的int是32位（64位机的int也同样是32位）。这会导致经常需要为它额外留空。所以你会看到在某些场合只能用 1360 * 768 代替这个1366分辨率。<br>回答2：16:9屏幕是成本竞争的产物：细心的朋友会发现16:9的屏幕面积要比16：10的屏幕小0.1英寸。这0.1英寸看起来不多，其实它的面积并不小，大规模的切割母版时能多切几块。如果相同尺寸的母版按照14.1英寸能切出30块，那么14.0英寸的屏幕或许就能切出40块。如果总成本是6万元，那么16:10的屏幕是2000元一块，而16：9的屏幕就是1500元一块。<br>回答3：因为分辨率太小，强行16:9，为了面板切割的更多，导致高度只有768，网页竖着显示不了多少内容。而16:9作为看电影的最佳比例，1366 * 768 又远达不到1080P。最终为了赚钱，市面上全都是 1366 * 768，导致大量的反感。<br>回答4：1366 * 768 是对成本妥协的产物，在切割液晶板时最经济。<br>回答5：切割效率最高。每一代液晶面板都有自己最大效率的分辨率，比例，以及尺寸大小，以尽量减少浪费为前提的切割。</li>
<li>早期很多显卡里面都没有设置 1366 * 768，所以早期的显卡都没法识别 1366 * 768，只有 1360 * 768。</li>
<li>1366x768 appears most commonly on monitors and laptop displays. I’ve seen 1360x768 creep its way onto cheap ass TVs though. My older TV’s native resolution, for example, is 1360x768.  Nevertheless, I’d go for 1360x768 if you wanted 16:9 content, as 1366x768 cannot display anything at a native 16:9 without rounding, while 1360x768 can (at 1360x765; if you check YouTube and it displaying a video when your fullscreen resolution is 1360x768, you’ll see).</li>
<li>At the time the first computer wide-screens became popular, the usual resolution on 4:3 panels was 1024×768 (the XGA display standard). For simplicity and backward compatibility, the XGA resolution was kept as a basis when making the WXGA resolution (so that XGA graphics could be easily displayed on WXGA screens).<br>Just extending the width and keeping the same height was also simpler technically because you would only have to tweak the horizontal refresh rate timing to achieve it. However, the standard aspect ratio for wide displays was 16:9, which is not possible with 768 pixels, so the nearest value was chosen, 1366×768.<br>WXGA can also refer to a 1360×768 resolution (and some others that are less common), which was made to reduce costs in integrated circuits. 1366×768 8-bit pixels would take just above 1-MiB to be stored (1024.5KiB), so that would not fit into an 8-Mbit memory chip and you would have to have a 16-Mbit memory chip just to store a few pixels. That is why something a bit lower that 1366 was chosen. Why 1360? Because you can divide it by 8 (or even 16) which is far simpler to handle when processing graphics (and could bring to optimized algorithms).</li>
<li>1366×768 8-bit pixels is just above 1MiB (by 512 bytes), so it does not fit into an 8Mbit memory chip.<br>1360 is also divisible with both 8 and 16, enabling simplified and optimized algorithms for processing graphics.</li>
</ul>
</blockquote>
<p>总结下来就是：</p>
<ul>
<li>1366 * 768 是硬件分辨率，1360 * 768 是VESA规定的显示标准,如要输出1366，需要驱动或特别的软件支持</li>
<li>笔记本用 1366 * 768，切割效率高，节省面板成本</li>
<li>1366 * 768 更接近16:9，而 1360 * 768 则为16:10</li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li>EDID最佳分辨率是做 1366 * 768 还是 1360 * 768 ？ – 应该还是 1366 * 768 ？毕竟跟屏匹配才是最佳？</li>
<li>出货的屏是 1366 * 768，如果EDID最佳分辨率做 1360 * 768，能做点对点吗？ – 即使第一详细时序是 1360 * 768，如果TV软件有 1366 * 768 的支持，就可以点对点，比如在第二详细时序添加 1366 * 768？</li>
<li>为什么最佳分辨率写了 1360 * 768，屏显还是 1366 * 768？ – 在Win7控制面板里看到的分辨率是 1360 * 768，通过edidw2k工具抓取的EDID也是最佳分辨率 1360 * 768，偏偏屏显上是 1366 * 768。拿竞争对手C的板子做个对比，发现他们的EDID写的是 1366 * 768，但是屏显又是 1360 * 768？未解之谜。</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>后来也是用同样的软件测试，画面能正常出来，EDID也能读到，使用相同的主机，相同的线材，相同的软件，相同的板卡。测试前有做工厂复位。<br>为什么测试那边会出现那样的情况，本来看到“主机重启后画面能正常出来，但仍然无法读取EDID。”，觉得很有可能是电脑的问题了（因为我的笔记本也很难读，台式机比较容易），但是升完级没画面，需要重启才有，这个情况让人困惑。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>edid</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下搭建FTP服务器</title>
    <url>/2018/01/31/ftp-server/</url>
    <content><![CDATA[<p>前前后后配了好几次FTP Server，每次都要重新开始的样子各种百度谷歌。先记一次留着下次用。</p>
<span id="more"></span>

<p>环境：Ubuntu 16.04 i386</p>
<h3 id="安装软件和添加用户"><a href="#安装软件和添加用户" class="headerlink" title="安装软件和添加用户"></a>安装软件和添加用户</h3><ol>
<li>sudo apt-get install vsftpd //安装vsftpd</li>
<li>vsftpd -version //查看vsftpd版本</li>
<li>sudo mkdir /home/ftp_root -p //创建FTP服务器工作目录ftp_root //注意目录权限</li>
<li>sudo useradd -d /home/ftp_root -s /bin/bash xxx //新建FTP用户xxx</li>
<li>sudo passwd xxx //为新建的FTP用户xxx设置密码 //可用cat /etc/passwd可以查看当前系统用户</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>vim /etc/vsftpd.conf  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">listen=YES</span><br><span class="line"></span><br><span class="line">listen_ipv6=NO</span><br><span class="line"></span><br><span class="line">anonymous_enable=YES</span><br><span class="line">anon_root=/home/ftp_root/ftp_anonymous</span><br><span class="line"></span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line">local_root=/home/ftp_root</span><br><span class="line"></span><br><span class="line">local_umask=022</span><br><span class="line"></span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"></span><br><span class="line">use_localtime=YES</span><br><span class="line"></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"></span><br><span class="line">xferlog_file=/var/<span class="built_in">log</span>/vsftpd.log</span><br><span class="line"></span><br><span class="line">ftpd_banner=Welcome to blah FTP service.</span><br><span class="line"></span><br><span class="line">chroot_local_user=YES</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"></span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line"></span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line"></span><br><span class="line"><span class="comment">#pam_service_name=vsftpd</span></span><br><span class="line">pam_service_name=ftp</span><br><span class="line"></span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>vim /etc/vsftpd.user_list</p>
</li>
<li><p>vim /etc/vsftpd.chroot_list</p>
</li>
<li><p>其他</p>
</li>
</ol>
<ul>
<li>防火墙：直接关闭或者开放端口</li>
<li>SeLinux：关闭</li>
<li>添加开机自启动</li>
</ul>
<h3 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h3><p>sudo service vsftpd start</p>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>方式有很多种，比如ssh、浏览器、Windows资源管理器添加FTP站点、FTP客户端工具等都可以。<br>我在Windows下用客户端工具FileZilla，好处是文件共享方便的同时是能直观看到log信息。</p>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol>
<li>启动vsftpd服务后查看状态，发现启动失败</li>
</ol>
<blockquote>
<p>Active: failed (Result: exit-code)<br>(code=exited, status=2)  </p>
</blockquote>
<p>原因：不明<br>解决方法：将 vsftpd.conf 里面的 listen 从 NO 改成 YES  </p>
<ol start="2">
<li>331和530错误，且匿名用户能登陆，但是用户账户不能登陆</li>
</ol>
<blockquote>
<p>331 Please specify the password.<br>530 Logiin incorrect.  </p>
</blockquote>
<p>原因：“By default vsFTPd uses the file /etc/pam.d/vsftpd. This file by default requires FTP users to have a shell listed in /etc/shells and requires them not to be listed in /etc/ftpusers. If you check those 2 things your probably find what the problem is.”<br>解决方法：将 vsftpd.conf 里面的 pam_service_name 从 vsftpd 改成 ftp  </p>
<ol start="3">
<li>500错误</li>
</ol>
<blockquote>
<p>500 OOPS: cannot change directory  </p>
</blockquote>
<p>原因：未明，权限问题？普通用户不能进入到 /root 目录？<br>解决方法：修改 /etc/passwd ，把FTP工作目录从 /root/ftp_root 改为 /home/ftp_root  </p>
<ol start="4">
<li>root用户能上传文件，但是xxx用户不行</li>
</ol>
<blockquote>
<p>227 Entering Passive Mode<br>553 Could not create file  </p>
</blockquote>
<p>原因：未明<br>解决方法：无解</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li><a href="https://blog.csdn.net/danson_yang/article/details/65629948">Linux useradd 与 adduser的区别， /sbin/nologin 与 /bin/bash</a></li>
<li>主动模式与被动模式</li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/ShaYeBlog/p/5897303.html">参考链接1</a></li>
<li><a href="https://www.360doc.com/content/14/1225/15/15077656_435676206.shtml">参考链接2</a></li>
<li><a href="https://blog.csdn.net/huanggang028/article/details/41248663">参考链接3</a></li>
<li><a href="https://blog.csdn.net/u010154760/article/details/45458219">参考链接4</a></li>
<li><a href="https://www.cnblogs.com/xiaohh/p/4789813.html">参考链接5</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>音频参数简单介绍</title>
    <url>/2018/02/28/rda8501-aq-v2/</url>
    <content><![CDATA[<p>重写8501AQ相关，作为《RDA8501调AQ的几点记录》的补充或修正。</p>
<span id="more"></span>

<h3 id="频响曲线"><a href="#频响曲线" class="headerlink" title="频响曲线"></a>频响曲线</h3><ul>
<li>对频响的理解</li>
</ul>
<blockquote>
<p>频响曲线是在测试电路中，使信号发生器的输出信号频率发生连续变化（即通常说的‘扫频’）并保持幅度不变，在输出端通过示波器或者其他一些记录仪将放大器对于这个连续变化相应的输出电平记录下来，就可以在一个坐标上描绘出一个电平对应频率的曲线。这个坐标的纵坐标是电平，横坐标是频率。纵坐标的单位是dB，横坐标的单位是Hz(或KHz)。为了记录方便，横坐标的标尺为对数型的，纵坐标则是线性的。看频响曲线的时候，不要被曲线的‘平滑’或者‘崎岖’所迷惑，首先要看看坐标的标尺，改变标尺的单位会使曲线看起来差别很大。如果把标尺加大10倍，你大概看到的差不多是一条完美的直线了。</p>
</blockquote>
<blockquote>
<p>频响为什么会影响音质？一方面，人耳有心理声学的掩蔽效应，这个效应简而言之就是不同频率及不同的响度会相互影响，一部分声音的叠加，会导致另一部分声音无法听见。表现到重放系统，如果频响不够平，或者不同频率变化幅度过大，就会导致有部分本来应该听到的内容听不到。这就是细节的丢失。还有一方面，不同频率的频响不同，会导致声音呈现出非原义的表现形式。比如，一段音乐，本来是笛子和古筝交相辉映珠联璧合的，如果笛子那个频段频响过高而古筝那个频段频响较低，就会导致不和谐的情况发生。很恼人的感觉就会出现，本来好听的就不再好听了。</p>
</blockquote>
<blockquote>
<p>在实际的调音中,  频响曲线要根据喇叭的特性进入调整以弥补喇叭自身的不足,  在哪些频点要提升或降低几个dB,  这就要考验音频工程师的功力。</p>
</blockquote>
<ul>
<li><p>工厂菜单调试点</p>
<ul>
<li>EQ Setting<br>  作用：通过BandPass Filter来改变特定频率范围信号强度（目前分为7段）  <ul>
<li>EQ Band：需要改变的EQ band  </li>
<li>Gain：设置EQ band增益，范围-50~50（-12db ~ 12db）  </li>
<li>Q Factor：调整EQ Band的影响频宽（0.1(宽)~5.0(窄)），预设1.5  </li>
<li>Frequency：调整EQ Band的中心频率（20HZ~20KHZ）</li>
</ul>
</li>
<li>PEQ Setting<br>  作用：用于EQ band不满足要求时候，对特定频率进行补偿使用  <ul>
<li>PEQ1：用于设置第一个频率补偿点参数  </li>
<li>Center Freq：设置中心频率  </li>
<li>Q Factory：同上EQ Band Setting中Q Factor  </li>
<li>Gain Step：同上EQ Band Setting中gain  </li>
<li>PEQ2：用于设置第二频率补偿点参数  </li>
<li>PEQ3：用于设置第三频率补偿点参数</li>
</ul>
</li>
</ul>
</li>
<li><p>举例：如图是8503P531板卡搭载RDA3118功放，软件使用默认设定，AP 500mV输入，喇叭功率为1W情况下得到的频响曲线<br>  <img src="https://i.loli.net/2018/02/28/5a9642c0ab9f2.jpg"></p>
</li>
<li><p>调好参数后把数值填充到结构体<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）和<strong>g_stAudioSoundModeEqualizerSetting</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/subcustomer_setting.c</em>）</p>
</li>
</ul>
<h3 id="最大声音功率"><a href="#最大声音功率" class="headerlink" title="最大声音功率"></a>最大声音功率</h3><p>指TV音量为最大(100)时，喇叭最大功率。不同客户输入信号标准或许不同，一般使用1KHz/-12dB（500mV）输入。<br>比如调一个4W最大声音功率，步骤如下：</p>
<ol>
<li>令工厂菜单Audio-&gt;AVL-&gt;AVL Mode = Disable，Audio-&gt;Power Limiter-&gt; Sp Attack = 0（PLC用于限制后端输出）；</li>
<li>令工厂菜单Function-&gt;Curve Setting-&gt;Volume Curve-&gt;OSD Volume Value（即TV系统音量）= 100，调Function-&gt;Curve Setting-&gt;Volume Curve-&gt;Vol.Pt.100，使功率达到4W，记录数值用于填回音量曲线表；</li>
<li>调大输入源幅度或继续增大Vol.Pt.100，使输出大于4W；</li>
<li>降低PLC Sp Attack，使输出小于等于4W，记录数值设为默认值；</li>
<li>完成。需要记录的参数是Sp Attack（<strong>PLC_SP_ATTACK</strong>：<em>aps/customer/s2tek/hk8501/adaptable/board_config.h</em>）和Vol.Pt.100（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/subcustomer_setting.h</em>）。</li>
</ol>
<h3 id="音量曲线"><a href="#音量曲线" class="headerlink" title="音量曲线"></a>音量曲线</h3><p>要求制作的音量曲线不可有明显突变，各个通道的曲线尽量接近。<br>步骤：</p>
<ol>
<li>调最大声音功率</li>
<li>依次调Function-&gt;Curve Setting-&gt;Volume Curve-&gt;Vol.Pt各个点，使每个音量点测量得到的功率基本满足客户要求，调试时注意Vol.Pt 值跟OSD Volume Value值匹配；</li>
<li>记录数值写回音量曲线表（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/subcustomer_setting.h</em>）</li>
</ol>
<h3 id="AVL（AVC-输入灵敏度）"><a href="#AVL（AVC-输入灵敏度）" class="headerlink" title="AVL（AVC/输入灵敏度）"></a>AVL（AVC/输入灵敏度）</h3><p>AVL用于控制输入信号的强弱（限制前端IC输入）。</p>
<ol>
<li>工厂菜单内容：  <ul>
<li>AVL Mode：Enable（开启AVL功能），Disable（关闭AVL功能）；AVL功能默认关闭，做输入灵敏度测试的时候先打开AVL功能；Audio -&gt; AVL -&gt; AVL Mode与OSD -&gt; SOUND上的 Auto Volume 功能一致  </li>
<li>Attack Rate：控制压抑以及还原速度（时间）的比例，即开关AVL功能时，功率变化的快慢  </li>
<li>Active Time：超过Limite Level时，每隔Active Time调整一次增益，每次减小0.1dB，直到降到Limite Level  </li>
<li>Limiter：当输入信号超过Limite Level时开始压抑  </li>
<li>Pullup Gain：当信号小于<strong>AGC_PULL_UP_ACTIVE_LEVEL</strong>的时候，会依照Pullup Gain的定义将信号放大（但是放大信号容易失真，建议设置0dB） </li>
</ul>
</li>
<li>调好后记录数据<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）</li>
</ol>
<h3 id="高低音"><a href="#高低音" class="headerlink" title="高低音"></a>高低音</h3><p>即OSD -&gt; SOUND上的Treble/Bass，如图，当Treble=100，Bass=100时得到红线AB，当 Treble=0，Bass=0时得到红线CD，增益范围在±6dB~±8dB，每一根线都是Treble和Bass作用叠加的效果图：<br><img src="https://i.loli.net/2018/02/27/5a9515e332cbe.png"><br>调试点主要有A、B、C、D四个，标准是增益范围，即A到C的增益差，B到D的增益差，有以下几种情况：  </p>
<ol>
<li><p>如需使A点向下移，即需减小Bass=100时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f73d1e.png"><br>如需使A点向上移，同理；  </p>
</li>
<li><p>如需使C点向上移，即需增大Bass=0时候的增益（Treble也有作用，只不过低频段主要影响的是Bass，所以这时一般不改动Treble的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f67a2d.png"><br>如需使C点向下移，同理；  </p>
</li>
<li><p>如需使B点向下移，即需减小Treble=100时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f671a4.png"><br>如需使B点向上移，同理；  </p>
</li>
<li><p>如需使D点向上移，即需增大Treble=0时候的增益（Bass也有作用，只不过高频段主要影响的是Treble，所以这时一般不改动Bass的增益），<br><img src="https://i.loli.net/2018/02/27/5a95166f6ce43.png"><br>如需使D点向下移，同理。  </p>
</li>
</ol>
<p>调好参数后把数据填入<strong>g_arAudioBassTable</strong> 和 <strong>g_arAudioTrebleTable</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/subcustomer_setting.c</em>）。</p>
<h3 id="声音模式"><a href="#声音模式" class="headerlink" title="声音模式"></a>声音模式</h3><p>即OSD -&gt; SOUND上的四种音效模式，不同的声音模式的差别是高低音的设定的不同。不建议修改OSD -&gt; SOUNG上Treble/Bass的默认值，而是通过调整Bass/Treble曲线满足客户需求。调试方法参考高低音调试。<br>如图是8501某板卡的声音模式曲线：<br><img src="https://i.loli.net/2018/02/27/5a9516de46c4f.png"> </p>
<h3 id="其他1"><a href="#其他1" class="headerlink" title="其他1"></a>其他1</h3><ul>
<li><p>分离度：左、右两个声道相互串扰的程度<br><img src="https://i.loli.net/2018/02/27/5a9516de2dfc1.png">  </p>
</li>
<li><p>增益差：左、右两个声道的信号增益之差<br><img src="https://i.loli.net/2018/02/27/5a9516de414d7.png">  </p>
</li>
<li><p>失真度：表示喇叭对输入信号的还原程度，一般来说，输出功率为 1W 时，失真度须小于等于 1%。输出功率最大时须小于等于 7%<br><img src="https://i.loli.net/2018/02/27/5a9516de38c7e.png">  </p>
</li>
<li><p>信噪比：喇叭播放时，正常声音信号强度与噪声信号强度的比值<br><img src="https://i.loli.net/2018/02/27/5a9516de40ee6.png"></p>
</li>
</ul>
<h3 id="其他2"><a href="#其他2" class="headerlink" title="其他2"></a>其他2</h3><ul>
<li><p>AV Out音频输出幅度：带AV Out端子的板卡需要测试这一项目，修改<strong>g_arAudioAuxiliaryVolumeOffset</strong>（<em>aps/customer/s2tek/hk8501/adaptable/board_config.c</em>）</p>
</li>
<li><p>唇音同步：声音图像同步（AV Sync） Audio–&gt;Misc.-&gt;Lipsync：调整 AV Sync，范围为 -200ms~200ms。修改<strong>g_stSettingDefault_FactoryUser</strong>（<em>aps/customer/s2tek/sub_customer/s2tek/s2tek/system_setting/rda_atv/app_data_setting.c</em>）</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>测量声音相关参数时需220V交流供电；</li>
<li>明确各个指标的测试方法和测试标准；测量频响前先确认客户是测电频响（测板卡的）还是声频响（测整机的）；</li>
<li>调试顺序：首先调频响；最大声音功率 &gt; 声音曲线 &gt; 失真度；高低音&gt; 声音模式。</li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>audio</tag>
        <tag>aq</tag>
      </tags>
  </entry>
  <entry>
    <title>一次SKD生产异常</title>
    <url>/2018/12/08/skw-skd/</url>
    <content><![CDATA[<p>客户拿到我们板卡，直接装整机，装好整机后上电升级，有的板卡升级后无法开机。</p>
<span id="more"></span>

<p>一共寄回来19块板子，客户反馈的状态如下：  </p>
<ul>
<li>有11片板子是如下两种状态：  </li>
</ul>
<ol>
<li>上电 按键按一下 灯闪一下 但是不开机 –&gt; 好多板卡都被升级了，此现象无法看到  </li>
<li>按键灯一直是红灯 没反应 不开机 –&gt; 确实有这个现象，有两种不同情况  </li>
</ol>
<ul>
<li>另外8片板子状态如下：  </li>
</ul>
<ol>
<li>有4片是上螺钉时打坏器件 –&gt; 硬件处理  </li>
<li>有1片是指示灯插反 –&gt; 硬件处理  </li>
<li>有1片有时候能开机，有时候不能开机，老化两小时之后，都能开机了 –&gt; 看到的现象是有时候能开机，有时候要自动开好几回才能开起来，后来flash被人换掉，换掉后都能正常开机，然后把旧的flash换回来，也能正常开机了，还不能明白准确原因，看之前的log信息，自动开好几回才能开起来像是DRAM没有跑起来，可是以前有现象的时候，没有量到DRAM电压和core power电压，就被换掉flash，现在也无法复测现象了，只能认为板子焊接有问题导致DRAM不能正常跑起来（如果外围没有问题，可以考虑更换IC尝试）  </li>
<li>有1片3.3V对地短路 –&gt; ？？？  </li>
<li>有1片是上电不开机有1.8V –&gt; 这里应该是core power，这片应该属于11片板那一类  </li>
</ol>
<p>无法开机的，硬件检查都没有异常，板卡都被人重新空片升级掉了，能用的板卡（我手上就两块），有两种情况：  </p>
<ol>
<li>上电后log信息提示“code is not complete”，此类可以重新上电升级。  </li>
<li>上电后log信息只有“S2Tek_a35 08/15”，此类是boot坏掉了，需要进行空片升级。把flash拿下来，读一下，得到：  <blockquote>
<p>0x00000000 ~ 0x0000FFF0: 全部0xFF<br>0x00010000 ~ 0x00377490: 有数据<br>0x003774A0 ~ 0x003EAFF0: 全部0xFF<br>0x003EB000 ~ 0x003EB380: 有数据<br>0x003EB390 ~ 0x003EBFF0: 全部0xFF<br>0x003EC000 ~ 0x003EC270: 有数据<br>0x003EC280 ~ 0x003ECFF0: 全部0xFF<br>0x003ED000: 有数据<br>0x003ED010 ~ 0x003EFFE0: 全部0xFF<br>0x003EFFF0 ~ 0x003F0FF0: 有数据<br>0x003F1000 ~ 0x003F1FF0: 全部0xFF<br>0x003F2000 ~ 0x003FFFF0: 有数据  </p>
</blockquote>
</li>
</ol>
<p>打开出货的ROM bin，发现：<br><img src="https://i.loli.net/2018/12/08/5c0b623b411de.jpg" alt="0x3774a0"><br>根据flash layout，0x003EB000此地址以上是Maincode分区，数据是连续的，以下则是模块分区，各模块之间并不是连续的。于是认为这是上电升级过程中，刚擦除boot的时候就断电了，所以后来上电也无法进行上电升级，更无法开机了，此种情况只能进行空片升级。（若升级前后boot版本相同，升级是不会擦除boot的，这种情况升级过程掉电，重新开机时也能做boot升级。若boot本身也要升级，原先boot code已被擦除而新的boot没能正常写入将会无法开机）  </p>
<p>奇怪的地方在于，19片板卡中，给原厂送去3片分析，有一片是属于“code is not cpmplete”但是可以继续上电升级的情况，但是另外有一片，读出来的rom bin，0H<del>3EC000H数据全部为FF，都被擦掉了，3EC000H</del>3FFFFFH后面部分段落有数据。这个情况看起来属于MENU升级而不属于上电升级，因为MENU升级的升级方式是全部擦除之后再烧写，上电升级则是擦一点写一点，可是客户端的升级方式是上电升级！不过刚才那片被擦掉boot的板卡不能完全明确是上电升级的结果，也可以认为是MENU升级，因为可能是刚刚好擦到boot就掉电了。具体还得跟踪代码才能知道上电升级究竟是不是擦一点写一点，如果是，擦一点写一点是怎么个擦一点写一点法呢？</p>
<p>最后，开机异常的，基本都是flash里面code被擦掉，至于怎么被擦掉，基本认为是升级过程中掉电造成的（客户亦承认工厂会有停电情况，也不能保证工人操作是否规范），不过除此之外，在生产过程中，是否有其他操作环节会擦掉代码？在向客户工厂和我们工厂了解了生产流程后，感觉可能性不大，但是不能说完全没有可能，我没有完全跟踪所有流程，所以很难没有遗漏，抓到“元凶”有一定难度。至于不良板卡读到的flash数据为啥看起来像是菜单升级？先跟踪一下上电升级流程看看吧！</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>红外解码之Toshiba协议简单记录</title>
    <url>/2018/08/22/ir-protocol-toshiba/</url>
    <content><![CDATA[<p>之前给创维做红外白平衡调试的几点记录。  </p>
<span id="more"></span>

<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>客户出大货前需要做白平衡调试，上一年还是用串口来调试，今年全球工厂都用红外来调试了，想不清楚为什么要改用红外来代替串口，感觉用串口更可靠一点。以前的做法是直接用测试主机接到我的TV平台，测试主机通过串口直接给TV下值，现在的做法是测试主机通过串口发给一个红外发射器（看了一下是用STM32做的，不同的红外协议使用的发射器还不一样），发射器再把值通过红外的方式发给TV。  </p>
<p>串口调试图例:<br><img src="https://i.loli.net/2018/08/22/5b7cde4b55468.jpg" alt="串口调试图例"><br>红外调试图例:<br><img src="https://i.loli.net/2018/08/22/5b7cde6b27243.jpg" alt="红外调试图例"></p>
<h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p><img src="https://i.loli.net/2018/08/22/5b7ce03d4c1d7.jpg" alt="红外白平衡设计规范"></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>东芝协议除了引导码和结束位，一帧数据刚好是4个字节，包括两个字节客户码和两个字节的键值。<br><img src="https://i.loli.net/2018/08/22/5b7cf86885007.jpg" alt="frame"><br>而目前代码中对于一帧数据的用法是，客户码2个字节有利用到，但是键值只用了一个字节，反码的那个字节没有利用。原厂的解释是反码部分只是用于验证，目前规格没有利用这部分数据，一直也不影响遥控器使用。<br>我们只要把这4个字节的内容都解出来，就可以实现客户功能</p>
<h3 id="解码算法"><a href="#解码算法" class="headerlink" title="解码算法"></a>解码算法</h3><p>对于“{0x0e0e, 0x11, UI_EVENT_MENU}”这个按键，客户码等于0x0e0e，Keycode等于0x11ee。按下此按键时可以看到如下打印信息：  </p>
<blockquote>
<p> [IR]IR_ISR    IR_len:33    reg0C:0x000010ef    reg54:0x0000e0e1<br> [IR]0    IR:00008877    tmpData:00000000    IR_Custom:00007070<br> [IR]1    IR:443b8000    tmp:000011ee    tmp_Custom:00000e0e<br> [IR]1st reg_single_sts received!!<br> [IR]Single Start Address  Address_  Cmd: 0xe,0xe, 0x11,0xee!!<br> [IR]IR_ISR    IR_len:2    reg0C:0x00000003    reg54:0x00000000<br> [IR]0    IR:00000001    tmpData:00000000    IR_Custom:00000000<br> [IR]1    IR:00008000    tmp:00000080    tmp_Custom:00000000<br> [IR]repeat key received!!<br>_APP_GUIOBJ_PopMsg_OnRelease is called<br> [IR]Single_end received!!  </p>
</blockquote>
<p>而代码中表现如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sisir_toshiba_ParseData</span><span class="params">(UINT8* mmiobase, IR_IOC_IOData* dataBuf)</span></span></span><br><span class="line"><span class="function"></span>{	</span><br><span class="line">	<span class="keyword">volatile</span> UINT32 IR_Data, IR_Custom, IR_bit_len, tmp_data, tmp_Custom, i;</span><br><span class="line">	<span class="keyword">volatile</span> UINT16 tmp_1 = <span class="number">0xffff</span>;</span><br><span class="line">	<span class="keyword">volatile</span> UINT16 tmp_2 = <span class="number">0xffff</span>;</span><br><span class="line">	datBuf = dataBuf;</span><br><span class="line">	IR_Data = irdatas.Value &amp; <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">	IR_Custom = GetMMIO_DWORD(mmiobase, <span class="number">0x54</span>);	<span class="comment">//read from IR decoder recevied custom code</span></span><br><span class="line"></span><br><span class="line">	IR_Custom = IR_Custom &amp; <span class="number">0x1ffff</span>;</span><br><span class="line"></span><br><span class="line">	IR_bit_len = (GetMMIO_DWORD(mmiobase, <span class="number">0x50</span>) &amp; <span class="number">0x3f00</span>) &gt;&gt; <span class="number">8</span>; <span class="comment">//read from IR decoder recevied bit length</span></span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]IR_ISR\tIR_len:%d\treg0C:0x%08x\treg54:0x%08x\n"</span>, IR_bit_len, IR_Data, IR_Custom);</span><br><span class="line">	IR_Data = IR_Data &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ( (IR_Custom &amp; <span class="number">0x1</span> ) == <span class="number">1</span> )</span><br><span class="line">	{</span><br><span class="line">		IR_Data = IR_Data | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line">	IR_Custom = IR_Custom &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	tmp_data = <span class="number">0</span>;</span><br><span class="line">	tmp_Custom = <span class="number">0</span>;</span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]0\tIR:%08x\ttmpData:%08x\tIR_Custom:%08x\n"</span>, IR_Data, tmp_data, IR_Custom);</span><br><span class="line"><span class="comment">//	for ( i=0;i&lt;7;i++ )</span></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++ ) <span class="comment">//fenghl</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> ( IR_Data &amp; <span class="number">0x8000</span> )</span><br><span class="line">		{</span><br><span class="line">			tmp_data = tmp_data | <span class="number">0x8000</span>;</span><br><span class="line">		}</span><br><span class="line">		tmp_data = tmp_data &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		IR_Data = IR_Data &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ( IR_Data &amp; <span class="number">0x8000</span> )</span><br><span class="line">	{</span><br><span class="line">		tmp_data = tmp_data | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	tmp_1 = tmp_data &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	tmp_2 = tmp_data &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	tmp_data = tmp_1 | tmp_2;</span><br><span class="line">	tmp_data = tmp_data &amp; <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	<span class="keyword">for</span> ( i=<span class="number">0</span>;i&lt;<span class="number">15</span>; i++ )</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> ( IR_Custom &amp; <span class="number">0x8000</span> )</span><br><span class="line">		{</span><br><span class="line">			tmp_Custom = tmp_Custom | <span class="number">0x8000</span>;</span><br><span class="line">		}</span><br><span class="line">		tmp_Custom = tmp_Custom &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		IR_Custom = IR_Custom &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ( IR_Custom &amp; <span class="number">0x8000</span> )</span><br><span class="line">	{</span><br><span class="line">		tmp_Custom = tmp_Custom | <span class="number">0x8000</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	tmp_1 = tmp_Custom &gt;&gt; <span class="number">8</span>;</span><br><span class="line">	tmp_2 = tmp_Custom &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	tmp_Custom = tmp_1 | tmp_2;</span><br><span class="line">	tmp_Custom = tmp_Custom &amp; <span class="number">0xffff</span>;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line">	DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]1\tIR:%08x\ttmp:%08x\ttmp_Custom:%08x\n"</span>, IR_Data, tmp_data, tmp_Custom);</span><br><span class="line">	<span class="comment">//IR_Data = tmp_data;</span></span><br><span class="line">	<span class="keyword">if</span> ( IR_bit_len == <span class="number">33</span>)</span><br><span class="line">	{	<span class="comment">// Single start</span></span><br><span class="line">		<span class="keyword">if</span> ( (singleKey == <span class="number">1</span>) || (rpt_cnt != <span class="number">0</span>) )</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> ( ir_timer_flag )</span><br><span class="line">			{</span><br><span class="line">				del_timer(&amp;IR_ContiTimer);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> ( singleKey == <span class="number">1</span> )</span><br><span class="line">			{</span><br><span class="line">				DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]2nd reg_single_sts received!!\n"</span>);</span><br><span class="line">				datBuf-&gt;Databuf[datBuf-&gt;Length].ContinueKey = SINGLE_KEY_END;	<span class="comment">// single end</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			{</span><br><span class="line">				DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]reg_single_sts received during repeat!!\n"</span>);</span><br><span class="line">				datBuf-&gt;Databuf[datBuf-&gt;Length].ContinueKey = CONTINUE_KEY_START_END;	<span class="comment">// continue end</span></span><br><span class="line">			}</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Command = tmp_irCmd;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Command_ = tmp_irCmd_;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Address = tmp_irAddress;</span><br><span class="line">			datBuf-&gt;Databuf[datBuf-&gt;Length].Address_ = tmp_irAddress_;</span><br><span class="line">			datBuf-&gt;Length++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]1st reg_single_sts received!!\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		tmp_irCmd = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_data &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		tmp_irCmd_ = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command_ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_data);</span><br><span class="line">		tmp_irAddress = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_Custom &gt;&gt; <span class="number">8</span>);</span><br><span class="line">		tmp_irAddress_ = dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address_ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(tmp_Custom);;</span><br><span class="line">		DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]Single Start Address  Address_  Cmd: 0x%x,0x%x, 0x%x,0x%x!!\n"</span>, tmp_irAddress, tmp_irAddress_, tmp_irCmd, tmp_irCmd_);</span><br><span class="line">		dataBuf-&gt;Databuf[dataBuf-&gt;Length].ContinueKey = CONTINUE_KEY_HEAD;</span><br><span class="line">		dataBuf-&gt;Length++;</span><br><span class="line">		singleKey = <span class="number">1</span>;</span><br><span class="line">		rpt_cnt = <span class="number">0</span>;</span><br><span class="line">		init_IR_cont_timer(<span class="number">150</span>);		<span class="comment">// 150 ms</span></span><br><span class="line">		ir_timer_flag = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( IR_bit_len == <span class="number">2</span> )</span><br><span class="line">	{</span><br><span class="line">		DBG_MSG1(DBGCFG_IR, <span class="string">"[IR]repeat key received!!\n"</span>);</span><br><span class="line">		<span class="keyword">if</span> ( ir_timer_flag == <span class="number">1</span> )</span><br><span class="line">		{</span><br><span class="line">			del_timer(&amp;IR_ContiTimer);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> ( rpt_cnt == <span class="number">0xff</span> )</span><br><span class="line">		{</span><br><span class="line">			rpt_cnt = <span class="number">1</span>;</span><br><span class="line">		}</span><br><span class="line">		rpt_cnt ++;</span><br><span class="line">		<span class="keyword">if</span> ( (rpt_cnt == <span class="number">4</span>) &amp;&amp; (singleKey == <span class="number">1</span>) )</span><br><span class="line">		{</span><br><span class="line">			singleKey = <span class="number">0</span>;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command = tmp_irCmd;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Command_ = tmp_irCmd_;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address = tmp_irAddress;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].Address_= tmp_irAddress_;</span><br><span class="line">			dataBuf-&gt;Databuf[dataBuf-&gt;Length].ContinueKey = CONTINUE_KEY_START;</span><br><span class="line">			dataBuf-&gt;Length++;</span><br><span class="line">			DBG_MSG1(DBGCFG_IR, <span class="string">"[IR][IR]Continue_key_start\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		init_IR_cont_timer(<span class="number">150</span>);		<span class="comment">// 150 ms</span></span><br><span class="line">		ir_timer_flag = <span class="number">1</span>;</span><br><span class="line">	} </span><br><span class="line">}</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">其中：  </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">irdatas.Value= GetMMIO_DWORD(mmiobase, <span class="number">0x0c</span>);	<span class="comment">//read from IR decoder recevied data</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>Toshiba客户码的高8位和低8位都是一样的？Toshiba一定是一样的,或是反向,硬体那边应该会直接转好反向的,所以到软体这边收到的都会是一样的。  </li>
<li>按遥控器MENU按键（custom code: 0x0E0E, data code: 0x11），示波器抓波形：<br><img src="https://i.loli.net/2018/12/06/5c0915a008d22.jpg" alt="UI_EVENT_MENU"><br>先发0x0E(0b00001110)，再发0x0E(0b00001110)，接着发0x11(0b00010001)，最后发0xEE(0b11101110)，由每个字节的低位开始发，所以示波器上按时间从早到晚（按图上从左到右）计算，得到：  <blockquote>
<p>01110000 01110000 10001000 01110111  </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>rda</tag>
        <tag>toshiba</tag>
        <tag>remote</tag>
        <tag>ir</tag>
      </tags>
  </entry>
  <entry>
    <title>一个DVB-C自动搜台的疑问</title>
    <url>/2018/12/18/dvbc-auto-tuning/</url>
    <content><![CDATA[<p>DVBC搜台过程中，频点乱序。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Mantis提交了一条问题：DVBC搜台过程中，进度条在前进，频点也在跳动，但是乱序，并非从低到高。<br>实际情况是：码流机播放《610.750 Network ID 1536.ts》码流，频点设定到482MHz，DVBC搜台过程中，频率从低到高搜，但是搜到482MHz的时候，频率就乱了。  </p>
<h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><p>截取部分log信息：  </p>
<blockquote>
<p>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 474000000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 474000000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 474000000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=474000000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 0<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=474000000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>xUpdateChannelMgr 211 RemoveChannel 474000000<br>[xRemoveChannel:2220]<br>[bool CDvbTableScanner::xGetNitFreqList(bool) 139] errCode = 1900551, freqCount = 0<br>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 482000000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 482000000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 482000000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=482000000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 1<br>virtual void CDtvFreqDetector::xStageBeginFreq()_304 signal LOCKED !!!!!!!!<br>[virtual void CDtvFreqDetector::xStageCheckFrontend() 771] m_curFreq = 482000000, m_curBandwidth = 8000000 m_modulation = 11<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=482000000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>xUpdateChannelMgr 211 RemoveChannel 482000000<br>[xRemoveChannel:2220]<br><strong>[bool CDvbTableScanner::xGetNitFreqList(bool) 139] errCode = 0, freqCount = 39</strong><br><strong>xGetNitFreqList..freq:482750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:458750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:124000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:466750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:506750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:578750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:386750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:498750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:626750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:650750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:148000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:714750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:698750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:706750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:762750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:826750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:858750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:642750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:778750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:810750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:834750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:746750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:298750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:602750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:610750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:850750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:140000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:738750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:530750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:818750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:690750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:164000000, symbolRate:6900000, modulation:9, polarization:0</strong><br><strong>xGetNitFreqList..freq:842750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:666750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:682750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:156000000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:554750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:490750000, symbolRate:6900000, modulation:11, polarization:0</strong><br><strong>xGetNitFreqList..freq:132000000, symbolRate:6900000, modulation:11, polarization:0</strong><br>[Mf_ScanInit 1000] modeEx=0, param=-1, scanMode=7 m_deleteAll=1<br>[xRemoveChannel:2288] m_chVector.m_size=39<br>ScanInit….type 2 antennaIndex 0xffffffff typeEx 0 time 304186343<br>[virtual void CTableScanner::xWorkerThread() 139] CH_SCAN_STATE_BEGIN_FREQ start<br>[virtual void CTableScanner::xWorkerThread() 145] CH_SCAN_STATE_SCANNING start<br>xStageBeginFreq:161:: m_isDeleteAll = 1, m_curFreq = 482750000<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 296] isScanMode = 1, m_curFreq = 482750000, m_curBandwidth = 8000000, tunerId = 0, m_feType = 2, m_modulation = 11,  m_symbolrate = 6900000<br>[bool FrontendLib_SetTuner(UINT32, UINT32, UINT8, RT_FRONTEND_TYPE, RT_MODULATION, RT_SPECTRAL_INVERSION, bool, UINT32, SatelliteInfo *) 156] isScanMode = 1, frequency = 482750000, bandwidth = 8000000, tunerId = 0, feType = 2, modulation = 11,  symbolRate = 6900000<br>[FrontendLib_SetTuner 174] frequency=482750000 bandwidth=8000000 tvSystem=19<br>[virtual void CDtvFreqDetector::xStageBeginFreq() 298] ret = 1<br>virtual void CDtvFreqDetector::xStageBeginFreq()_304 signal LOCKED !!!!!!!!<br>[virtual void CDtvFreqDetector::xStageCheckFrontend() 771] m_curFreq = 482750000, m_curBandwidth = 8000000 m_modulation = 11<br>[virtual void CTableScanner::xWorkerThread() 166] CH_SCAN_STATE_SCANNING end<br>[virtual void CTableScanner::xWorkerThread() 171] CH_SCAN_STATE_END_FREQ begin<br>[xUpdateChannelMgr:197] freq=482750000, bSave=1, bUpdateCurChIndex=0, bKeepChannel=0, curFrequency=0, modulation=11<br>bool CDvbSiMgr::xUpdateChannelMgr(__UINT32, INT16, bool, bool, bool, __UINT32, RT_MODULATION) 218 count 6<br>AddChannel:LCN=1,chName=Nederland 1 HD,frequency=482750000<br>AddChannel:LCN=2,chName=Nederland 2 HD,frequency=482750000<br>AddChannel:LCN=3,chName=RTL Lounge,frequency=482750000<br>AddChannel:LCN=4,chName=TVE,frequency=482750000<br>AddChannel:LCN=5,chName=HZN Barker 1,frequency=482750000<br>AddChannel:LCN=6,chName=HZN Barker 2,frequency=482750000<br>bool CDvbSiMgr::xUpdateChannelMgr(__UINT32, INT16, bool, bool, bool, __UINT32, RT_MODULATION) use time 0  </p>
</blockquote>
<p>使用码流分析工具查看码流：<br><img src="https://i.loli.net/2018/12/18/5c18b1955d467.png" alt="NIT">  </p>
<p>代码片段[RTD2831]：  </p>
<pre><code class="cpp">bool CDvbTableScanner::xGetNitFreqList(bool bDelete)
{
    int freqCount=0;
    SI_DELIVERY_PARAM *pFreqList = NULL;
    ErrCode errCode;
    int startindex=0;
    bool bDelFollow=false;
    bool bAddCurrent=false;
    bool bIncludeExistTP=false;
    RT_FRONTEND_TYPE feType = m_pFreqScanDetector-&gt;Mf_GetFrontendType();
    SI *siHandle = (SI*)((IDtvMedia*)m_pTvMedia)-&gt;GetDtvFlow()-&gt;GetSiHandle();
    if(feType == RT_FRONTEND_DVB_CABLE &amp;&amp; !m_bRemoveAll)
    {
        bIncludeExistTP=true;
    }

    errCode = SI_GetFreqList(siHandle, &amp;freqCount, &amp;pFreqList, bIncludeExistTP);
    ALOGD("[%s %d] errCode = %lu, freqCount = %d\n", __func__, __LINE__, errCode, freqCount);

    if (errCode != SI_ERR_OK || freqCount==0 || pFreqList == NULL)
    {
        return FALSE; //如果freqCount为零，就返回了。
    }

    if(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_HomeTp.count!=0)
    {
        bDelete=true;
        if(m_HomeTp.onid!=0)
        {
            bDelete=false;
            for(int i=0;i&lt;freqCount;i++)
            {
                if(pFreqList[i].onid==m_HomeTp.onid)
                {
                    bDelete=true;
                    break;
                }
            }
        }
    }

    if(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; bDelete &amp;&amp; m_pFreqList!=NULL)
    {
        bDelFollow=true;
        bDelete=false;
    }

    if(bDelete || m_pFreqList==NULL)
    {
        xFreeTable();
        
        m_pFreqList = (RT_PHY_CHANNEL *)malloc(sizeof(RT_PHY_CHANNEL) * (freqCount+1));
        if(m_pFreqList == 0)
            return false;
        m_freqListSize = freqCount+1;
        memset(m_pFreqList, 0, sizeof(RT_PHY_CHANNEL)* (m_freqListSize));
        m_isMallocedList=true;
        
        if(feType == RT_FRONTEND_DVB_CABLE)
        {
            bAddCurrent=true;
        }
    }
    else
    {
        RT_PHY_CHANNEL *pFreqList;
        int sizeTmp=m_freqListSize;
        pFreqList = (RT_PHY_CHANNEL *)malloc(sizeof(RT_PHY_CHANNEL)* (sizeTmp+freqCount));
        if(pFreqList==NULL)
        {
            return false;
        }
        memcpy(pFreqList, m_pFreqList, sizeof(RT_PHY_CHANNEL)* (sizeTmp));
        xFreeTable();
        m_pFreqList=pFreqList;
        if(bDelFollow)
            startindex=m_curFreqIndex;
        else
            startindex=sizeTmp;
        m_freqListSize=sizeTmp+freqCount;
        m_isMallocedList=true;
    }

    for (int i = 0; i &lt; freqCount &amp;&amp; startindex&lt;m_freqListSize; i++)
    {
        m_pFreqList[startindex].channelNum = startindex;

        m_pFreqList[startindex].frequency = pFreqList[i].frequency;

        switch (pFreqList[startindex].modulation)    // Cable delivery system descriptor, defined in en300468 DVB-SI spec
        {
            case SI_DVB_16_QAM:      // 16QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM16;
                break;
            case SI_DVB_32_QAM:      // 32QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM32;
                break;
            case SI_DVB_64_QAM:      // 64QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM64;
                break;
            case SI_DVB_128_QAM:      // 128QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM128;
                break;
                        default:
            case SI_DVB_256_QAM:      // 256QAM,
                m_pFreqList[startindex].modulation = RT_MOD_QAM256;
                break;
        }
        m_pFreqList[startindex].symbolRate = pFreqList[i].symbol_rate;


        if(feType == RT_FRONTEND_DVB_SATELLITE)
        {
            m_pFreqList[startindex].modulation = pFreqList[i].modulation_system == 0 ? RT_MOD_DVB_S : RT_MOD_DVB_S2;
            m_pFreqList[startindex].symbolRate = pFreqList[i].symbol_rate;
        }


        m_pFreqList[startindex].bandwidth = 8000000;
        m_pFreqList[startindex].polarization= pFreqList[i].polarization%2;
        if(bDelete || iSNewTP(m_pFreqList,startindex,&amp;m_pFreqList[startindex]))
        {
            ALOGD("%s..freq:%d, symbolRate:%d, modulation:%d, polarization:%d\n",__FUNCTION__,m_pFreqList[startindex].frequency,m_pFreqList[startindex].symbolRate,
            m_pFreqList[startindex].modulation,m_pFreqList[startindex].polarization);
                startindex++;
        }

        if(bAddCurrent &amp;&amp; startindex&lt;m_freqListSize)
        {
            if(m_curFreq/1000000 == m_pFreqList[startindex].frequency/1000000)
            {
                bAddCurrent=false;
            }
        }
    }

    if(bAddCurrent)
    {
        m_pFreqList[startindex].frequency = m_curFreq;
        m_pFreqList[startindex].bandwidth = m_curBandwidth;
        m_pFreqList[startindex].channelNum = m_curChNum;
        m_pFreqList[startindex].modulation = m_curModulation;
        m_pFreqList[startindex].symbolRate = m_curSymbolRate;
        m_pFreqList[startindex].polarization = m_curPolarization;
        startindex++;
    }

    m_freqListSize=startindex;
    return true;
}

bool CDvbTableScanner::iSNewTP(RT_PHY_CHANNEL *src, int size, RT_PHY_CHANNEL *pTp)
{
    if(pTp-&gt;frequency == 0)
        return FALSE;
    for(int i=0;i&lt;size;i++)
    {
        if(abs((int)src[i].frequency/100000 - (int)pTp-&gt;frequency/100000) &lt; 3)
        {
            if(src[i].symbolRate != pTp-&gt;symbolRate)
                continue;

            if(src[i].polarization != pTp-&gt;polarization)
                continue;

            if(src[i].modulation != pTp-&gt;modulation)
                continue;

            return false;
        }
    }
    return true;
}
</code></pre>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可知是NIT的原因，自动搜台的时候（如果没有指定频点）会从频点由低往高搜台，搜到台后，解析NIT时发现有FreqList，就去FreqList里面的频点搜。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>NIT(Network Information Table 网络信息表)。此DVB列表包含了有关网络的范围、转换器等信息。它总是位于PID 0x0010的位置。DVB定义了两种类型的NIT，NIT Actual与NIT Other。NIT Actual是一个包含有关正在被访问的网络的物理参数的一个命令列表。NIT Other包含了有关其他网络的物理参数，NIT Other是可选项。  </li>
<li>NIT搜索就是从NIT表开始的搜索，NIT表中的第二个循环，给出了当前网络中的频点，调制方式，符号率。搜索NIT表知道这些消息以后，将得到的频点做一个列表，然后挨个锁频，在每个频点下搜索PAT,PMT，然后得到节目，搜索完所有的频点以后，当前网络所有的节目就得到了。  </li>
<li><a href="https://blog.csdn.net/kkdestiny/article/details/12994675">【PSI/SI学习系列】2.PSI/SI深入学习3——SI信息解析1(NIT,BAT)</a>  </li>
<li><a href="https://blog.csdn.net/rongdeguoqian/article/details/40372097">DVB-SI理解入门</a>  </li>
<li><a href="https://www.xjishu.com/zhuanli/62/200810067838.html">现有数字电视的搜台方式包含两大类全频点搜台和利用NIT (Network Information Table,网络信息表)快速搜台。前者的做法与模拟电视相似，根据频压曲线的变化和解码器相关数据当前的状态改变步进从低频到高频逐步扫描，这种过程一般会超过20分钟，并且由于无法利用NIT表，没有节目自动更新的功能；而后者先找到NIT并从NIT中提取Frequency List Descriptor(频率列表描述子)，利用频率列表描述子所带的频率信息，快速定位到每一个有信 号的频率点，从而完成快速搜台</a></li>
</ul>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>realtek</tag>
        <tag>dvb</tag>
        <tag>dvb-c</tag>
        <tag>dtv</tag>
        <tag>si</tag>
        <tag>scan</tag>
      </tags>
  </entry>
  <entry>
    <title>步履不停</title>
    <url>/2019/01/06/tokugawa-ieyasu/</url>
    <content><![CDATA[<p>读完了《德川家康》，摘抄几个句子，状态差的时候看一看。</p>
<span id="more"></span>

<ul>
<li><p>“阿久，你一定要忍耐，这个时代需要的就是忍耐。人们必须克制心中的欲望，懂得忍让。人生在世无不如此，这是命中注定的。”  </p>
</li>
<li><p>“只要你剃了头发，那些以前闭门不见客的人也会以礼佛的名义见你……哈哈，这也是随风的策谋。”  </p>
</li>
<li><p>信长意味深长地微笑了，神态根本不像只有十四岁的少年，“人生之事无不是雅兴，今日也不例外。你这次给我带来了什么？”  </p>
</li>
<li><p>常思此世间，飘零无定处。直叹水中月，浮生若朝露。人生五十年，如梦亦如幻。有生斯有死，壮士何所憾？  </p>
</li>
<li><p>如果只有某一个人能够做到高瞻远瞩，那么政治和战斗将无法展开…..  </p>
</li>
<li><p>“真好，能够活到今天。”  </p>
</li>
<li><p>“掉以轻心了吧！”浪人哈哈大笑，“绝不可轻言主动进攻。但对方发起攻击，就必须漂亮地予以反击。但又需在击退敌人的同时，保证自己的安全。不攻击对方，也不要被对方击中。这才是大将之剑。”  </p>
</li>
<li><p>人要能够打造自己的身体。猥琐的身体只能附着猥琐的灵魂。  </p>
</li>
<li><p>“作为大将，要吃朝霞和彩云，强筋健体；要内心哭泣，脸上微笑”  </p>
</li>
<li><p>“是我违背了忍耐的誓言，我太心急了。”  </p>
</li>
<li><p>“凡事不可慌张。慌张使人目盲。”  </p>
</li>
<li><p>已经来临的人生之冬是人力无法阻止的。  </p>
</li>
<li><p>“不能发怒！”  </p>
</li>
<li><p>再也没有比将人生作为赌注更让人爽快之事了。信长果然如藤吉郎所料地行动。如此一来，藤吉郎就可以发挥自己的智慧，去赢得这场人生的豪赌。他将赌注下在信长这匹烈马身上，而这匹烈马，大概会一直驰骋纵横，直到人生最后一刻。  </p>
</li>
<li><p>此事并非完全出乎意料。只要义元不死，就无法打破当前势力的均衡，那他松平元康就只能继续做骏府的人质。甚至可以说，元康一直在等待义元之死。<br>  元康不经意抬头望着天空，乌云散尽，繁星闪烁，一颗流星忽然坠向南方的海面。如此辽阔的天地，居然没有冈崎人立锥之地–他真切地感受到了命运的残酷，但并未绝望。处境如此险恶，他反而想笑。<br>  望着天空中闪烁的星星，元康不断反省当前他应该抛弃的东西。首先应该抛弃的，是这座孤城。至于妻子和孩子，他已经抛弃了。日夜思念的母亲，他已经见过了，那见面也就可以当做别离。对冈崎城的执著应该抛弃，还有，冥冥中支撑着他奋斗的“运气”–那模糊的幻影，现在也应完全抛开。不，仅仅扔掉这些东西，还无法行动自如。还要抛弃什么呢？元康眼前突然浮现出雪斋禅师的脸。他笑了。最后应该抛弃的，是我自己，唯有完全没有了自己，无限静寂的“无”才能显露出来–雪斋长老留给元康的那个“无”，多年后，终于又回到元康心中。  </p>
</li>
<li><p>但是於大不想诅咒人生的悲惨，她甚至还希望宽恕那一切，希望一切走向光明，并一直为此默默祈祷。她认为，宽恕一切，能够让人逐渐变得坚强和伟大。  </p>
</li>
<li><p>“我从今以后不会性急，却也要一刻不停。”  </p>
</li>
<li><p>永禄十年腊月，家康得到敕许，改姓德川。  </p>
</li>
<li><p>后天的努力能改变人的命运吗？非要改变那些无法改变的东西，到头来只是徒劳；本可以改变的却不努力，就是懈怠。也就是说，既存在因人的后天努力而改变的命运，也确实存在着由命运主宰的人生。令人迷惑的是，人不可逆天而动，但人的所动，都是因为希望逃脱宿命。  </p>
</li>
<li><p>三左卫门出去后，家康长叹一声，禁不住哈哈大笑，但马上自责：尔岂可幸灾乐祸！  </p>
</li>
<li><p>“女人难道就这么害怕独守空房吗，阿浓？”浓夫人没有回答。    </p>
</li>
<li><p>浓姬很清楚，大概是年龄逐长的缘故，从十七八岁就开始咏叹“人生五十年”的丈夫，即使牺牲生命，也要在这个世界建立新秩序，这是他的大悲愿。当她不明白丈夫的心志时，心情是舒畅的；明白以后，她变得痛苦。  </p>
</li>
<li><p>生难死亦难，眼际乌云漫，蓦然回首间，山端明月现。  </p>
</li>
<li><p>对秀吉来说，没有哪一次战役不是他命运的转折点。这只猴子总是拼尽全力做每一件事。  </p>
</li>
<li><p>“太夫，如果说人生只有五十载，我早已足够了。“久政脸上浮现出笑容，”我的一生无怨无悔，始终按照自己的意志行事，不曾失节。“  </p>
</li>
<li><p>“不……柔弱正是你的力量。柔弱而又坚强的人，最易惹人发火。”  </p>
</li>
<li><p>如果只讲策略，不论感情，所为就不合天意，如此一来，随时可能会被自己的策略颠覆。  </p>
</li>
<li><p>自助者，天助之。命运之事，怎能随便试探？命运便是时刻准备着，不断前进，不断忍耐，除此之外，别无他途。  </p>
</li>
<li><p>“面临战斗时，一定要牢牢控制住自己，不要贸然进击，而是要忍耐、等待，等待战机。在这方面，甲州信玄公最有心得。”  </p>
</li>
<li><p>“从今往后，无论什么人，都得学会隐忍，世上再也没有比隐忍更好的盾牌了。你明白吗？并不是什么人都能忍的。能忍人之不能忍者，将来方能成大器。”  </p>
</li>
<li><p>信长势如破竹，扩展着自己的势力。信长越扩张，家康就越内敛，两人之间的差距越来越大，就像走向了阴阳两极。  </p>
</li>
<li><p>人生，生是那么漫长，死却是如此迅速而脆弱。  </p>
</li>
<li><p>秀吉超常的精力，源自他从不把辛劳作为辛劳来看待，在他的胸中，从来就无“辛劳”之辞。他夜以继日，每进一步，都会感到无比的快乐，也感到莫大的欣慰。这种“辛劳之乐”非但不会令人疲劳，只会磨炼人的意志，鼓舞人的精神。从这个意义上来说，秀吉仿佛一名无我之人，而他的喜悦便如登高回望之情。在四十七载沉浮中，他深深地体味到了这种“辛劳之乐”的功效，一直将其奉为座右铭。  </p>
</li>
<li><p>可能每个人的一生都是无家可归的，只不过是进行着一次遥远的旅程罢了。  </p>
</li>
<li><p>“随风无敌人，因为他总是以心换心。”  </p>
</li>
<li><p>“我曾受雪斋禅师严训。禅师说，碰到困难时，要心中无物，这样，道理便会显现，便能心领神会了。‘无’便可通神明之心。”  </p>
</li>
<li><p>战事中，遇到阻碍，比战败更能体现大将性情。进退有方，才是大将之材，一般人却难以做到。  </p>
</li>
<li><p>木食上人默默待在一旁。从聚乐第到伏见，再从伏见到高野山，对于关白秀次，这短短的旅程，竟是他的省悟之旅，甚至远胜他二十八年的苦恼人生。律己恕人，多么重大的发现，对人宽容，便畅通无阻；反之，人生就会陷入无尽的黑暗。“我佛宗旨便是如此。对自己严格要求，对他人宽宏大量……只有这样，人生才会丰富多彩；不懂得这些，生活便贫乏寡淡。如今，大人的人生即将变得丰富。”“上人，我想在这里向大政所谢罪。”“贫僧以为，此乃善事。”  </p>
</li>
<li><p>世上并非事事都能如人所愿，这并非人的过错。  </p>
</li>
<li><p>难道家康历尽千辛万苦，隐忍了五十余年，也会像松永久秀和明智光秀那样徒劳一生？  </p>
</li>
<li><p>人无论心胸有多宽广，却还有解不开的结。  </p>
</li>
<li><p>这果真是一场欣求净土的战事吗？每当出战，家康总是扪心自问，这已成了他勇气的源泉。  </p>
</li>
<li><p>十九岁时就已立起的旗帜，他花甲之年依然不倒。不同的是，当初立下这面旗帜时，身边只有十几个人，而今他拥有万千威武之师。  </p>
</li>
<li><p>家康终生隐忍，绝不冒进，始终稳坐钓鱼台，静观天下势。但不动则已，动必中的。  </p>
</li>
<li><p>“大将悲哀时不能哭，在苦累时要忍耐，有好吃的东西时要分给家臣。怎样，五郎太丸，你能成为大将吗？”  </p>
</li>
<li><p>命数不会眷顾一个无所事事之人，特意为他开辟一条出人头地的道路。  </p>
</li>
<li><p>去岁新年，胜重曾问家康，身为所司代，为政应注意什么。家康道：“人一生如负重致远，不可急躁。以不自在为寻常事，则不觉不足。心生欲望时，当思先前困窘之日。”言毕，家康又微笑道：”忍耐乃长久根本，愤怒是人生大敌。只知胜而不知败，自害其身。常思己过，勿怪人非。凡事过犹不及。“  </p>
</li>
<li><p>如今，家康终于等到了嫡孙出生。这个孩儿的祖父是征夷大将军，拥有着无上的权力。然而家康再怎么得意，也不至于忘形，因今日一切都是他艰苦奋斗所得。  </p>
</li>
<li><p>用人时，不能让人心慰，人定不会尽全力。  </p>
</li>
<li><p>家康看到事情于天下不利时，自会放弃无谓的忍耐，但表面上却会不动声色。正因如此，不管高台院在道歉时，家康装得多么若无其事，他也不会因此而改变主意。  </p>
</li>
<li><p>”意外之风带来的凉意，很容易让人昏昏欲睡。”  </p>
</li>
<li><p>“真正的大将既能坐于漏船，亦能够卧于火屋。”  </p>
</li>
<li><p>事不宜迟，正月里可借“拜年”之名，做许多大事。  </p>
</li>
<li><p>秀忠果然严格按照义理约束自己。  </p>
</li>
<li><p>满座人鸦雀无声。众人都感到，许久不见的、只有作战议事时才有的杀气，又从家康身上散发出来。  </p>
</li>
<li><p>“人有病，天知否？”  </p>
</li>
<li><p>“万物皆有源，如花果皆有种子。”  </p>
</li>
<li><p>许久，宗矩才明白，家康公的眼睛清澈如水，许可看到冥界。  </p>
</li>
<li><p>“兵法与为人之道本是一途。”  </p>
</li>
<li><p>盛世大和花竞放，千秋万代颂春风。  </p>
</li>
<li><p>“憎人之心不可有，律己之心不可无。”  </p>
</li>
<li><p>家康其颜如佛，祥和安宁。他被病痛折磨了这么久，鼻梁却似比平日更是挺拔。所谓往生，当是这般模样。  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/01/16/selection-sort/</url>
    <content><![CDATA[<p>选择排序，字面意思就是依次选出最大/小值、次最大/小值、次次最大/小值、次次次最大/小值……  </p>
<span id="more"></span>

<p>直接贴代码：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	min = i;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">	{</span><br><span class="line">	    <span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">	    {</span><br><span class="line">		min = j;</span><br><span class="line">	    }</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(min!=i)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[i];</span><br><span class="line">	    a[i] = a[min];</span><br><span class="line">	    a[min] = temp;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    selection_sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优化思路是可以在一个循环里面不仅仅是选取最大/小值，而是同时把最大值和最小值取出来。优化代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(left=<span class="number">0</span>,right=length<span class="number">-1</span>;left&lt;right;left++,right--)</span><br><span class="line">    {</span><br><span class="line">	min = left;</span><br><span class="line">	max = right;</span><br><span class="line">	<span class="keyword">for</span>(i=left;i&lt;=right;i++)</span><br><span class="line">	{</span><br><span class="line">	    <span class="keyword">if</span>(a[min]&gt;a[i])</span><br><span class="line">		min = i;</span><br><span class="line">	    <span class="keyword">if</span>(a[max]&lt;a[i])</span><br><span class="line">		max = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(min!=left)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[left];</span><br><span class="line">	    a[left] = a[min];</span><br><span class="line">	    a[min] = temp;</span><br><span class="line">	    <span class="keyword">if</span>(max==left)  <span class="comment">//why</span></span><br><span class="line">		max = min; <span class="comment">//why</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(max!=right)</span><br><span class="line">	{</span><br><span class="line">	    temp = a[right];</span><br><span class="line">	    a[right] = a[max];</span><br><span class="line">	    a[max] = temp;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    selection_sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一开始想不通交换min值的时候为什么要重新获取max值，画个图就一目了然了。 </p>
<blockquote>
<p>if(max==left)<br>  max = min;  </p>
</blockquote>
<p><img src="https://i.loli.net/2019/01/17/5c3fe03bb93a5.jpg" alt="selectionSort"><br>因为i是由left坐标遍历到right坐标，所以最大值有可能落在left的坐标上，当最大值落在left坐标时，交换最小值的时候， a[left]与a[min]交换了，原本最大值是a[left]在left位置，交换最小值后转移到min位置，即此刻最大值的坐标落在min的位置，而不是原来left的位置。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2019/01/04/bubble-sort/</url>
    <content><![CDATA[<p>冒泡排序，思路是相邻两个的两两比较。  </p>
<span id="more"></span>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>C  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">               a[j<span class="number">-1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>{</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = length -<span class="number">1</span>; j &gt; i; j--) {</span><br><span class="line">				<span class="keyword">if</span>(a[j] &lt; a[j-<span class="number">1</span>]) {</span><br><span class="line">					<span class="keyword">int</span> temp = a[j];</span><br><span class="line">					a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">					a[j-<span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">		BubbleSort bs = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">		bs.sort(a,a.length);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i:a) {</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>添加打印信息，修改代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">               <span class="keyword">int</span> temp = a[j];</span><br><span class="line">               a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">               a[j<span class="number">-1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">		<span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; length; s++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[s]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    sort(a,length);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译运行，得到有如下打印信息：  </p>
<blockquote>
<p>1 4 5 2 7 3 6<br>1 2 4 5 3 7 6<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7<br>1 2 3 4 5 6 7  </p>
</blockquote>
<p>发现从第3行开始便是多余的动作，如何优化呢？当再没有两两交换发生时，退出便是，这里优化的外层的循环。修改代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		flag = <span class="number">0</span>; <span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>; <span class="comment">//优化</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="comment">//优化</span></span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">//优化</span></span><br><span class="line">		<span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; length; s++)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[s]);</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>是否有机会优化内层循环？对于一组数据，可能有一部分数据是有序的，此时记录最后一次发生交换的位置，下次比较就从开始比较到刚才记录的位置，可减少多余的比较，因为此位置后面的数据是有序的，后面就不需要比较这些内容。<br>修改代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; k; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				pos = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		k = pos;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>完整c代码：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = length - <span class="number">1</span>; j &gt; k; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">				a[j<span class="number">-1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				pos = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		k = pos;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	sort(a,length);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/hansionz/article/details/80822494">【排序】：冒泡排序以及三种优化</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>PAL M 识别成 NTSC M</title>
    <url>/2019/01/14/PALM/</url>
    <content><![CDATA[<p>搜台后 PAL/M 为什么会识别成 NTSC/M ？  </p>
<span id="more"></span>

<p>客户提出一个疑问：自动搜台 PAL/M 为什么会识别成 NTSC/M ？<br>事实上，跟搜台方式无关，无论自动还是手动搜台，结果都一样，在AV通道同样。<br>做如下实验：<br>54200设定 PAL M chroma = off，ATV图像无颜色，屏显是 NTSC M<br>54200设定 PAL M chroma != off，ATV图像有颜色，屏显是 PAL M<br>54200设定 NTSC M chroma = off，ATV图像无颜色，屏显是 NTSC M<br>54200设定 NTSC M chroma != off，ATV图像有颜色，屏显是 NTSC M  </p>
<p>判断制式的做法是先判断扫描线数，PAL/M和NTSC/M都是525行，如果没有色副载波，就默认是NTSC/M了，关闭chroma，就没有了色副载波信号，所以PAL/M会被识别成NTSC/M。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>palm</tag>
        <tag>ntscm</tag>
        <tag>atv</tag>
      </tags>
  </entry>
  <entry>
    <title>Android延迟执行的三种方式</title>
    <url>/2019/01/18/android-delay/</url>
    <content><![CDATA[<p>Android延迟执行的三种方式</p>
<span id="more"></span>

<ul>
<li><p>线程  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>); <span class="comment">// 休眠1秒</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>延时器</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">},<span class="number">1000</span>); <span class="comment">// 延时1秒</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Android消息处理</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 延时执行的代码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	}</span><br><span class="line">},<span class="number">1000</span>); <span class="comment">// 延时1秒</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何克服自我怀疑？</title>
    <url>/2019/01/31/null/</url>
    <content><![CDATA[<p>容易自我怀疑，如何克服？网友的回答。  </p>
<span id="more"></span>

<h4 id="来自bgwzh的回答"><a href="#来自bgwzh的回答" class="headerlink" title="来自bgwzh的回答"></a>来自bgwzh的回答</h4><p>克服是不可能克服的，这辈子都不行。虽然克服不了，但你可以选择修正。  </p>
<p>修正的话你就要搞清楚为什么你会自我怀疑。其实说白了很简单，就是你心智参数配置问题。  </p>
<p>因为你过去的经验，所以你给自己设定了一个“无能者”或“失败者”的称号。所以每次做事，你看看自己的这个称号，你就会开始自我怀疑。因此，解决办法就是移除这个称号，让你对自己有一个正确的认识。  </p>
<p>具体方法是，回忆过去所有失败的经验，然后去思考自己为什么失败。那是你能力欠缺还是外界因素。有些领导喜欢说不要找借口。虽然有些确实是借口，但有些确是理由。比如让你一天之内开发出一个完善的系统。你能做到吗？做不到，你的理由就不是借口。你需要衡量自己的能力，只有你自己知道你到底是不是在找借口。因此对自己诚实很重要。如果你总是自欺，你就会慢慢变得越难觉察自己真实的情况。  </p>
<p>当你得出结论之后，不要去强化并再度认可自己的称号。不要用几个事件就决定拥有无限可能的自己。你是什么样的不能从你做过的事上得出结论，那只能得出，你选择成为了那个样，这个结论。你可以选择失败，同样可以选择成功。只要吸取并利用好过去的经验。  </p>
<p>我不清楚你的具体情况，你也可能没有失败的经验，且几乎每一次都会成功，但你每次还是会自我怀疑。如果你是这种情况，那就是你童年时给自己设定了错误的认知所致。认知的设定可能源于你家人对你的评判，你接受了，并把这评价设置为自己的标签，于是你就会在每次做事时都会感受到自我怀疑。  </p>
<p>如果你是这种情况，那你就需要把注意力放在你成功的案例上。同样的，去思考你成功的原因，只要你能得出这个成功你能力大于巧合这个结论，那你就完成了。你不是一个“不行”的男人，你很可以，只是你觉得自己不行罢了。你现在已不同往日，你已经长大了，没必要再用童年时的自我标签了。你可以抛开过去，为自己重新做诠释。  </p>
<p>@gabon 这位兄弟说他会有焦虑。其实焦虑的本质是恐惧，你恐惧自己不行，也恐惧失败。如何修正对自己的认识上面说了，现在说下如何修正对失败的恐惧。  </p>
<p>恐惧失败只有两个原因，一是恐惧失败后自己的形象受损，一是恐惧失败后自己的身体受损。因此，你只需要理解人都会犯错，并支持这个认知，你就可以免于害怕自己形象的受损。你无需做一个完美无缺之人。你也做不到。  </p>
<p>至于身体受损的担心就更好说了，你只要反问自己，失败了，你会死吗？你不会死，也没那么容易死。你喜欢考虑很多，给自己未来以保障。然而生命无常，计划永远赶不上变化。你给自己设想的保障，说不定明天就会被公司裁员所打破。要适当的享受冒险，你才能活的安心。  </p>
<p><strong>一定要把车到山前必有路与天无绝人之路奉为你的座右铭，你才能安住于当下，不念过去，不惧未来。只有现在是真实的，未来的情况你无法预测，也无需预测。只要在当下把事情做好就行了，未来自会以它该是的样子而来。你只需要接受即可。人不是来这无常的世界体验永恒与安定的，而是来这体验变化与精彩的。按这个思想来对待生活吧，你必会体验到生命的美好。</strong>  </p>
<p>以上。  </p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>ego</tag>
        <tag>life</tag>
        <tag>live</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/02/08/insertion-sort/</url>
    <content><![CDATA[<p>如何去理解插入排序？我的方法是：已知选择排序的思路是选出特定元素去组成新的序列，对于插入排序而言，是要把元素插入到有序序列。  </p>
<span id="more"></span>


<p>代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="comment">//直接插入排序，产生从小到大的序列</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        {   </span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>]) <span class="comment">//这个条件是要判断当前元素是否要插入到有序序列</span></span><br><span class="line">                {   </span><br><span class="line">                        t = a[i]; <span class="comment">//把要插入的值先保存出来</span></span><br><span class="line">                        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;t;j--)</span><br><span class="line">                        {   </span><br><span class="line">                                a[j+<span class="number">1</span>] = a[j]; <span class="comment">//把元素往后挪，直到找到要插入的位置</span></span><br><span class="line">                        }   </span><br><span class="line">                        a[j+<span class="number">1</span>] = t; <span class="comment">//终于找到要插入的位置了，赋值</span></span><br><span class="line">                }   </span><br><span class="line">        }   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上为直接插入排序，如果数据量比较大，尝试用二分插入排序，可以减小比较次数。因为相对于直接插入排序，一边比较一边找插入位置而言，二分插入排序的做法是先通过比较找到要插入的位置，然后挪元素，这里二分法找位置会较快。<br>二分插入排序，代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">        <span class="comment">//二分插入排序                    </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">                {</span><br><span class="line">                        t = a[i];</span><br><span class="line">                        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> right = i<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">                        {</span><br><span class="line">                                <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                                <span class="keyword">if</span>(t&lt;a[mid])</span><br><span class="line">                                {</span><br><span class="line">                                        right = mid<span class="number">-1</span>;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                {</span><br><span class="line">                                        left = mid+<span class="number">1</span>;</span><br><span class="line">                                }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=left;j--)</span><br><span class="line">                        {</span><br><span class="line">                                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">                        }</span><br><span class="line">                        a[left] = t;</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">}   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2019/02/13/shell-sort/</url>
    <content><![CDATA[<p>希尔排序，实质是分组插入排序。  </p>
<span id="more"></span>


<p>代码有点难懂，需要手动演算才更好理解。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; a[j + gap]; j -= gap)</span><br><span class="line">                        {</span><br><span class="line">                                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                                a[j] = a[j+gap];</span><br><span class="line">                                a[j+gap] = temp;</span><br><span class="line">                        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://www.itcodemonkey.com/article/3286.html">图解希尔排序</a>  </li>
<li><a href="https://blog.csdn.net/MoreWindows/article/details/6668714">白话经典算法系列之三 希尔排序的实现</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Panel的几个概念</title>
    <url>/2019/02/12/panel/</url>
    <content><![CDATA[<p>Panel的几个概念。  </p>
<span id="more"></span>


<h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><ul>
<li><p>FRC(free run)  </p>
<ul>
<li>特性：Display输出frame rate不需跟input video frame rate同步。  </li>
<li>应用：Input video frame rate太低或太高，panel无法支援frame rate，panel在某些应用下需强制输出固定frame rate给TCON。  </li>
</ul>
</li>
<li><p>Frame Sync<br>什么是Frame Sync？<br>狭义的说：让Output V sync freq与Input V sync freq相同。<br>例如：Input V Freq 60Hz，Output V Freq也等于60Hz。<br>广义的说：让Output V sync freq与Input V sync freq保持一定比例关系。<br>例如：Input V Freq 60Hz，Output V Freq等于120Hz。  </p>
</li>
</ul>
<p>为保证输入和输出的场频相同就要满足DCLK/(Htotal×Vtotal) = 采样时钟频率/(输入Htotal×输入Vtotal)，为满足这一公式，DCLK、Htotal、Vtotal会在屏可接收的范围内进行调整。不同的芯片会采用不同的LOCK方法，因此计算方法会不同，只有去看程序才能明白是怎么计算的。</p>
<pre><code>- 特性：output frame rate刚好是input frame rate的1倍或2倍。例如：Input V Freq 60Hz,Output V Freq也等于60Hz；Input V Freq 60Hz，Output V Freq等于120Hz。  
- 应用：确保输出画面跟输入信号一样流畅。  
- 控制：确保display不会有掉frame或是出现不规律的frame repeat现象。  
</code></pre>
<ul>
<li><p>Frame PLL Mode  </p>
<ul>
<li>运作方式：固定住Output H total and V total, 然后IC会自动调整(微调)Output clock來使得Output V Freq接近Input V Freq。  </li>
<li>优点：固定Vtt、Htt，不会有short frame/line的问题；可以做FRC。  </li>
<li>缺点：需要较长的时间来完成frame sync；会受到clock范围的限制。  </li>
</ul>
</li>
<li><p>Frame Lock  </p>
<ul>
<li>frame lock是固定Dclk，当input reference信号来时，将Output 的timing generator reset掉，借由这个动作到达input和output一张frame的时间一样长。  </li>
<li>优点：frame sync速度快，一张frame就sync住。  </li>
<li>缺点：因为是用input的reference信号（可预期不可control）来clear timing generator，在reset时有可能不是一张完整的frame或者line，会有short frame和short line的情况，因此：<br>  1，有些panel没办法接收这种timing，画面会闪；<br>  2，当reset点不是在Blanking区间，换timing， OSD会破掉；<br>  3，因为是每一张frame都reset，所以没办法做FRC。  </li>
</ul>
</li>
</ul>
<p><a href="https://www.doc88.com/p-6911746171453.html">FrameLock(FrameSync)</a>  </p>
<h2 id="Frame-Sync"><a href="#Frame-Sync" class="headerlink" title="Frame Sync"></a>Frame Sync</h2><p>目前常用的Frame Sync有以下两种方式：Frame PLL Mode、Frame Lock。  </p>
<h2 id="RDA-Frame-Sync-方法"><a href="#RDA-Frame-Sync-方法" class="headerlink" title="RDA Frame Sync 方法"></a>RDA Frame Sync 方法</h2><p><img src="https://i.loli.net/2019/02/12/5c6293a433a9d.jpg" alt="rda calc frame sync.jpg">  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>同一版软件在V320BJ6_Q01这款屏上测试正常，在V320BJ8_Q01这款屏上测试任意信号都有随机抖动的问题。两款屏的Timing Spec一样。调试思路是调整输出Clock值。尝试微调Vtotal无法改善，放弃，然后尝试关展频，测试5台机器2小时再也没有抖动的问题，但是另外一个抖动频率较高的机器仍发现有抖动情况，读寄存器发现在60Hz信号下吃的却是50Hz的Vtotal，于是修改屏参强制60Hz输出，测试未见异常。由于客户不做EMI，所以此题改法是关闭展频，至于60Hz信号为什么会吃50Hz值，暂时没有结论。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://wenku.baidu.com/view/61565e78e009581b6bd9eba1.html">FPLL实际应用介绍</a>  </li>
<li><a href="https://blog.csdn.net/jxgz_leo/article/details/52225462">用于降低EMI的时钟展频技术</a>  </li>
<li><a href="https://www.onsemi.cn/pub/Collateral/AND9015-D.PDF">ON Semiconductor</a>  </li>
<li><a href="https://www.cypress.com/file/106246/download">Cypress Semiconductor</a>  </li>
<li><a href="https://blog.csdn.net/cswuhsdaz/article/details/91471437">分辨率的Clock和屏的Clock</a></li>
</ol>
<hr>
<h2 id="色彩分辨率"><a href="#色彩分辨率" class="headerlink" title="色彩分辨率"></a>色彩分辨率</h2><p>色彩分辨装是指显示屏能显示的颜色深度，一般以位数来描述，如：10Bit、8Bit、6Bit。而规格书有时也会以可显示的颜色数量来描述，如16.7M。颜色数量和位数的关系是：颜色数量=2<sup>bits</sup>*2<sup>bits</sup>*2<sup>bits</sup>。以8Bit的显示屏为例，可显示的颜色数量为Display Colors=2<sup>8</sup>*2<sup>8</sup>*2<sup>8</sup>=16777216(16.7M)。颜色位数的设定会影响显示屏对画面细节部分的显示.设定不当时会出现画面细节模糊或屏幕亮度变低。  </p>
<h2 id="LVDS数据格式"><a href="#LVDS数据格式" class="headerlink" title="LVDS数据格式"></a>LVDS数据格式</h2><p>两种LVDS数据格式：JEIDA和VESA。具体使用哪种格式是由屏的SELLVDS这个脚决定的。<br><img src="https://i.loli.net/2019/12/26/PI2hvFEfDxVOC6k.jpg" alt="SELLVDS.jpg">  </p>
<h2 id="Timing参数"><a href="#Timing参数" class="headerlink" title="Timing参数"></a>Timing参数</h2><p>需要关注的参数：DCLK、行场Total、行场Blank，电视机工作时，DCLK是根据信号的频率而变化的，DCLK = HTotal x VTotal x 信号频率。<br>有的Panel会详细细分60Hz和50Hz，一般Dclk = HTotal*VTotal*60，所以当只给出了60Hz的VTotal时，可以算出50Hz的VTotal=1.2*60Hz的VTotal。<br><img src="https://i.loli.net/2019/12/26/9QufyMh3Xltq1p4.jpg" alt="Timing.jpg"><br><img src="https://i.loli.net/2019/12/26/O8qiB9NjzYokQXA.jpg" alt="Timing组成.jpg"><br>Total = Display + Blank;<br>Blank = Sync + 后肩 + 前肩;<br><img src="https://i.loli.net/2019/12/27/gi5IajhkrPCyZfV.jpg" alt="aframe.jpg"><br><a href="https://www.cnblogs.com/sky-heaven/p/9040817.html">LCD时序中设计到的VSPW/VBPD/VFPD/HSPW/HBPD/HFPD总结【转】</a>  </p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p>时序需要参考屏规格书具体调整。一般来说：<br>开机顺序：先开Panel，再开LVDS，最后开Backlight；<br>关机顺序：先关Backlight，再关LVDS，最后关Panel。  </p>
<h2 id="LVDS驱动电流"><a href="#LVDS驱动电流" class="headerlink" title="LVDS驱动电流"></a>LVDS驱动电流</h2><p>因LVDS接口实际是差分信号接口,调整差分信号的电流会影响LVDS信号输出的幅度。不同的屏因为匹配阻抗略有差异，同样的驱动电流，LVDS输出的幅度也不一样。当LVDS的输出幅度过大或过小时，画面会出现黑屏等现象。<br><img src="https://i.loli.net/2019/12/26/Et3ucUeBDQ8sPyW.jpg" alt="LVDS Interface.jpg"><br><img src="https://i.loli.net/2019/12/26/8SeMj2lmYTq4sax.jpg" alt="LVDS Input Characteristics.jpg"><br><a href="https://blog.csdn.net/github_33678609/article/details/53435286">LVDS协议及原理分析</a>  </p>
<h2 id="眼图"><a href="#眼图" class="headerlink" title="眼图"></a>眼图</h2><p>眼图：一系列数字信号叠加在一起而形成的，因为数字信号有高低电平的变化。  </p>
<p><code>眼高</code>越高，这个信号越好，两条红色横线是VIH与VIL。左边、右边箭头是信号01转换的时刻，这两个箭头越宽，说明越接近原信号的建立时间，保持时间。这两个箭头越小，说明信号不完整，产生反射、干扰等。<br>数字信号在采样前后，需要一定的建立时间和保持时间，数字信号在这一段时间内应保持稳定，才能保证正确采样。而对于电平的判决，需要高电平的电压值高于输入高电平VIH，低电平的电压值低于输入低电平VIL。  </p>
<p><code>眼宽</code>：当信号很多叠加在一起时，这个眼宽就很好地反映了这个信号的稳定时间。  </p>
<h2 id="常见问题及解法思路"><a href="#常见问题及解法思路" class="headerlink" title="常见问题及解法思路"></a>常见问题及解法思路</h2><h4 id="画面闪线或抖动"><a href="#画面闪线或抖动" class="headerlink" title="画面闪线或抖动"></a>画面闪线或抖动</h4><p>屏画面闪亮线一般会出现在电视开机过程中或TV 转台瞬间，原因有多种，最常见的是DCLK设定超出屏可支持的范围。另外一个原因是DCLK 锁定的速度太快，以致屏接受不了这种改变而出现亮线。  </p>
<h4 id="画面水印严重"><a href="#画面水印严重" class="headerlink" title="画面水印严重"></a>画面水印严重</h4><p>画面水印多数是因为屏对图像数据颜色深度处理不足，以致非常相近颜色都被认是同一种颜色，在画面上出现色块，在过渡色画面较容易出现。对于水印的处理，除了屏供应商修改T-con软件外，机芯软件一般可通过调整Gamma曲线的顶端来降低水印。具体的做法是把Gamma的最大值减少。除了屏本身的原因外，软件PQ的设定有时也会产生水印，例如调整画质时把个别颜色的增益设定过大，再经过白平衡调整，处理后的颜色已提前进入饱和，从而出现水印。  </p>
<h4 id="移动画面及水平移动字幕出现停顿"><a href="#移动画面及水平移动字幕出现停顿" class="headerlink" title="移动画面及水平移动字幕出现停顿"></a>移动画面及水平移动字幕出现停顿</h4><p>移动画面不流畅在排除了画面本身的问题外，DCLK与信号未实现同步是主要原因。如V-Total、H-Total参数设定不正确，使得DCLK超出了同步范围。  </p>
<h4 id="屏工作一段时间后出现黑屏"><a href="#屏工作一段时间后出现黑屏" class="headerlink" title="屏工作一段时间后出现黑屏"></a>屏工作一段时间后出现黑屏</h4><p>一种情况表现为电视有声音无图像，背光也不亮。问题的原因之一是背光PWM占空比最小值设定过小，从而使背光模块进入保护状态。还有一个原因就是前面提到个别屏的Dimming信号在屏背光启动时需要保持100%占空比一段时间来激发背光灯管，如果背光启动时，Dimming信号的占空比是用户设定值，而且占空比较小，背光灯管就有可能不能正常启动。另一种情况是有声音无图像但背光是亮的。这种情况的原因之一是展频设置不当，个别屏的展频幅度超过2%时就会出现黑屏现象，所以软件设置的展频幅度一般在1.4%~2%之间。  </p>
<h4 id="背光不受控"><a href="#背光不受控" class="headerlink" title="背光不受控"></a>背光不受控</h4><p>该问题的表现为调整背光时屏幕亮度变化很少或不变化，排除硬件原因，最可能的原因是PWM频率设置不正确。如，屏的PWM频率范围是140~160Hz，如果设定的PWM频率在这个范围外，那就有可能出现这样的问题。  </p>
<h4 id="屏幕有滚动细横纹"><a href="#屏幕有滚动细横纹" class="headerlink" title="屏幕有滚动细横纹"></a>屏幕有滚动细横纹</h4><p>这种现象在纯颜色的画面下较容易观察到。而引起该问题的原因多数是展频的频率设置不正确，可以调整展频的频率看现象是否有改善。如果调整展频的频率没有改善，可以关掉展频功能来进一步确认。  </p>
<h4 id="画面闪彩点"><a href="#画面闪彩点" class="headerlink" title="画面闪彩点"></a>画面闪彩点</h4><p>该问题表现为图像及UI都会闪点，引起该问题的原因多数是LVDS信号的眼图不良。  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>panel</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/02/14/merge-sort/</url>
    <content><![CDATA[<p>归并排序，是指将两个有序序列合并成一个有序序列的操作。两个有序序列如何获得？通过从上到下递归分解序列，当元素为1时就是有序序列。接着从下到上合并序列，最后得到一个有序序列。  </p>
<span id="more"></span>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arrays</span></span><br><span class="line"><span class="comment"> * @param L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * @param M      指向数组分隔的元素</span></span><br><span class="line"><span class="comment"> * @param R      指向数组最后的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arrays[], <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lengthLeft = M - L;</span><br><span class="line">	<span class="keyword">int</span> lengthRight = R - M + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左边的数组的大小</span></span><br><span class="line">	<span class="keyword">int</span> leftArray[lengthLeft];</span><br><span class="line">	<span class="built_in">memset</span>(leftArray,<span class="number">0</span>,lengthLeft*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//右边的数组大小</span></span><br><span class="line">	<span class="keyword">int</span> rightArray[lengthRight];</span><br><span class="line">	<span class="built_in">memset</span>(rightArray,<span class="number">0</span>,lengthRight*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往这两个数组填充数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) {</span><br><span class="line">		leftArray[i - L] = arrays[i];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) {</span><br><span class="line">		rightArray[i - M] = arrays[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//arrays数组的第一个元素</span></span><br><span class="line">	<span class="keyword">int</span> k = L;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; lengthLeft &amp;&amp; j &lt; lengthRight) {</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">		<span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) {</span><br><span class="line">			arrays[k++] = leftArray[i++];</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			arrays[k++] = rightArray[j++];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; lengthLeft) {</span><br><span class="line">		arrays[k++] = leftArray[i++];</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt; lengthRight) {</span><br><span class="line">		arrays[k++] = rightArray[j++];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param arrays</span></span><br><span class="line"><span class="comment"> * @param L      指向数组第一个元素</span></span><br><span class="line"><span class="comment"> * @param R      指向数组最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arrays[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">	<span class="keyword">if</span> (L == R) {</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">		<span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">		mergeSort(arrays, L, M);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">		mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//合并</span></span><br><span class="line">		merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">	mergeSort(a,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">	{   </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">	}   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://juejin.im/post/5ab4c7566fb9a028cb2d9126">归并排序就这么简单</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2019/02/15/search/</url>
    <content><![CDATA[<p>查找算法。<br><img src="https://i.loli.net/2019/02/15/5c663799023fb.png">  </p>
<span id="more"></span>


<p>例程如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinearSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 线性查找，一般当序列无序时使用</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(a[i] == keyValue)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 折半查找，适用于有序序列</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> M = (L+R)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[M] &gt; keyValue)</span><br><span class="line">			R = M - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[M] &lt; keyValue)</span><br><span class="line">			L = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> M;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OMGSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 插值查找，适用于元素分布均匀的有序序列，因其按照线性比例来确定M值</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// M值根据如下数学方程获得：</span></span><br><span class="line">		<span class="comment">// (keyValue - a[L]) : (M - L) = (a[R] - a[L]) : (R - L)</span></span><br><span class="line">		<span class="keyword">int</span> M = (keyValue - a[L]) * (R - L) / (a[R] - a[L]) + L;</span><br><span class="line">		<span class="keyword">if</span>(a[M] &gt; keyValue)</span><br><span class="line">			R = M - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[M] &lt; keyValue)</span><br><span class="line">			L = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> M;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size = <span class="number">20</span>; <span class="comment">// 斐波那契数组的长度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> F[])</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">	<span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">	F[<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max_size; i++)  </span><br><span class="line">		F[i] = F[i<span class="number">-1</span>] + F[i<span class="number">-2</span>];  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> keyValue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 斐波那契查找</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">int</span> R = length - <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> F[max_size];  </span><br><span class="line">	Fibonacci(F); <span class="comment">// 构造一个斐波那契数组F   </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span>(length &gt; F[k]) <span class="comment">// 计算length位于斐波那契数列的位置  </span></span><br><span class="line">		k++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp[F[k]<span class="number">-1</span>]; <span class="comment">// 将数组a扩展到F[k]-1的长度  </span></span><br><span class="line">	<span class="built_in">memcpy</span>(temp,a,length*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &lt; F[k]<span class="number">-1</span>; i++)  </span><br><span class="line">		temp[i] = a[length<span class="number">-1</span>];  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R)  </span><br><span class="line">	{  </span><br><span class="line">		<span class="keyword">int</span> M = L + F[k<span class="number">-1</span>] - <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span>(keyValue &lt; temp[M])  </span><br><span class="line">		{  </span><br><span class="line">			R = M - <span class="number">1</span>;  </span><br><span class="line">			k -= <span class="number">1</span>;  </span><br><span class="line">		}  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(keyValue &gt; temp[M])  </span><br><span class="line">		{  </span><br><span class="line">			L = M + <span class="number">1</span>;  </span><br><span class="line">			k -= <span class="number">2</span>;  </span><br><span class="line">		}  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">		{  </span><br><span class="line">			<span class="keyword">if</span>(M &lt; length)  </span><br><span class="line">				<span class="keyword">return</span> M; <span class="comment">// 若相等则说明M即为查找到的位置  </span></span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				<span class="keyword">return</span> length<span class="number">-1</span>; <span class="comment">// 若M&gt;=length则说明是扩展的数值,返回length-1  </span></span><br><span class="line">		}  </span><br><span class="line">	}    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="number">100</span>};</span><br><span class="line">	<span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> keyValue = <span class="number">25</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"LinearSearch Result: %d at %d\n"</span>,keyValue,LinearSearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"BinarySearch Result: %d at %d\n"</span>,keyValue,BinarySearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"OMGSearch Result: %d at %d\n"</span>,keyValue,OMGSearch(a,length,keyValue));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FibonacciSearch Result: %d at %d\n"</span>,keyValue,FibonacciSearch(a,length,keyValue));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title>callback function in c example</title>
    <url>/2019/03/16/callback/</url>
    <content><![CDATA[<p>网上查到的很好的解释：    </p>
<blockquote>
<p>回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后把这个函数（入口地址）作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。  </p>
</blockquote>
<span id="more"></span>


<p>至少在应用之间异步消息传递、驱动层与应用层之间的通信上有奇效。代码中很多模块的实现都使用回调做法（代码写得还真绕，看了好一会<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），后来在添加Uart/IR工厂自动化测试，单键通过按键面板实现7键功能上也参考了。<br>思路是先实现回调函数功能，然后把回调函数赋给一个函数指针（注册回调函数），最后使用这个函数指针即可。例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*callbackFunc)</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">callbackFunc pCallbackFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerCallbackFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	pCallbackFunc = &amp;add;</span><br><span class="line">	<span class="comment">//pCallbackFunc = add; //ok</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">	registerCallbackFunc();</span><br><span class="line">	c = (*pCallbackFunc)(a,b);</span><br><span class="line">	<span class="comment">//c = pCallbackFunc(a,b); //ok</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c = %d\n"</span>,c);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://www.geeksforgeeks.org/callbacks-in-c/">Callbacks in C</a>  </li>
<li><a href="https://stackoverflow.com/questions/142789/what-is-a-callback-in-c-and-how-are-they-implemented">What is a “callback” in C and how are they implemented?</a>  </li>
<li><a href="https://segmentfault.com/a/1190000008293902">一文搞懂C语言回调函数</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2019/02/16/hanoi-tower/</url>
    <content><![CDATA[<p>递归实现汉诺塔问题。  </p>
<span id="more"></span>


<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveOne</span><span class="params">(<span class="keyword">int</span> diskNum, <span class="keyword">char</span> init, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"move disk %d from %c to %c\n"</span>,diskNum,init,dest);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> diskNum, <span class="keyword">char</span> init, <span class="keyword">char</span> temp, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(diskNum == <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		moveOne(diskNum, init, dest);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		move(diskNum<span class="number">-1</span>, init, dest, temp);</span><br><span class="line">		moveOne(diskNum, init, dest);</span><br><span class="line">		move(diskNum<span class="number">-1</span>, temp, init, dest);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	move(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出如下：  </p>
<blockquote>
<p>move disk 1 from A to C<br>move disk 2 from A to B<br>move disk 1 from C to B<br>move disk 3 from A to C<br>move disk 1 from B to A<br>move disk 2 from B to C<br>move disk 1 from A to C  </p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>hanoi</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口回调</title>
    <url>/2019/03/18/callback-2/</url>
    <content><![CDATA[<blockquote>
<p>Android中的回调，遵循的基本思想是Java中的回调函数。<br>回调函数就是一个通过函数指针调用的函数。如果你的函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的时间或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<br>Java中没有指针的概念，通过接口和内部类的方式实现回调的功能。  </p>
</blockquote>
<span id="more"></span>


<p>举个栗子，有以下几个文件：  </p>
<p>文件Interface.java，接口定义类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件App.java，接口的实现类1：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"impl: printf"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件App2.java，接口的实现类2：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App2</span> <span class="keyword">implements</span> <span class="title">Interface</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iPrintf</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"impl: printf 2"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件Sys.java，调用回调函数的类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sys</span> </span>{</span><br><span class="line">	<span class="comment">//定义回调接口的成员变量</span></span><br><span class="line">	<span class="keyword">private</span> Interface mInterface;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置回调接口对象成员变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Interface mInterface)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.mInterface = mInterface;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用回调接口对象中的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCallback</span><span class="params">()</span> </span>{</span><br><span class="line">		mInterface.iPrintf();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>文件Test.java，测试类：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">		Sys mSys = <span class="keyword">new</span> Sys();</span><br><span class="line">		App mApp = <span class="keyword">new</span> App();</span><br><span class="line">		App2 mApp2 = <span class="keyword">new</span> App2();</span><br><span class="line">		mSys.setCallback(mApp); <span class="comment">//通过形参传递接口的实现类的对象的引用</span></span><br><span class="line">		mSys.doCallback();</span><br><span class="line">		mSys.setCallback(mApp2); <span class="comment">//通过形参传递接口的实现类的对象的引用</span></span><br><span class="line">		mSys.doCallback();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://blog.csdn.net/linshijun33/article/details/48183925">Android接口回调，最简单的理解方式</a>  </li>
<li><a href="https://www.imooc.com/article/20224">Android 回调方法的实现</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>callback</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>[转载]Android System Server大纲之LightsService</title>
    <url>/2019/03/19/lights-service/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从功能机以来，手机等设备就配备了Led闪光灯，当有未接电话、未读短信和通知等等，Led就会闪烁。和振动器类似，都是给用户一种人机交互的反馈，哪怕这种人机交互是那么的简单。既然它是一个Led，也就是一个硬件，Android系统上层驱动这个硬件的服务就是LightsService，所以，这个文章也是描述一个软硬件结合的功能。但是上层APP不能直接驱动Led硬件，LightsService是系统所使用。    </p>
<span id="more"></span>


<p>既然是软硬结合的一个功能，那么在Android系统里，从上到下实现这个功能的架构如下：<br><img src="https://i.loli.net/2019/03/19/5c90af777f197.png" alt="FamilyYuan.png">  </p>
<h2 id="LightsService初始化"><a href="#LightsService初始化" class="headerlink" title="LightsService初始化"></a>LightsService初始化</h2><p>回顾《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文，LightsService在frameworks/base/services/java/com/android/server/SystemServer.java中的启动过程是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>{</span><br><span class="line">        <span class="comment">// Manages LEDs and display backlight so we need it to bring up the display.</span></span><br><span class="line">        mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的代码中，LightsService是通过SystemServiceManager.startService()的方式启动，在《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文中提到的Android系统的各种服务的启动方式可知，LightsService是继承了SystemService，LightsService启动后会回调onStart()方法。代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{</span><br><span class="line">        publishLocalService(LightsManager.class, mService);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码在frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。<br>在《<a href="https://blog.csdn.net/myfriend0/article/details/55098173">Android系统之System Server大纲</a>》一文中提到，publishLocalService()的作用，这里是把mService推进LocalServices中，所以外部引用LightsService时，实际是拿到mService这个对象。mService的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LightsManager mService = <span class="keyword">new</span> LightsManager() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Light <span class="title">getLight</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (id &lt; LIGHT_ID_COUNT) {</span><br><span class="line">                <span class="keyword">return</span> mLights[id];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>mService的实质是一个LightsManager，LightsManager只提供一个方法getLight(int id)，从数组mLights中匹配一个返回值，返回值是什么类型呢？看mLights[]的本质，如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LightImpl mLights[] = <span class="keyword">new</span> LightImpl[LightsManager.LIGHT_ID_COUNT];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>mLights[]的实质一个LightImpl的数组，所以LightsManager的getLight(int id)返回的是一个LightImpl的实例，LightImpl的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span> </span>{</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">                setLightLocked(color, mode, onMS, offMS, BRIGHTNESS_MODE_USER);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>LightImpl实际是Light的子类，而Light实质是一个led硬件的抽象，那么一个led就被抽象成一个Light对象。因此，要控制led，只要拿到led的抽象对象Light即可实现驱动led。  </p>
<p>回头再看看LightsService的初始化，LightsService的构造方法如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightsService</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">        mNativePointer = init_native();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LightsManager.LIGHT_ID_COUNT; i++) {</span><br><span class="line">            mLights[i] = <span class="keyword">new</span> LightImpl(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上文提到的LightImpl数组mLights就是在LightsService中被初始化了，这里会根据LightsManager.LIGHT_ID_COUNT的总数循环生成LightImpl的实例保存在mLights数组中。这里的LightsManager.LIGHT_ID_COUNT的值是8，代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LightsManager</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BACKLIGHT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_KEYBOARD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BUTTONS = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BATTERY = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_NOTIFICATIONS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_ATTENTION = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_BLUETOOTH = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_WIFI = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_ID_COUNT = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Light <span class="title">getLight</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从LIGHT_ID_BACKLIGHT到LIGHT_ID_WIFI共8个，这里是否表示8个led呢，后文在论述清楚。回到LightsService的构造方法，调用了init_native()方法，当然，熟悉Android架构的都清楚，其它硬件的服务和LightsService一样，都有这么一个过程。目的就是LightsService启动时，调用init_native()初始化硬件，也就是软硬件的通道在init_native()这个方法中打通。init_native()是一个native方法，对应的JNI接口是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">init_native</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>, jobject <span class="comment">/* clazz */</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    hw_module_t* <span class="keyword">module</span>;</span><br><span class="line">    Devices* devices;</span><br><span class="line"></span><br><span class="line">    devices = (Devices*)malloc(sizeof(Devices));</span><br><span class="line"></span><br><span class="line">    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t <span class="keyword">const</span>**)&amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        ......</span><br><span class="line">        devices-&gt;lights[LIGHT_INDEX_NOTIFICATIONS]</span><br><span class="line">                = get_device(<span class="keyword">module</span>, LIGHT_ID_NOTIFICATIONS);</span><br><span class="line">        ......</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        memset(devices, <span class="number">0</span>, sizeof(Devices));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (jlong)devices;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数定义在文件frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp中。  </p>
<p>init_native()中首先调用了hw_get_module()函数，这个函数就是打开硬件设备，这个是函数的实现过程在hardware/libhardware/hardware.c中，对Android HAL熟悉的读者，应该很熟悉这个过程，本文也不往下赘述这个过程了。然后通过调用get_device()函数取得返回值赋值Devices的变量lights，get_device()的一个参数是LIGHT_ID_NOTIFICATIONS，这和上文中LightsManager的8个led id是对应的。Devices的变量lights的实质是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">struct Devices {</span><br><span class="line">    light_device_t* lights[LIGHT_COUNT];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>light_device_t定义在hardware/libhardware/include/hardware/lights.h文件中。回到init_native()函数，接着看get_device()这个函数：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> light_device_t* get_device(hw_module_t* <span class="keyword">module</span>, <span class="keyword">char</span> <span class="keyword">const</span>* name)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    hw_device_t* device;</span><br><span class="line">    err = <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, name, &amp;device);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> (light_device_t*)device;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过module-&gt;methods-&gt;open()打开硬件设备，这个过程本文就不再赘述了。打开设备通道后，取得light_device_t，保存在Devices的数组lights中，这和LightsService上文中的LightImpl的数组mLights也是对应的关系。  </p>
<h2 id="通过LightsService启动Led"><a href="#通过LightsService启动Led" class="headerlink" title="通过LightsService启动Led"></a>通过LightsService启动Led</h2><p>APP虽然不能直接驱动led，但是led一般也是为Android的Notification所使用，所以APP发起一个通知，led也会闪烁。本文就从Android的notification入手，分析驱动led的过程。  </p>
<p>APP创建Notification时，可以通过如下方法指定这个notification需要led：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setLights</span><span class="params">(<span class="meta">@ColorInt</span> <span class="keyword">int</span> argb, <span class="keyword">int</span> onMs, <span class="keyword">int</span> offMs)</span> </span>{</span><br><span class="line">    mN.ledARGB = argb;</span><br><span class="line">    mN.ledOnMS = onMs;</span><br><span class="line">    mN.ledOffMS = offMs;</span><br><span class="line">    <span class="keyword">if</span> (onMs != <span class="number">0</span> || offMs != <span class="number">0</span>) {</span><br><span class="line">        mN.flags |= FLAG_SHOW_LIGHTS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本文暂时不对这个方法进行过多的阐述，会在以后的文章中再详细介绍Android的notification机制。当然APP如果不调用这个方法，那么Android系统会自动为APP的notification选取默认值。  </p>
<p>APP的notification通知到Android系统以后，就会驱动led闪烁起来。在上文LightsService的初始化中提到，led硬件已经抽象成一个Light对象，这个对象便是LightImpl，获取到LightImpl的实例，便可驱动led。Android的notification获取LightImpl的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationManagerService</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> LightsManager lights = getLocalService(LightsManager.class);</span><br><span class="line">    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个类定义在文件frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java中。  </p>
<p>在上文LightsService的初始化中可知，LightsService被推进到LocalService中，所以是通过getLocalService()获取到LightsManager，然后再通过getLight()方法，获取到LightImpl的实例，这个过程在上文LightsService的初始化中已经阐述的很明白。获取到了LightImpl，通过什么接口驱动led呢？先看看LightImpl的结构：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setBrightness</span><span class="params">(<span class="keyword">int</span> brightness)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setBrightness</span><span class="params">(<span class="keyword">int</span> brightness, <span class="keyword">int</span> brightnessMode)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pulse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pulse</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> onMS)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个类定义在文件frameworks/base/services/core/java/com/android/server/lights/Light.java中。  </p>
<p>如上面的代码，LightImpl提供setBrightness()设置亮度、setColor设置颜色、setFlashing启动led等7个方法。因此，Anroid notification驱动led的代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mNotificationLight.setFlashing(ledARGB, Light.LIGHT_FLASH_TIMED,ledOnMS, ledOffMS);</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java中。<br>setFlashing()接收四个参数，第一个当然是颜色，类型是rgb；第二参数是mode，数值分别是可以是：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_NONE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_TIMED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIGHT_FLASH_HARDWARE = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这些变量定义在文件frameworks/base/services/core/java/com/android/server/lights/Light.java中。<br>第三个和第四个是一对相反的参数，分别表示led闪烁时亮的时间，led闪烁时灭的时间。接着看setFlashing()的实现：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlashing</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">            setLightLocked(color, mode, onMS, offMS, BRIGHTNESS_MODE_USER);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。<br>直接调用了setLightLocked()，代码如下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LightImpl</span> <span class="keyword">extends</span> <span class="title">Light</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLightLocked</span><span class="params">(<span class="keyword">int</span> color, <span class="keyword">int</span> mode, <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS, <span class="keyword">int</span> brightnessMode)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!mLocked &amp;&amp; (color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS ||</span><br><span class="line">            mBrightnessMode != brightnessMode)) {</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"setLight #"</span> + mId + <span class="string">": color=#"</span></span><br><span class="line">                + Integer.toHexString(color) + <span class="string">": brightnessMode="</span> + brightnessMode);</span><br><span class="line">        mLastColor = mColor;</span><br><span class="line">        mColor = color;</span><br><span class="line">        mMode = mode;</span><br><span class="line">        mOnMS = onMS;</span><br><span class="line">        mOffMS = offMS;</span><br><span class="line">        mLastBrightnessMode = mBrightnessMode;</span><br><span class="line">        mBrightnessMode = brightnessMode;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_POWER, <span class="string">"setLight("</span> + mId + <span class="string">", 0x"</span></span><br><span class="line">                + Integer.toHexString(color) + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法定义在文件frameworks/base/services/core/java/com/android/server/lights/LightsService.java中。  </p>
<p>对参数整理一遍后，调用了JNI方法setLight_native()，这里的第二个参数便是LightsManager.LIGHT_ID_NOTIFICATIONS = 4；继续往下看setLight_native()：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>, jobject <span class="comment">/* clazz */</span>, jlong ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint light, jint colorARGB, jint flashMode, jint onMS, jint offMS, jint brightnessMode)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Devices* devices = (Devices*)ptr;</span><br><span class="line">    <span class="keyword">light_state_t</span> state;</span><br><span class="line">    ......</span><br><span class="line">    state.brightnessMode = brightnessMode;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">ALOGD_IF_SLOW</span>(<span class="number">50</span>, <span class="string">"Excessive delay setting light"</span>);</span><br><span class="line">        devices-&gt;lights[light]-&gt;<span class="built_in">set_light</span>(devices-&gt;lights[light], &amp;state);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数定义在文件frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp中。  </p>
<p>set_light()的定义是在文件hardware/libhardware/include/hardware/lights.h中，具体实现，就因led的硬件厂商不同而不同了，这里以某个led的厂商为例：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_lights</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">char</span> <span class="keyword">const</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">               struct <span class="keyword">hw_device_t</span> **device)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dragon_lights</span> *<span class="title">lights</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    lights-&gt;base.set_light = set_light_backlight;</span><br><span class="line"></span><br><span class="line">    *device = (struct <span class="keyword">hw_device_t</span> *)lights;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在led通道初始化过程中，set_light()函数实际调用的是set_light_backlight函数，set_light_backlight函数如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_light_backlight</span><span class="params">(struct <span class="keyword">light_device_t</span> *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct <span class="keyword">light_state_t</span> <span class="keyword">const</span> *state)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dragon_lights</span> *<span class="title">lights</span> =</span> <span class="built_in">to_dragon_lights</span>(dev);</span><br><span class="line">    <span class="keyword">int</span> err, brightness_idx;</span><br><span class="line">    <span class="keyword">int</span> brightness = <span class="built_in">rgb_to_brightness</span>(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (brightness &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Get the bin number for brightness (0 to kNumBrightnessLevels - 1)</span></span><br><span class="line">        brightness_idx = (brightness - <span class="number">1</span>) * kNumBrightnessLevels / <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get brightness level</span></span><br><span class="line">        brightness = kBrightnessLevels[brightness_idx];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lights-&gt;lock);</span><br><span class="line">    err = <span class="built_in">write_brightness</span>(lights, brightness);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lights-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>跟踪到这里，本文也就不往下跟踪了，这些代码都会因led厂商不同而不同。驱动led的过程就到此结束。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文阐述了LightsService的作用，从打开硬件通道和驱动硬件led闪烁起来的过程，虽然APP是不可以直接驱动led，但是led几乎都是为android notification所用，所以，APP发布的notification也可以使用led，通知用户有新的状态。对于上文提到的led颜色，对于很多设备，是不支持设置颜色了的，设置了也只能是一种颜色，所以在这些设备上，可以说是大多数设备，这个功能基本就没有任何用处。另外，因led硬件的不同，文章中提到的8个led id，可能有，可能没有。  </p>
<hr>
<ol>
<li><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://blog.csdn.net/myfriend0/article/details/56482594">原文链接</a>  </li>
<li>网上另外一篇不错的文章：<a href="https://blog.csdn.net/zhangchiytu/article/details/7958513">lights从上到下的流程</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用</title>
    <url>/2019/05/10/git/</url>
    <content><![CDATA[<p>速查。  </p>
<span id="more"></span>


<h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><ul>
<li><p>把文件修改添加到暂存区：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>提交修改，把暂存区的内容提交到当前分支：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>下载远程分支<code>rtk_base</code>的代码，并把根文件夹命名为<code>rtk_code_base</code>：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b rtk_base http://123.45.6.78:9999/Hlkffm_Bndroid/2951_hlkffm_0402.git rtk_code_base </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>单行显示git记录，包括版本号和commit log：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>显示1个commit：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br></pre></td></tr></tbody></table></figure>
<p>  如果想显示5个，就-5，不指定的话，会从该commit一直往后显示</p>
</li>
<li><p>查看一段时间区间的提交信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --since=<span class="string">"2019-11-18 00:00:00"</span> --until=<span class="string">"2019-12-01 00:00:00"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看具体某一个版本，包括修改的作者、时间、文件等，以及“shows number of added and deleted lines”：    </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git show 7f7c809c1f537a3ffff57667d41424e1cff8cad1 --numstat</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某行代码提交记录：  </p>
<p>  查看index.js文件中第38行的提交修改记录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git blame -L 38,38 src/component/BarCode/index.js</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看某个文件中某个函数的提交记录：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -L :FunctionName:FilePath</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查找某个字符串的提交记录：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -S <span class="string">"Hello,World!"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看单个文件的历史修改记录：  </p>
<p>  首先切换到要查看的文件所在的目录  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie/vendor/realtek/app/HKMediaBrowser/app/src/main/java/com/hk/mediabrowser/activity/</span><br></pre></td></tr></tbody></table></figure>

<p>  列出文件的所有改动历史  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure>

<p>  显示该文件每次提交的diff  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure>

<p>  查看某个提交中的某个文件的变化  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git show 4a771319a90dad7d654dbd7ece50cd9add0fef30 PhotoPlayerActivity.java</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>HEAD指向的版本就是当前版本，在版本的历史之间切换：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在两个版本之间创建Diff：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff [旧版本 Commit ID] [新版本 Commit ID] &gt; [Diff文件名]</span><br></pre></td></tr></tbody></table></figure>
<p>  eg:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff 5af260f2e3974e0d043a42f397b2d9165e6b4d3f e4c3cbd7700e5230e6b053cf3e231bced23f4edc &gt; patch.diff</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>应用Diff：  </p>
<p>  检查Diff文件  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply --<span class="built_in">stat</span> patch.diff</span><br></pre></td></tr></tbody></table></figure>

<p>  检查Diff文件是否能正常打入  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply --check patch.diff</span><br></pre></td></tr></tbody></table></figure>

<p>  打入Diff  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git apply patch.diff</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看命令历史：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看工作区和版本库里面最新版本的区别：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>丢弃工作区的修改：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>  把readme.txt文件在工作区的修改全部撤销，这里有两种情况：  </p>
<ol>
<li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；  </li>
<li>readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。  </li>
</ol>
</li>
<li><p>把暂存区的修改撤销掉(unstage)：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>合并某分支到当前分支:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>清理掉本地不受版本库控制的文件:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git clean -f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>删除服务器分支的命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push --delete origin 分支名</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">stash应用场景 - 处理临时任务前需要保存工作现场</a>  </p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">多人协作</a>  </p>
</li>
<li><p>rebase  </p>
</li>
<li><p>标签    </p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424">配置别名</a>  </p>
</li>
<li><p>开发步骤  </p>
<ol>
<li>切换到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git fetch origin;git checkout origin/develop;git branch -D develop;git checkout -b develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>新建一个自己的临时开发分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -b user_01</span><br></pre></td></tr></tbody></table></figure></li>
<li>添加修改  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git add path/file</span><br></pre></td></tr></tbody></table></figure></li>
<li>提交修改，并产生一个git_ID:0deaddead  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">""</span><span class="string">""</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>切换到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git fetch origin;git checkout origin/develop;git branch -D develop;git checkout -b develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>拉取刚才的提交，到最新的develop分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git cherry-pick 0deaddead</span><br></pre></td></tr></tbody></table></figure></li>
<li>推送到服务器  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin develop:develop</span><br></pre></td></tr></tbody></table></figure></li>
<li>删除自己临时的开发分支  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -D user_01</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>git不同code，修改相同路径相同的文件，直接抓取的修改文件的方法：  </p>
<p>  例如，谷歌TV抓取歌谷TV上的文件，在谷歌TV code执行：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote add gegu git@123.45.6.78:Android_RD/gegu_tv.git  </span><br><span class="line">$ git remount -v  </span><br><span class="line">$ git fetch gegu  </span><br><span class="line">$ git pull  </span><br><span class="line">$ git cherry-pick xxxxxxx(gegu上的gitid)  </span><br><span class="line">$ git push origin develop  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>查看另一个分支的文件：<br>  有时你想查看另一个分支的文件的内容。用一个简单的Git命令就可以实现，而且不需要切换分支。<br>  假设你有一个名为README.md的文件，它在main分支中，而你正在dev分支上工作，使用下面的Git命令，你可以在终端上完成：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git show main:README.md</span><br></pre></td></tr></tbody></table></figure>
<p>  一旦你执行了这个命令，你就可以在你的终端上查看文件的内容。  </p>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://git-scm.com/docs/git-show">git show</a>  </li>
<li><a href="https://www.git-scm.com/docs/git-log#Documentation/git-log.txt--Lltstartgtltendgtltfilegt">git log</a>  </li>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README.md">git-flight-rules</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iHerb礼券码</title>
    <url>/2019/08/08/iherb/</url>
    <content><![CDATA[<p>分享我的iHerb礼券码</p>
<span id="more"></span>


<p><a href="https://cn.iherb.com/?rcode=BKZ9932">BKZ9932</a></p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>nutrition</tag>
        <tag>protein</tag>
        <tag>bulking</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB使用</title>
    <url>/2019/05/23/gdb/</url>
    <content><![CDATA[<p>GDB速查。  </p>
<span id="more"></span>


<p>常见调试命令  </p>
<table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">命令缩写</th>
<th align="left">命令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">backtrace</td>
<td align="left">bt</td>
<td align="left">查看函数调用堆栈</td>
</tr>
<tr>
<td align="left">frame</td>
<td align="left">f</td>
<td align="left">查看栈帧</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">l</td>
<td align="left">查看源码</td>
</tr>
<tr>
<td align="left">print</td>
<td align="left">p</td>
<td align="left">打印内部变量值</td>
</tr>
<tr>
<td align="left">info</td>
<td align="left">i</td>
<td align="left">查看程序状态</td>
</tr>
<tr>
<td align="left">display</td>
<td align="left">disp</td>
<td align="left">跟踪某变量，每次停下来则显示值</td>
</tr>
<tr>
<td align="left">run</td>
<td align="left">r</td>
<td align="left">开始运行程序</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">c</td>
<td align="left">继续程序运行，直到下一个断点</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">b</td>
<td align="left">设置断点</td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">s</td>
<td align="left">开始执行程序</td>
</tr>
<tr>
<td align="left">step</td>
<td align="left">s</td>
<td align="left">执行下一条语句，若该语句为函数调用，则进入函数内的第一条语句</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">n</td>
<td align="left">执行下一条语句，不会进入函数内部执行</td>
</tr>
<tr>
<td align="left">watch</td>
<td align="left"></td>
<td align="left">监视变量值的变化</td>
</tr>
<tr>
<td align="left">file</td>
<td align="left"></td>
<td align="left">装入需要调试的程序</td>
</tr>
<tr>
<td align="left">set var name=v</td>
<td align="left"></td>
<td align="left">设置变量的值</td>
</tr>
<tr>
<td align="left">kill</td>
<td align="left">k</td>
<td align="left">杀掉正在调试的程序</td>
</tr>
<tr>
<td align="left">quit</td>
<td align="left">q</td>
<td align="left">退出GDB环境</td>
</tr>
</tbody></table>
<p>举例  </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">info threads</td>
<td align="left">显示当前可调试的所有线程</td>
</tr>
<tr>
<td align="left">t 23</td>
<td align="left">跳到Thread ID 23</td>
</tr>
<tr>
<td align="left">f 1</td>
<td align="left">跳到第一帧</td>
</tr>
<tr>
<td align="left">thread apply all bt</td>
<td align="left">查看所有线程堆栈信息</td>
</tr>
<tr>
<td align="left">break 16</td>
<td align="left">设置断点，在源程序第16行处</td>
</tr>
<tr>
<td align="left">break func</td>
<td align="left">设置断点，在函数func( )入口处</td>
</tr>
<tr>
<td align="left">info break</td>
<td align="left">查看断点信息</td>
</tr>
<tr>
<td align="left">p i</td>
<td align="left">打印变量i的值</td>
</tr>
<tr>
<td align="left">finish</td>
<td align="left">退出函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>2851</title>
    <url>/2019/05/11/2851/</url>
    <content><![CDATA[<p>速查。  </p>
<span id="more"></span>


<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>进入到code的Android版本目录，“pie”是Android 9  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie  </span><br></pre></td></tr></tbody></table></figure>
<p>初始化编译环境  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> build/envsetup.sh  </span><br></pre></td></tr></tbody></table></figure>
<p>选择板型  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ lunch  </span><br></pre></td></tr></tbody></table></figure>
<p>进入到APK目录  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> vendor/realtek/app/HKMediaBrowser  </span><br></pre></td></tr></tbody></table></figure>
<p>编译  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mm  </span><br></pre></td></tr></tbody></table></figure>
<p>在<code>kernel/android/pie/frameworks/base/services</code>目录下的东西，需要到这个目录下执行<code>mm</code>，<code>eng</code>版本会生成<code>services.jar</code>,<code>user-debug</code>会生成<code>services.jar``services.jar.prof``oat/arm/services.art``oat/arm/services.odex``oat/arm/services.vdex</code>  </p>
<p>编译kernel模块  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ make -C kernel/linux/linux-4.14/ CROSS_COMPILE=../../../kernel/system/tmp/toolchain/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin/asdk-linux- modules  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mount -o rw,remount /  </span><br><span class="line">$ mount -o rw,remount /vendor  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="更新API"><a href="#更新API" class="headerlink" title="更新API"></a>更新API</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/pie  </span><br><span class="line">$ <span class="built_in">source</span> build/envsetup.sh  </span><br><span class="line">$ lunch  </span><br><span class="line">$ make update-api  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="Android分区查看"><a href="#Android分区查看" class="headerlink" title="Android分区查看"></a>Android分区查看</h3><ul>
<li>查看分区数  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/partitions  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看分区名字  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls -l /dev/block/by-name/  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看分区挂载点  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/mounts  </span><br></pre></td></tr></tbody></table></figure></li>
<li>查看磁盘使用情况  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ df -h  </span><br></pre></td></tr></tbody></table></figure></li>
<li>记录当前系统所有挂载文件系统的信息  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/self/mountinfo</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="格式化一个分区"><a href="#格式化一个分区" class="headerlink" title="格式化一个分区"></a>格式化一个分区</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mke2fs -t ext4 /dev/block/mmcblk0p14 &gt; /dev/null</span><br><span class="line">$ mke2fs -t ext4 /dev/block/mmcblk0p14 &gt; /dev/null</span><br><span class="line">$ mke2fs -t ext4 /dev/block/mmcblk0p3 &gt; /dev/null</span><br></pre></td></tr></tbody></table></figure>

<h3 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ dumpsys -l <span class="comment">#查看当前所有的系统服务名称，接着就可以通过dumpsys + name查看某个服务的具体信息  </span></span><br><span class="line">$ dumpsys activity <span class="comment">#查询AMS服务相关信息  </span></span><br><span class="line">$ dumpsys window <span class="comment">#查询WMS服务相关信息  </span></span><br><span class="line">$ dumpsys cpuinfo <span class="comment">#查询CPU情况  </span></span><br><span class="line">$ dumpsys meminfo <span class="comment">#查询内存情况  </span></span><br><span class="line">$ dumpsys input <span class="comment">#查询linux event与android keyevent的映射  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys activity a packagename <span class="comment">#获取某个应用的Activity信息  </span></span><br><span class="line">$ dumpsys activity s packagename <span class="comment">#获取某个应用的Service信息  </span></span><br><span class="line">$ dumpsys activity b packagename <span class="comment">#获取某个应用的Broadcast信息  </span></span><br><span class="line">$ dumpsys activity prov packagename <span class="comment">#获取某个应用的Provider信息  </span></span><br><span class="line">$ dumpsys activity p packagename <span class="comment">#查询某个应用的进程状态  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys activity top <span class="comment">#当前界面app状态  </span></span><br><span class="line">$ dumpsys activity oom <span class="comment">#查看进程状态  </span></span><br><span class="line"></span><br><span class="line">$ dumpsys usb dump-descriptors -dump-list <span class="comment">#查看USB描述符状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ dumpsys activity | grep Focuse  </span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> kernel/android/nougat/packages/apps/  </span><br><span class="line">$ find -name <span class="string">"AndroidManifest.xml"</span>  | xargs grep -wnr <span class="string">"com.android.tv.settings"</span>  </span><br><span class="line">$ ls kernel/android/nougat/packages/apps/TvSettings/Settings  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="ADB使用"><a href="#ADB使用" class="headerlink" title="ADB使用"></a>ADB使用</h3><p>单板设置：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">setprop service.adb.tcp.port 5555  </span><br><span class="line">start adbd  </span><br><span class="line">ifconfig  </span><br></pre></td></tr></tbody></table></figure>

<p>PC机设置：<br>ipconfig确认IP是否跟单板在同一个网段上<br>Ping单板的IP<br>连接：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ adb connect 192.168.1.105:5555  </span><br><span class="line">$ adb shell  </span><br><span class="line">$ adb kill-server <span class="comment">#终止adb服务进程  </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a>logcat</h3><p>常用功能：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ logcat -c <span class="comment">#清空所有的日志缓存信息  </span></span><br><span class="line">$ logcat -G 10M <span class="comment">#设置缓存区大小为10M  </span></span><br><span class="line">$ logcat -s MainActivity <span class="comment">#设置输出日志的标签，只显示MainActivity标签的日志  </span></span><br><span class="line">$ logcat -v time <span class="comment">#设置日志的输出格式，log带有日期  </span></span><br><span class="line">$ logcat | grep &lt;过滤内容&gt; <span class="comment">#根据内容过滤log  </span></span><br><span class="line">$ logcat CRYPTO:S <span class="comment">#S表示为不输出该标签的日志  </span></span><br><span class="line">$ logcat | grep -vE <span class="string">"CRYPTO"</span> <span class="comment">#滤掉CRYPTO  </span></span><br></pre></td></tr></tbody></table></figure>

<p>应用：<br>如何查看指定应用的日志？以包名为com.realtek.dtv的应用为例：  </p>
<ol>
<li>查看应用进程号  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ps | grep com.realtek.dtv  </span><br></pre></td></tr></tbody></table></figure>
获得信息，可知该应用的PID为1069：  <blockquote>
<p> 1069 1000       0:05 com.realtek.dtv<br> 2909 2000       0:00 grep com.realtek.dtv  </p>
</blockquote>
</li>
<li>过滤该应用的日志  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ logcat -c;logcat | grep 1069  </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>应用安装：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ pm install /storage/udisk/sda1/.apk  </span><br><span class="line">$ pm uninstall com.test.selftest  （包名） </span><br></pre></td></tr></tbody></table></figure>
<p>编辑框也可以直接输入信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ input text 12345678  </span><br></pre></td></tr></tbody></table></figure>
<p>uboot命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ fatls mmc 0:2 //查看第0个mmc设备的第2个分区(fat分区)</span><br><span class="line">$ ext4ls mmc 0:11 /common/panel //查看第0个mmc设备的第11个分区的/common/panel目录</span><br><span class="line">$ mmc list //列出所有的mmc设备</span><br><span class="line">$ mmc part //列出当前mmc设备的分区信息</span><br></pre></td></tr></tbody></table></figure>
<p>bootcode指令烧录:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ usb start;  </span><br><span class="line">$ fatload usb 0:1 0x1500000 dvrboot.rescue.exe.bin;  </span><br><span class="line">$ go 0x1500000  </span><br></pre></td></tr></tbody></table></figure>
<p>升级内核：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ swuu vmlinux.pkg  </span><br></pre></td></tr></tbody></table></figure>
<p>打开KERNEL打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 7 4 1 7 &gt; /proc/sys/kernel/printk  </span><br></pre></td></tr></tbody></table></figure>
<p>关闭KERNEL打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 0 4 1 7 &gt; /proc/sys/kernel/printk  </span><br></pre></td></tr></tbody></table></figure>
<p>打开demod打印信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"log_onoff=1"</span> &gt; /proc/rtkdemod/dbg  </span><br></pre></td></tr></tbody></table></figure>
<p>开bootcode打印：<br>编辑bootcode/uboot/include/configs/rtd285o_common.h  </p>
<p>快速打开一个应用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ am start com.android.tv.settings/com.android.tv.settings.MainSettings  </span><br></pre></td></tr></tbody></table></figure>

<p>调试IR信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ rtd irda set_decode_dbg_en 1  </span><br></pre></td></tr></tbody></table></figure>
<p>选择IR协议：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ rtd irda set_protocol 1  </span><br></pre></td></tr></tbody></table></figure>
<p>快速复位：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ am broadcast -a android.intent.action.MASTER_CLEAR  </span><br></pre></td></tr></tbody></table></figure>
<p>输入虚拟键：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ input keyevent 26 //keycode_power  </span><br></pre></td></tr></tbody></table></figure>
<p>查看input设备的属性：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat /proc/bus/input/devices  </span><br></pre></td></tr></tbody></table></figure>
<p>获取屏幕分辨率：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wm size</span><br></pre></td></tr></tbody></table></figure>
<p>获取像素密度：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wm density</span><br></pre></td></tr></tbody></table></figure>
<p>编译差分包：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ./build/tools/releasetools/ota_from_target_files -i ota_target_files_old.zip ota_target_files.zip update.zip  </span><br></pre></td></tr></tbody></table></figure>
<p>升级OTA：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ touch /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"--update_package=/data/update.zip"</span> &gt; /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"--wipe_data"</span> &gt;&gt; /cache/recovery/<span class="built_in">command</span>;  </span><br><span class="line">$ sync;  </span><br><span class="line">$ reboot  </span><br><span class="line">$ <span class="comment">#然后按住TAB键上电</span></span><br></pre></td></tr></tbody></table></figure>
<p>进Recovery：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">touch /cache/recovery/<span class="built_in">command</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--show_text"</span> &gt; /cache/recovery/<span class="built_in">command</span></span><br><span class="line">sync</span><br></pre></td></tr></tbody></table></figure>
<p>打包系统log信息：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar cvf /mnt/media_rw/sda1/log.tar /tmp/var/<span class="built_in">log</span>/ /data/anr/ /data/tombstones/;sync;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>mm编译出来的软件无法安装：<br>不生成<code>odex</code>，只生成<code>apk</code>，就可以安装了。<br>把<code>Android.mk</code>的<code>LOCAL_DEX_PREOPT </code>设定为<code>false</code>。  </p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ol>
<li><p>挂在so的问题，一般可以看<code>tombstones</code>文件，或者用<code>addr2line</code>工具定位：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ addr2line -f -C -e libhbbtv_jni.so 0000381b</span><br></pre></td></tr></tbody></table></figure>
<p><code>-f</code>显示函数名称<br><code>-C</code>显示函数参数  </p>
</li>
<li><p><code>debuggerd</code>命令<br>进程锁死或者错误逻辑引起死循环时，可以用该命令把相关进程的backtrace打印出来：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ debuggerd -b &lt;pid&gt;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://blog.csdn.net/weiwei_xiaoyu/article/details/53926276">usb-descriptor(一)</a>  </li>
<li><a href="https://blog.csdn.net/weiwei_xiaoyu/article/details/53930697">usb-descriptor(二)</a>  </li>
<li><a href="https://blog.csdn.net/jklinux/article/details/72638830">02 uboot的常用命令及用法</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>realtek</tag>
        <tag>android</tag>
        <tag>2851</tag>
      </tags>
  </entry>
  <entry>
    <title>CRC查表</title>
    <url>/2019/08/09/crc/</url>
    <content><![CDATA[<p>复制下来。</p>
<span id="more"></span>


<p>代码如下：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> crcTable[<span class="number">256</span>] = {</span><br><span class="line"><span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xEE0E612C</span>, <span class="number">0x990951BA</span>, <span class="number">0x076DC419</span>, <span class="number">0x706AF48F</span>,</span><br><span class="line"><span class="number">0xE963A535</span>, <span class="number">0x9E6495A3</span>, <span class="number">0x0EDB8832</span>, <span class="number">0x79DCB8A4</span>, <span class="number">0xE0D5E91E</span>, <span class="number">0x97D2D988</span>,</span><br><span class="line"><span class="number">0x09B64C2B</span>, <span class="number">0x7EB17CBD</span>, <span class="number">0xE7B82D07</span>, <span class="number">0x90BF1D91</span>, <span class="number">0x1DB71064</span>, <span class="number">0x6AB020F2</span>,</span><br><span class="line"><span class="number">0xF3B97148</span>, <span class="number">0x84BE41DE</span>, <span class="number">0x1ADAD47D</span>, <span class="number">0x6DDDE4EB</span>, <span class="number">0xF4D4B551</span>, <span class="number">0x83D385C7</span>,</span><br><span class="line"><span class="number">0x136C9856</span>, <span class="number">0x646BA8C0</span>, <span class="number">0xFD62F97A</span>, <span class="number">0x8A65C9EC</span>, <span class="number">0x14015C4F</span>, <span class="number">0x63066CD9</span>,</span><br><span class="line"><span class="number">0xFA0F3D63</span>, <span class="number">0x8D080DF5</span>, <span class="number">0x3B6E20C8</span>, <span class="number">0x4C69105E</span>, <span class="number">0xD56041E4</span>, <span class="number">0xA2677172</span>,</span><br><span class="line"><span class="number">0x3C03E4D1</span>, <span class="number">0x4B04D447</span>, <span class="number">0xD20D85FD</span>, <span class="number">0xA50AB56B</span>, <span class="number">0x35B5A8FA</span>, <span class="number">0x42B2986C</span>,</span><br><span class="line"><span class="number">0xDBBBC9D6</span>, <span class="number">0xACBCF940</span>, <span class="number">0x32D86CE3</span>, <span class="number">0x45DF5C75</span>, <span class="number">0xDCD60DCF</span>, <span class="number">0xABD13D59</span>,</span><br><span class="line"><span class="number">0x26D930AC</span>, <span class="number">0x51DE003A</span>, <span class="number">0xC8D75180</span>, <span class="number">0xBFD06116</span>, <span class="number">0x21B4F4B5</span>, <span class="number">0x56B3C423</span>,</span><br><span class="line"><span class="number">0xCFBA9599</span>, <span class="number">0xB8BDA50F</span>, <span class="number">0x2802B89E</span>, <span class="number">0x5F058808</span>, <span class="number">0xC60CD9B2</span>, <span class="number">0xB10BE924</span>,</span><br><span class="line"><span class="number">0x2F6F7C87</span>, <span class="number">0x58684C11</span>, <span class="number">0xC1611DAB</span>, <span class="number">0xB6662D3D</span>, <span class="number">0x76DC4190</span>, <span class="number">0x01DB7106</span>,</span><br><span class="line"><span class="number">0x98D220BC</span>, <span class="number">0xEFD5102A</span>, <span class="number">0x71B18589</span>, <span class="number">0x06B6B51F</span>, <span class="number">0x9FBFE4A5</span>, <span class="number">0xE8B8D433</span>,</span><br><span class="line"><span class="number">0x7807C9A2</span>, <span class="number">0x0F00F934</span>, <span class="number">0x9609A88E</span>, <span class="number">0xE10E9818</span>, <span class="number">0x7F6A0DBB</span>, <span class="number">0x086D3D2D</span>,</span><br><span class="line"><span class="number">0x91646C97</span>, <span class="number">0xE6635C01</span>, <span class="number">0x6B6B51F4</span>, <span class="number">0x1C6C6162</span>, <span class="number">0x856530D8</span>, <span class="number">0xF262004E</span>,</span><br><span class="line"><span class="number">0x6C0695ED</span>, <span class="number">0x1B01A57B</span>, <span class="number">0x8208F4C1</span>, <span class="number">0xF50FC457</span>, <span class="number">0x65B0D9C6</span>, <span class="number">0x12B7E950</span>,</span><br><span class="line"><span class="number">0x8BBEB8EA</span>, <span class="number">0xFCB9887C</span>, <span class="number">0x62DD1DDF</span>, <span class="number">0x15DA2D49</span>, <span class="number">0x8CD37CF3</span>, <span class="number">0xFBD44C65</span>,</span><br><span class="line"><span class="number">0x4DB26158</span>, <span class="number">0x3AB551CE</span>, <span class="number">0xA3BC0074</span>, <span class="number">0xD4BB30E2</span>, <span class="number">0x4ADFA541</span>, <span class="number">0x3DD895D7</span>,</span><br><span class="line"><span class="number">0xA4D1C46D</span>, <span class="number">0xD3D6F4FB</span>, <span class="number">0x4369E96A</span>, <span class="number">0x346ED9FC</span>, <span class="number">0xAD678846</span>, <span class="number">0xDA60B8D0</span>,</span><br><span class="line"><span class="number">0x44042D73</span>, <span class="number">0x33031DE5</span>, <span class="number">0xAA0A4C5F</span>, <span class="number">0xDD0D7CC9</span>, <span class="number">0x5005713C</span>, <span class="number">0x270241AA</span>,</span><br><span class="line"><span class="number">0xBE0B1010</span>, <span class="number">0xC90C2086</span>, <span class="number">0x5768B525</span>, <span class="number">0x206F85B3</span>, <span class="number">0xB966D409</span>, <span class="number">0xCE61E49F</span>,</span><br><span class="line"><span class="number">0x5EDEF90E</span>, <span class="number">0x29D9C998</span>, <span class="number">0xB0D09822</span>, <span class="number">0xC7D7A8B4</span>, <span class="number">0x59B33D17</span>, <span class="number">0x2EB40D81</span>,</span><br><span class="line"><span class="number">0xB7BD5C3B</span>, <span class="number">0xC0BA6CAD</span>, <span class="number">0xEDB88320</span>, <span class="number">0x9ABFB3B6</span>, <span class="number">0x03B6E20C</span>, <span class="number">0x74B1D29A</span>,</span><br><span class="line"><span class="number">0xEAD54739</span>, <span class="number">0x9DD277AF</span>, <span class="number">0x04DB2615</span>, <span class="number">0x73DC1683</span>, <span class="number">0xE3630B12</span>, <span class="number">0x94643B84</span>,</span><br><span class="line"><span class="number">0x0D6D6A3E</span>, <span class="number">0x7A6A5AA8</span>, <span class="number">0xE40ECF0B</span>, <span class="number">0x9309FF9D</span>, <span class="number">0x0A00AE27</span>, <span class="number">0x7D079EB1</span>,</span><br><span class="line"><span class="number">0xF00F9344</span>, <span class="number">0x8708A3D2</span>, <span class="number">0x1E01F268</span>, <span class="number">0x6906C2FE</span>, <span class="number">0xF762575D</span>, <span class="number">0x806567CB</span>,</span><br><span class="line"><span class="number">0x196C3671</span>, <span class="number">0x6E6B06E7</span>, <span class="number">0xFED41B76</span>, <span class="number">0x89D32BE0</span>, <span class="number">0x10DA7A5A</span>, <span class="number">0x67DD4ACC</span>,</span><br><span class="line"><span class="number">0xF9B9DF6F</span>, <span class="number">0x8EBEEFF9</span>, <span class="number">0x17B7BE43</span>, <span class="number">0x60B08ED5</span>, <span class="number">0xD6D6A3E8</span>, <span class="number">0xA1D1937E</span>,</span><br><span class="line"><span class="number">0x38D8C2C4</span>, <span class="number">0x4FDFF252</span>, <span class="number">0xD1BB67F1</span>, <span class="number">0xA6BC5767</span>, <span class="number">0x3FB506DD</span>, <span class="number">0x48B2364B</span>,</span><br><span class="line"><span class="number">0xD80D2BDA</span>, <span class="number">0xAF0A1B4C</span>, <span class="number">0x36034AF6</span>, <span class="number">0x41047A60</span>, <span class="number">0xDF60EFC3</span>, <span class="number">0xA867DF55</span>,</span><br><span class="line"><span class="number">0x316E8EEF</span>, <span class="number">0x4669BE79</span>, <span class="number">0xCB61B38C</span>, <span class="number">0xBC66831A</span>, <span class="number">0x256FD2A0</span>, <span class="number">0x5268E236</span>,</span><br><span class="line"><span class="number">0xCC0C7795</span>, <span class="number">0xBB0B4703</span>, <span class="number">0x220216B9</span>, <span class="number">0x5505262F</span>, <span class="number">0xC5BA3BBE</span>, <span class="number">0xB2BD0B28</span>,</span><br><span class="line"><span class="number">0x2BB45A92</span>, <span class="number">0x5CB36A04</span>, <span class="number">0xC2D7FFA7</span>, <span class="number">0xB5D0CF31</span>, <span class="number">0x2CD99E8B</span>, <span class="number">0x5BDEAE1D</span>,</span><br><span class="line"><span class="number">0x9B64C2B0</span>, <span class="number">0xEC63F226</span>, <span class="number">0x756AA39C</span>, <span class="number">0x026D930A</span>, <span class="number">0x9C0906A9</span>, <span class="number">0xEB0E363F</span>,</span><br><span class="line"><span class="number">0x72076785</span>, <span class="number">0x05005713</span>, <span class="number">0x95BF4A82</span>, <span class="number">0xE2B87A14</span>, <span class="number">0x7BB12BAE</span>, <span class="number">0x0CB61B38</span>,</span><br><span class="line"><span class="number">0x92D28E9B</span>, <span class="number">0xE5D5BE0D</span>, <span class="number">0x7CDCEFB7</span>, <span class="number">0x0BDBDF21</span>, <span class="number">0x86D3D2D4</span>, <span class="number">0xF1D4E242</span>,</span><br><span class="line"><span class="number">0x68DDB3F8</span>, <span class="number">0x1FDA836E</span>, <span class="number">0x81BE16CD</span>, <span class="number">0xF6B9265B</span>, <span class="number">0x6FB077E1</span>, <span class="number">0x18B74777</span>,</span><br><span class="line"><span class="number">0x88085AE6</span>, <span class="number">0xFF0F6A70</span>, <span class="number">0x66063BCA</span>, <span class="number">0x11010B5C</span>, <span class="number">0x8F659EFF</span>, <span class="number">0xF862AE69</span>,</span><br><span class="line"><span class="number">0x616BFFD3</span>, <span class="number">0x166CCF45</span>, <span class="number">0xA00AE278</span>, <span class="number">0xD70DD2EE</span>, <span class="number">0x4E048354</span>, <span class="number">0x3903B3C2</span>,</span><br><span class="line"><span class="number">0xA7672661</span>, <span class="number">0xD06016F7</span>, <span class="number">0x4969474D</span>, <span class="number">0x3E6E77DB</span>, <span class="number">0xAED16A4A</span>, <span class="number">0xD9D65ADC</span>,</span><br><span class="line"><span class="number">0x40DF0B66</span>, <span class="number">0x37D83BF0</span>, <span class="number">0xA9BCAE53</span>, <span class="number">0xDEBB9EC5</span>, <span class="number">0x47B2CF7F</span>, <span class="number">0x30B5FFE9</span>,</span><br><span class="line"><span class="number">0xBDBDF21C</span>, <span class="number">0xCABAC28A</span>, <span class="number">0x53B39330</span>, <span class="number">0x24B4A3A6</span>, <span class="number">0xBAD03605</span>, <span class="number">0xCDD70693</span>,</span><br><span class="line"><span class="number">0x54DE5729</span>, <span class="number">0x23D967BF</span>, <span class="number">0xB3667A2E</span>, <span class="number">0xC4614AB8</span>, <span class="number">0x5D681B02</span>, <span class="number">0x2A6F2B94</span>,</span><br><span class="line"><span class="number">0xB40BBE37</span>, <span class="number">0xC30C8EA1</span>, <span class="number">0x5A05DF1B</span>, <span class="number">0x2D02EF8D</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">CountCRC32</span><span class="params">(<span class="keyword">char</span> *pData, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> crc;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> c;</span><br><span class="line"></span><br><span class="line">    crc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    {</span><br><span class="line">        c = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pData[i];</span><br><span class="line">        crc = ((crc&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00FFFFFF</span>) ^ crcTable[ (crc^c) &amp; <span class="number">0xFF</span> ];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>( crc^<span class="number">0xFFFFFFFF</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789">循环冗余校验（CRC）算法入门引导</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>crc</tag>
        <tag>checksum</tag>
      </tags>
  </entry>
  <entry>
    <title>开始健身</title>
    <url>/2019/08/08/kaike/</url>
    <content><![CDATA[<p>BE BETTER TOMORROW THAN YOU ARE TODAY!  </p>
<span id="more"></span>


<p>身高170cm左右，大学期间体重在102斤到104斤之间浮动，身材很瘦。2016年年中开始工作之后，没多久就有了健身的想法，当时还不想去健身房，想从寝室健身开始，于是在公司宿舍住了大概半年后，搬出去开始自己租房子，大概2017年年中，终于买了一个哑铃凳和一对哑铃放在小出租屋里，果然，闲置了一年半，最后二手出了。健身失败。  </p>
<p>时间来到了2019年4月。半途而废的挫败感让我难堪，适逢<a href="https://zhuanlan.zhihu.com/Uncle-Zhuo">卓叔</a>新馆开张，我终于下定决心健身了，花了接近5000块钱买了20节课，这是我花钱最多的一次单次消费！卧槽，终于要开始了。前期一周两节课，分化开始后一周三节课，按照这个频率，课很快就学完了，觉得收获很大。公司现在搞了个小型健身房，我现在开始在公司练啦，对我有用的只有个史密斯机、一个哑铃凳和一架子哑铃，总比没有好吧！史密斯机练三大项很难受！没办法正常做硬拉和杠铃卧推，槽糕！  </p>
<p>5月1号和8月7号的自拍，有点小进步，嘻嘻。  </p>
<p>期待明年今日。  </p>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>bulking</tag>
        <tag>fitness</tag>
        <tag>workout</tag>
        <tag>muscle</tag>
        <tag>training</tag>
        <tag>health</tag>
      </tags>
  </entry>
  <entry>
    <title>匆匆</title>
    <url>/2019/12/13/debbie/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>

<blockquote>
<p><em><strong>The sun shines through the kitchen, and we are making love, feel like the rest of the world doesn’t exit any more and I finally understand the meaning of eternity.</strong></em>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>love</tag>
        <tag>debbie</tag>
      </tags>
  </entry>
  <entry>
    <title>配屏不亮可能有哪些原因？</title>
    <url>/2019/12/26/panel-not-working/</url>
    <content><![CDATA[<p>配屏不亮可能有哪些原因？  </p>
<span id="more"></span>


<ol>
<li>排线松动  </li>
<li>板卡驱屏电压不对  </li>
<li>LVDS驱动电流不够  </li>
<li>分辨率不对  </li>
<li>屏参不对  </li>
</ol>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>panel</tag>
      </tags>
  </entry>
  <entry>
    <title>Auto Color</title>
    <url>/2019/12/27/auto-color/</url>
    <content><![CDATA[<p>Auto Color，也有Auto ADC的叫法。分量和VGA属于高清模拟通道，在TV的流程里面会经过ADC处理。为了保证每台电视的一致性，在生产过程就会有一道ADC校正工序。但是目前的IC一般都会自动校正了。    </p>
<span id="more"></span>


<p>目的：  </p>
<ol>
<li>使信号的最低电平经ADC采集后输出的数位信号是0，信号的最高电平经ADC采集后输出的数位信号是255，这样可以得到最佳的对比度。  </li>
<li>硬件电路差异，进入ADC采集器的RGB信号可能偏离标准信号，且偏离量可能不一样，故必须对RGB通道分别做Auto Color。  </li>
</ol>
<p>原理：<br>通过调整ADC Offset设定值，使信号的最低电平经ADC采集后输出的数位信号为0，通过调整ADC Gain设定值使信号的最高电平经ADC采集后输出的数位信号为255。  </p>
<p><img src="https://i.loli.net/2019/12/27/83pyl1QRjkstuZJ.png" alt="auto_adc.png">  </p>
<p><img src="https://i.loli.net/2019/12/27/mJOnClSaRdHgzBG.jpg" alt="AutoColor.jpg">  </p>
<p>VGA ADC Adjust:<br><img src="https://i.loli.net/2019/12/27/pQ1Un9zBgfibN54.jpg" alt="VGA_ADC.jpg">  </p>
<p>YPbPr ADC Adjust:<br><img src="https://i.loli.net/2019/12/27/F5oqWwOavPR6YN2.jpg" alt="YPP_ADC_1.jpg">  </p>
<p><img src="https://i.loli.net/2019/12/27/oh5dTI2NwXJn4fa.jpg" alt="YPP_ADC_2.jpg">  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>adc</tag>
      </tags>
  </entry>
  <entry>
    <title>电视信号大致流程</title>
    <url>/2019/12/30/tv-block-diagram/</url>
    <content><![CDATA[<p>如下：  </p>
<span id="more"></span>



<p>图像：<br>一般称Demod及其之前的部分为前端，Decoder及其之后的部分为后端。<br><img src="https://i.loli.net/2019/12/30/obZB2aPhHzECQAp.jpg" alt="video_block_diagram.jpg"><br>个人理解：<br>RF信号给到Tuner，Tuner调谐成中频信号给到Demod，Demod解调成TS流给到Decoder，如果是隔行信号，还会经过De-Interlacer去交错，然后经过Scaler缩放，输出到Panel。  </p>
<hr>
<p>声音：<br>由前端输入模组，中间处理模组，后端输出模组构成：<br>前端输入一般叫做Audio_Rx模块，此模块与各通道HW连接，通过设定MUX，接收各个通道送过来的资料；<br>中间处理模组对收进来的资料处理、编解码动作及各种postprocess动作等等；<br>后端输出模组一般叫做Audio_Tx单元，会去执行Vol、PeakControl、输出通道选择等动作。<br><img src="https://i.loli.net/2020/09/09/7hkbSzi3nql5XRc.png" alt="Audio Processor Flow Chart.png"><br><img src="https://i.loli.net/2019/12/30/NxED3dr7sCqSRp1.jpg" alt="audio_block_diagram.jpg"><br>个人理解：<br>声音由通道输入，MUX后，经由PreScale处理声音额外的正Gain，然后经过AVL、EQ、Treble/Bass等处理后，输出到后端，执行Volume、Power Limiter、Mute等，最后经过功放放大，输出到喇叭。  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>DVB-T自动搜台流程跟踪</title>
    <url>/2020/01/16/rtk-dvbt-auto-scan/</url>
    <content><![CDATA[<p>已经有点烦了。  </p>
<span id="more"></span>



<p><code>kernel/android/pie/vendor/realtek/app/dtvinput/src/com/realtek/dtv/digitalsetup/dvb/DVBScanChannelFragment.java</code>，菜单上的最后一步，是创建一个<code>DigitalScanTask</code>：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mDigitalScanTask = <span class="keyword">new</span> DigitalScanTask((DigitalChannelSetupActivity)getActivity());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> mDigitalScanTask.sendMessageDelayed(DigitalScanTask.MSG_CHANNEL_SACN, scanParam, <span class="number">500</span>);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHANNEL_SACN:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_CHANNEL_TABLE_SACN);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHANNEL_TABLE_SACN:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    startTableScan();</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">success = mTvServiceHelper.startAutoScan(mScanChannelList,mModeType);<span class="comment">//auto table scan</span></span><br></pre></td></tr></tbody></table></figure>
<p>向下传进一个频点表<code>mScanChannelList</code>。  </p>
<p>调到了<code>kernel/android/pie/vendor/realtek/app/dtvinput/src/com/realtek/dtv/TvServiceHelper.java</code>的<code>startAutoScan</code>  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startAutoScan</span><span class="params">(ArrayList&lt;FreqTable&gt; freqtable,String type)</span></span>{</span><br><span class="line">	<span class="keyword">if</span> (mTv != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> mTv.StartDtvAutoScan(freqtable.size(),freqtable,-<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接着通过JNI，HIDL（依次调用了以下文件）<br><code>kernel/android/pie/vendor/realtek/frameworks/base/core/java/com/realtek/tv/Tv.java</code><br><code>kernel/android/pie/vendor/realtek/frameworks/base/core/jni/com_realtek_tv_Tv.cpp</code><br><code>kernel/android/pie/vendor/realtek/hardware/interfaces/tv/1.0/IRtkTv.hal</code><br><code>kernel/android/pie/vendor/realtek/hardware/interfaces/tv/1.0/default/RtkTv.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvsystem/tv/TvClient.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvservice/TvService.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tv/libtvservice/Tv.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/tvapi/dtvcontrol/CDTVControl.cpp</code><br><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/TableScanner.cpp</code>  </p>
<p>终于创建一个<code>ScanThread</code>线程  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CTableScanner::AutoScanStart</span><span class="params">(<span class="keyword">int</span> tvsubtype, <span class="keyword">int</span> satelliteIndex,<span class="keyword">bool</span> bSkipPMT,<span class="keyword">bool</span> bSSUScan)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	RT_FRONTEND_TYPE feType = m_pFreqScanDetector-&gt;<span class="built_in">Mf_GetFrontendType</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_threadIsRunning == <span class="literal">true</span> || (feType != RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_freqListSize == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_scanMode != CH_SCAN_MODE_IDLE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	m_bRemoveAll = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">	<span class="keyword">if</span>(feType == RT_FRONTEND_DVB_SATELLITE &amp;&amp; m_pFreqList == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">xLoadTable</span>(satelliteIndex);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	m_serviceID=<span class="number">0</span>;</span><br><span class="line">	m_scanMode = CH_SCAN_MODE_AUTO;</span><br><span class="line">	m_bSSUScan = bSSUScan;</span><br><span class="line">	m_bDelNosignalMux = <span class="literal">true</span>;</span><br><span class="line">	m_satelliteIndex = satelliteIndex;</span><br><span class="line">	m_bQuickScan=<span class="literal">false</span>;</span><br><span class="line">	m_bSkipPMT=bSkipPMT;</span><br><span class="line">	m_curFreqIndex = <span class="number">0</span>;</span><br><span class="line">	m_uiScanProgress = <span class="number">0</span>;</span><br><span class="line">	m_lastScanedFreqIndex =<span class="number">0</span>;</span><br><span class="line">	m_curFreq = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].frequency:<span class="number">0</span>;</span><br><span class="line">	m_curBandwidth = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].bandwidth:<span class="number">0</span>;</span><br><span class="line">	m_curChNum = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].channelNum:<span class="number">0</span>;</span><br><span class="line">	m_curModulation = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].modulation:RT_MOD_UNKNOWN;</span><br><span class="line">	m_curSymbolRate = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].symbolRate:<span class="number">0</span>;</span><br><span class="line">	m_curPolarization = m_pFreqList!=<span class="literal">NULL</span>?m_pFreqList[<span class="number">0</span>].polarization:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">NULL</span>, ScanThread, (<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Quick sleep to cause thread to be created.</span></span><br><span class="line">	<span class="keyword">while</span> (m_threadIsRunning == <span class="literal">false</span>)</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="准备搜台"><a href="#准备搜台" class="headerlink" title="准备搜台"></a>准备搜台</h3><p><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/ChScanner.cpp</code><br><code>ScanThread</code>线程首先将<code>CH_SCAN_STATE</code>设定为<code>CH_SCAN_STATE_INIT</code>，然后进入一个<code>xWorkerThread</code>循环  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CChScanner::ScanThread</span><span class="params">(<span class="keyword">void</span> *pParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	CChScanner *pThis = (CChScanner *)pParam;</span><br><span class="line">	pThis-&gt;m_scanState = CH_SCAN_STATE_INIT;</span><br><span class="line">	pThis-&gt;m_threadIsRunning = <span class="literal">true</span>;</span><br><span class="line">	pThis-&gt;m_runThread = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pThis-&gt;m_runThread == <span class="literal">true</span>)</span><br><span class="line">		pThis-&gt;<span class="built_in">xWorkerThread</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Manual/seekscan needs to set this variable before ending scan message is sent out.</span></span><br><span class="line">	pThis-&gt;m_threadIsRunning = <span class="literal">false</span>;</span><br><span class="line">	pThis-&gt;m_cancelScan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/TableScanner.cpp</code><br><code>xWorkerThread</code>循环中首先处理了<code>case``CH_SCAN_STATE_INIT</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xWorkerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Verify scan mode is valid.</span></span><br><span class="line">	<span class="keyword">if</span> ((m_scanMode == CH_SCAN_MODE_IDLE) || (m_scanMode &gt;= CH_SCAN_MODE_MAX))</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (m_scanState)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_INIT:</span><br><span class="line">		<span class="built_in">xStageInit</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_BEGIN_FREQ:</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_BEGIN_FREQ start\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="built_in">xStageBeginFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_SCANNING:</span><br><span class="line">		<span class="comment">// wait scan done</span></span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING start\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="keyword">while</span> (!m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()) {</span><br><span class="line">			<span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			m_pFreqScanDetector-&gt;<span class="built_in">RunStateProc</span>();</span><br><span class="line">			<span class="keyword">if</span> (m_cancelScan != <span class="literal">true</span> &amp;&amp; !m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()) {</span><br><span class="line">				<span class="keyword">if</span>(m_scanMode == CH_SCAN_MODE_BLIND_SCAN||m_scanMode == CH_SCAN_MODE_BLIND_SCAN_NETWORK)</span><br><span class="line">				{</span><br><span class="line">					<span class="keyword">int</span> Index = <span class="number">0</span>, Total = <span class="number">0</span>;</span><br><span class="line">					UINT32 freq = m_pFreqScanDetector-&gt;<span class="built_in">Mf_GetFrequency</span>(&amp;Index,&amp;Total);</span><br><span class="line">					<span class="keyword">if</span>(freq&gt;<span class="number">0</span>)</span><br><span class="line">					{</span><br><span class="line">						m_curFreqIndex = Index;</span><br><span class="line">						m_freqListSize = Total;</span><br><span class="line">						m_curFreq = freq;</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">usleep</span>(SCAN_THREAD_CS_TIME*<span class="number">1000</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING end\n"</span>, __func__, __LINE__);</span><br><span class="line">		m_scanState = CH_SCAN_STATE_END_FREQ;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_END_FREQ:</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_END_FREQ begin\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="built_in">xStageEndFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_SCAN_FAILED:</span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_EXIT:</span><br><span class="line">		<span class="built_in">xStageExit</span>();</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> CH_SCAN_STATE_IDLE:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">		m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXIT_SCANNING:</span><br><span class="line">	m_runThread = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跑的是<code>xStageInit()</code>函数，主要做了一件事  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanInit</span>(scanMode, param, m_bDelNosignalMux,scanModeEx);</span><br></pre></td></tr></tbody></table></figure>
<p>这件事会跳到<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/channel/scan/DtvFreqDetector.cpp</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanInit</span><span class="params">(CH_SCAN_MODE scanMode, UINT32 param, <span class="keyword">bool</span> bDelNoSignalMux, CH_SCAN_MODE_EX modeEx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanInit</span>(<span class="built_in">getSiScanType</span>(scanMode), param, typeEx);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接着跳到<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/mediacontrol/component/si/DvbSiMgr.cpp</code>  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanInit</span><span class="params">(SI_MGR_SCAN_TYPE type, <span class="keyword">int</span> antennaIndex, SI_MGR_SCAN_TYPE_EX typeEx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (type == SI_MGR_SCAN_TYPE_AUTO||type==SI_MGR_SCAN_TYPE_AUTO_QUICK) {</span><br><span class="line">	<span class="built_in">SI_SetState</span>(siHandle, SI_STATE_AUTOSCAN);</span><br><span class="line">	<span class="built_in">SI_AutoScanInit</span>(siHandle,antennaIndex,type==SI_MGR_SCAN_TYPE_AUTO_QUICK?TRUE:FALSE,FALSE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined ENABLE_CI &amp;&amp; defined ENABLE_CIPLUS_1_4)</span></span><br><span class="line">	<span class="keyword">if</span>(m_CiCallbackObj.NotifyChannelErase != <span class="literal">NULL</span>) {</span><br><span class="line">		m_CiCallbackObj.<span class="built_in">NotifyChannelErase</span>();</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>xStageInit</code>最后把<code>CH_SCAN_STATE</code>状态设定为<code>CH_SCAN_STATE_BEGIN_FREQ</code>  </p>
<h3 id="开始搜台"><a href="#开始搜台" class="headerlink" title="开始搜台"></a>开始搜台</h3><p><code>xWorkerThread``case``CH_SCAN_STATE_BEGIN_FREQ</code>执行<code>CTableScanner::xStageBeginFreq()</code><br>执行<code>m_pFreqScanDetector-&gt;Mf_ScanFrequency(param)</code><br>这里<code>FREQ_SCAN_STATE</code>被设置成状态<code>FREQ_SCAN_STATE_BEGIN_FREQ</code><br><code>CTableScanner::xStageBeginFreq()</code>的最后，<code>CH_SCAN_STATE</code>被设置成<code>CH_SCAN_STATE_SCANNING</code>  </p>
<h3 id="正在搜台"><a href="#正在搜台" class="headerlink" title="正在搜台"></a>正在搜台</h3><p>搜台过程就是<code>CTableScanner::xWorkerThread()``case``CH_SCAN_STATE_SCANNING</code>，是一个<code>while</code>循环<br>先判断是否搜台结束  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>()</span><br></pre></td></tr></tbody></table></figure>
<p>否则，跑  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">m_pFreqScanDetector-&gt;<span class="built_in">RunStateProc</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>因为刚才<code>FREQ_SCAN_STATE</code>被设置为<code>FREQ_SCAN_STATE_BEGIN_FREQ</code>,所以跑<code>CDtvFreqDetector::xStageBeginFreq()</code>。在某一频点的搜台基本都是在<code>CDtvFreqDetector</code>这里处理啦。  </p>
<p><code>m_pFreqScanDetector-&gt;RunStateProc()</code>做了什么？  </p>
<ol>
<li>Stop SI  </li>
<li>Set tuner param  </li>
<li>Notify demod to lock  </li>
<li>Check frontend(Update modulation, bandwidth, and symbol rate)  </li>
<li>Check SI  </li>
</ol>
<h4 id="FREQ-SCAN-STATE-BEGIN-FREQ"><a href="#FREQ-SCAN-STATE-BEGIN-FREQ" class="headerlink" title="FREQ_SCAN_STATE_BEGIN_FREQ"></a><code>FREQ_SCAN_STATE_BEGIN_FREQ</code></h4><p>跟下去能看到<code>tuner-&gt;tune(param)</code>和<code>tuner-&gt;isLocked()</code>都是在<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/driverbaseddtvapp/TunerMgr.cpp</code>处理的  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TunerMgr::tune</span><span class="params">(UINT32 frequency, UINT32 bandwidth, RT_FRONTEND_TYPE feType, RT_MODULATION modulation, RT_SPECTRAL_INVERSION inversion, <span class="keyword">bool</span> isScanMode, UINT32 symbolRate, SatelliteInfo *pSatelliteInfo)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	mFreq = frequency;</span><br><span class="line">	mBandwidth = bandwidth;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FrontendLib_SetTuner</span>(frequency, bandwidth, mTunerId, feType, modulation, inversion, isScanMode, symbolRate, pSatelliteInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TunerMgr::isLocked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">uint8_t</span> lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">TunerControlGetLockStatus</span>(mTunerId, &amp;lock) == TUNER_CTRL_OK)</span><br><span class="line">		<span class="keyword">return</span> lock;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="FREQ-SCAN-STATE-CHECK-FRONTEND"><a href="#FREQ-SCAN-STATE-CHECK-FRONTEND" class="headerlink" title="FREQ_SCAN_STATE_CHECK_FRONTEND"></a><code>FREQ_SCAN_STATE_CHECK_FRONTEND</code></h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckFrontend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_modulation = <span class="built_in">getRtModVal</span>(m_feType, info);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanStart</span>(m_curFreq, m_modulation, m_curBandwidth, symbolrate,  m_curPhyChNum, tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>(), m_serviceID);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanStart</span><span class="params">(UINT32 frequency, RT_MODULATION modulation, UINT32 bandwidth, UINT32 symbolrate, UINT32 phyChNum,UINT32 strength,<span class="keyword">float</span> snr, UINT16 serviceID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI* siHandle = (SI*)m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>()-&gt;<span class="built_in">GetSiHandle</span>();</span><br><span class="line">    SI_DVB_MODULATION siModulation;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(modulation)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM16:</span><br><span class="line">        siModulation=SI_DVB_16_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM32:</span><br><span class="line">        siModulation=SI_DVB_32_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM64:</span><br><span class="line">        siModulation=SI_DVB_64_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM128:</span><br><span class="line">        siModulation=SI_DVB_128_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM256:</span><br><span class="line">        siModulation=SI_DVB_256_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SI_SetState</span>(siHandle, SI_STATE_SCAN);</span><br><span class="line">    <span class="built_in">SI_ScanChannelEx</span>(siHandle, frequency, <span class="number">0</span>, bandwidth,siModulation,symbolrate, strength,snr,serviceID,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)phyChNum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>SI_ScanChannelEx</code>路径在<code>kernel/android/pie/vendor/realtek/frameworks/native/appclass/si/livetv_sidvb/librtd/si4/api/SI_Api.c</code>！  </p>
<h4 id="FREQ-SCAN-STATE-CHECK-SI"><a href="#FREQ-SCAN-STATE-CHECK-SI" class="headerlink" title="FREQ_SCAN_STATE_CHECK_SI"></a><code>FREQ_SCAN_STATE_CHECK_SI</code></h4><p><code>CDtvFreqDetector::xStageCheckSi()</code>：Wait for SI to finish gathering tables  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckSi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">RETRY:</span><br><span class="line">	<span class="keyword">if</span> (m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanIsDone</span>(&amp;m_bIsGetService) == <span class="literal">false</span>)</span><br><span class="line">	{</span><br><span class="line">		m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetSignalInfo</span>(tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>());</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetModulation</span>(m_curFreq, m_modulation);</span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDvbSiMgr::ScanIsDone</span><span class="params">(<span class="keyword">bool</span> *bGetCh)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_MESSAGE message;</span><br><span class="line">    UINT32 data = <span class="number">0</span>;</span><br><span class="line">    DriverBasedDtvApp *pDvbApp = m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDvbApp-&gt;<span class="built_in">GetSiMessage</span>(&amp;message, &amp;data) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == SI_MESSAGE_RESET_CHANNEL &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xResetChannel</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(message == SI_MESSAGE_CHANNEL_UPDATE &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xUpdateChannelMgr</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_CH_INFO_READY)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = data == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_SSU_SW_NOT_FOUND||message == SI_MESSAGE_SSU_SWINFO_READY)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = message == SI_MESSAGE_SSU_SWINFO_READY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">/* if (message != SI_MESSAGE_CH_INFO_READY)*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="完成搜台"><a href="#完成搜台" class="headerlink" title="完成搜台"></a>完成搜台</h3><h4 id="FREQ-SCAN-STATE-END-FREQ"><a href="#FREQ-SCAN-STATE-END-FREQ" class="headerlink" title="FREQ_SCAN_STATE_END_FREQ"></a><code>FREQ_SCAN_STATE_END_FREQ</code></h4><p>如果搜台完成了，<code>CDtvFreqDetector::xStageCheckSi()</code>之后会把<code>FREQ_SCAN_STATE</code>状态设定成<code>FREQ_SCAN_STATE_END_FREQ</code>，在<code>CTableScanner::xWorkerThread()</code>中，<code>CH_SCAN_STATE``CH_SCAN_STATE_SCANNING</code>会退出，变成<code>CH_SCAN_STATE_END_FREQ</code><br>接着跑<code>CTableScanner::xStageEndFreq()</code>,如果频点没搜完，接着搜下一个频点，否则，<code>CH_SCAN_STATE</code>设定为<code>CH_SCAN_STATE_SCAN_FAILED</code>，跑<code>CTableScanner::xStageExit()</code>，这里面跑<code>m_pFreqScanDetector-&gt;Mf_ScanDeInit()</code>以及把一些标志清空。  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanDeInit</span><span class="params">(<span class="keyword">bool</span> bNoSaveInNoCh)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetMode</span>(SI_MGR_MODE_INACTIVE);</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanEnd</span>(bNoSaveInNoCh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush SI queue.</span></span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">FlushMessageQueue</span>();</span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SaveChannelToFile</span>(bNoSaveInNoCh);</span><br><span class="line"></span><br><span class="line">	DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tunerId = <span class="number">-1</span>;</span><br><span class="line">	tuner-&gt;<span class="built_in">getTunerId</span>(tunerId);</span><br><span class="line">	<span class="built_in">TunerControlChannelScanModeEnable</span>(tunerId, <span class="number">0</span>);</span><br><span class="line">	tuner-&gt;<span class="built_in">reset</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>dvb</tag>
        <tag>si</tag>
        <tag>scan</tag>
        <tag>dvb-t</tag>
      </tags>
  </entry>
  <entry>
    <title>冥想</title>
    <url>/2020/02/28/ming-xiang/</url>
    <content><![CDATA[<p>贪婪地呼吸？    </p>
<span id="more"></span>


<ol>
<li>舒适地落座。你不一定非得盘腿。坐在椅子上、垫子上，或者地板上，哪里都可以。只要你保证脊柱直立。  </li>
<li>呼吸时感受气息的进出。选择一个身体部位–鼻腔，胸口，或者内脏，将你的注意力集中在那里，认真地尝试感觉你的呼吸。你可以使用一些柔和的提示，比如“吸气”、“吐气”，只要这样有助于引导你的注意力。  </li>
<li>根据我阅读过的所有书籍，这一步是重头戏。不管什么时候，如果你的注意力跑偏，只要原谅自己，恢复呼吸节奏就可以了。你不需要勉强自己的大脑一片空白，因为这基本是不可能的。（当然，当你的注意力集中在感受呼吸时，脑袋里的叽叽喳喳会暂停，但这种宁静不会持续太久。）这就是个训练，目的在于抓住你游荡的思绪，然后重寻你的呼吸，一遍遍地重复。  </li>
</ol>
<p>此刻，我终于明白了。奋斗无可厚非，只要奋斗者能够意识到在这广袤的宇宙中，一切事物的结果都不由我们掌控，与其在自己无法控制的变量上浪费精力，还不如专注于能够改变的东西。当你的雄心壮志带上了这一层智慧，那么你既能千方百计地谋求成功，又能洒脱地看待结果。因此，即使遭遇失败，也能迅速振作起来，掸掸满身的尘土，重新面对挫折。  </p>
<p>如果结果不尽如人意，我只需要鼓起勇气重新开始就好了。  </p>
<p>因你无法改变的事情而郁郁寡欢是毫无意义的，因你能够改变的事物而愁容满面同样没有帮助。  </p>
<p>静心冥想基础练习：  </p>
<ol>
<li>保持舒适的坐姿。  </li>
<li>感受自己的呼吸。  </li>
<li>当你走神的时候，只需要温柔地将意识带回到呼吸上就可以了。  </li>
</ol>
<hr>
<ul>
<li>来源<br><a href="https://book.douban.com/subject/26434953/">一个冥想者的觉知书</a></li>
</ul>
]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的Android功能需求</title>
    <url>/2020/03/04/android-simple-hard/</url>
    <content><![CDATA[<p>菜鸡历险记。  </p>
<span id="more"></span>



<p>需要加一个功能，包含两部分，一是工厂菜单也可以手动检索U盘中的OTA包，并且进行升级，二是插入U盘的时候，平台能自动识别U盘中的OTA包，并且可以升级。  </p>
<p>第一部分，具体就是，按菜单上升级选项的时候，去确认U盘是否存在指定文件名的文件，如果存在，把这个文件拷贝到系统目录<code>/data</code>，拷贝的时候弹出一个进度条<code>ProgressDialog</code>，等拷贝完成，进度条消失，最后调用系统接口<code>RecoverySystem.installPackage</code>升级OTA包。以上的动作基本都在Fragment菜单页通过Handler<code>sendEmptyMessageDelayed</code>的方式处理，验证也OK。  </p>
<p>第二部分：  </p>
<ul>
<li><p>阶段A<br>做插U盘识别的，在广播接收器里面，如果有U盘mount上了，就去查这个东西，然后调用Fragment的函数，最后也想通过Fragment的Handler把这些事情处理完。<br>本想通过这样，可以达到Fragment上一样的效果，既能执行拷贝等动作也能刷新进度条菜单。但是发生了很多<code>CRASH</code>，比如调用的很多函数里需要用到<code>Context</code>，所以我又在<code>BootCompleteReceiver</code>（名字是这样写，但是其实里面有判断<code>android.intent.action.MEDIA_MOUNTED</code>的）把<code>Context</code>传到<code>Fragment</code>，这都还好，最麻烦的就是，我在<code>BootCompleteReceiver</code>里无论通过静态的方式还是new的方式调用<code>Fragment</code>的方法，都用不了控件<code>ProgressDialog</code>，提示<code>Unable to add window</code>，<code>Dialog</code>只能在<code>Activity</code>中显示！到这，不知道怎么在广播里更新UI了。这样的话，就只有COPY和升级的功能，但是看不到整个过程的进度条，这样看起来很奇怪。要不在<code>BootCompleteReceiver</code>先把<code>Activity</code>启动起来，再接着做事情？感觉越来越奇怪了。还有遇到的就是调用<code>Fragment</code>方法的时候，报错<code>Attempt to invoke virtual method on a null object reference</code>，感觉也是没有对象，所以一些方法用了会有问题之类的问题，麻烦啊。  </p>
</li>
<li><p>阶段B<br>那咋搞？我就把<code>Fragment</code>里面的<code>Handler</code>处理方式差不多复制一份搞到<code>BootCompleteReceiver</code>里面，动作都写在<code>BootCompleteReceiver</code>，不通过别的地方调用了，<code>ProgressDialog</code>也是，但是操作控件的时候还是没有<code>Activity</code>啊。但是插入U盘之后<code>AlertDialog</code>是怎么出来的呢？原来<code>AlertDialog</code>有<code>WindowManager.LayoutParams.TYPE_SYSTEM_ALERT</code>属性，这应该是系统层面的东西吧，不依赖<code>Activity</code>。那有没有系统层面的进度条？好像没有。但是网上有说把<code>ProgressDialog</code>设置成<code>TYPE_SYSTEM_ALERT</code>或者<code>TYPE_TOAST</code>，一试确实OK。但是，这只是菜单而已。菜单运行良好了，但是实际上，OTA包体积很大，在<code>BootCompleteReceiver</code>跑拷贝动作的时候，发生<code>ANR</code>，最终没有跑到<code>RecoverySystem.installPackage</code>那里去，为啥，拷贝是在<code>BootCompleteReceiver</code>里面的<code>Handler</code>做的，网上查，说没有<code>new Thread</code>直接创建的<code>new handler</code>是<code>UI线程</code>，<code>UI线程</code>不能做耗时操作，但是为啥在阶段A的时候，在<code>Fragment</code>的<code>Handler</code>里面拷贝OTA包却没有问题？在广播里的<code>Handler</code>却有问题？不明白。查到说<a href="https://www.jianshu.com/p/34c8d5384f94">一个进程如果正在执行BroadcastReceiver的 onReceive() 方法，就会被当做一个前台进程，不易被系统杀死。当 onReceive() 执行完毕，BroadcastReceiver 就不再活跃，其所在进程会被系统当做一个空进程，随时有可能被系统杀死。</a>可能就是这个原因吧。<code>onReceive</code>都跑完了，<code>Handler</code>的拷贝动作还没有跑完。但是<code>Fragment</code>的话，一直在前台，所以不会被杀死。  </p>
</li>
<li><p>阶段C<br>改成<code>new Thread</code>行不行呢，没有尝试，估计不行。<code>Fragment</code>写一次，<code>BootCompleteReceiver</code>写一次，太蠢了。按照<a href="https://www.jianshu.com/p/34c8d5384f94">《如何在BroadcastReceiver中执行耗时操作》</a>这里说的，用<code>IntentService</code>，很好用，但是操作<code>ProgressDialog</code>还是用了<code>TYPE_SYSTEM_ALERT</code>属性。  </p>
</li>
</ul>
<p>但是如果启动了一个服务，这个服务没有对应的<code>Activity</code>，而服务需要刷新UI，怎么搞比较好呢？不能都用<code>TYPE_SYSTEM_ALERT</code>吧。  </p>
<p>纯小白，真惨啊。  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下Thread使用demo</title>
    <url>/2020/04/15/linux-thread-demo/</url>
    <content><![CDATA[<p>这里的场景是串口自发自收。  </p>
<span id="more"></span>


<p>先贴代码：  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readRet = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">CH_Factory_Uart_Selfcheck_Reading_Thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>{</span><br><span class="line">	SINT32 count = <span class="number">0</span>;</span><br><span class="line">	SINT32 port_id = <span class="number">0</span>;<span class="comment">// use uart 0</span></span><br><span class="line">	SINT32 read_len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[] = <span class="string">"changhong"</span>;</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">RHAL_UART_ReadUart</span>(port_id,(UINT8 *)buf,&amp;read_len,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">if</span>(read_len &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf,<span class="string">"changhong"</span>) == <span class="number">0</span>) {</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: count = %d, buf = %s, read_len = %d\n"</span>,__func__,__LINE__,count,buf,read_len);</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: OOOOOOOOOOOOOOOOK!\n"</span>,__func__,__LINE__);</span><br><span class="line">			readRet = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(count &gt; <span class="number">20</span>) {</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: ERRORRRRRRRRRRRR!\n"</span>,__func__,__LINE__);</span><br><span class="line">			readRet = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">pthread_exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSystemControl::CH_Factory_Uart_Check</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]\n"</span>,__func__,__LINE__);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    SINT32 read_len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"changhong"</span>;</span><br><span class="line">    SINT32 port_id = <span class="number">0</span>;<span class="comment">// use uart 0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> readThreadId;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"stop console"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">RHAL_UART_SelectUart</span>(port_id)!=<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;readThreadId, <span class="literal">NULL</span>, CH_Factory_Uart_Selfcheck_Reading_Thread, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">    ret = <span class="built_in">RHAL_UART_WriteUart</span>(port_id,(UINT8 *)buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret) </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"[%s] [%d]: write uart fail\n"</span>,__func__,__LINE__);</span><br><span class="line">		<span class="built_in">pthread_join</span>(readThreadId, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">RHAL_UART_SelectUart</span>(<span class="number">1</span>); <span class="comment">//switch back to UART1</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">pthread_join</span>(readThreadId, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RHAL_UART_SelectUart</span>(<span class="number">1</span>); <span class="comment">//switch back to UART1</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"start console"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!readRet)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上代码线程的点在于：  </p>
<ol>
<li><p>创建一个<code>ID</code>  </p>
<blockquote>
<p>pthread_t readThreadId;  </p>
</blockquote>
</li>
<li><p>创建了线程，<code>ID</code>与实际的线程函数匹配了  </p>
<blockquote>
<p>pthread_create(&amp;readThreadId, NULL, CH_Factory_Uart_Selfcheck_Reading_Thread, NULL);  </p>
</blockquote>
<p> <code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>就是被创建的线程，<code>ID</code>是<code>readThreadId</code>  </p>
</li>
<li><p>退出线程  </p>
<blockquote>
<p>pthread_join(readThreadId, NULL);  </p>
</blockquote>
<p> <code>pthread_join</code>会阻塞主线程，等待<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>结束。<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>是一个<code>while(1)</code>循环，当串口读到需要的数据时，通过<code>pthread_exit(0)</code>使线程内部结束，这个时候跳到主线程的<code>pthread_join</code>，<code>pthread_join</code>终于等到了<code>CH_Factory_Uart_Selfcheck_Reading_Thread</code>结束，主线程就可以继续跑下去了。  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>thread</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>USB Port Status</title>
    <url>/2020/04/22/usb-port-status/</url>
    <content><![CDATA[<p>需要检测平台的两路USB端口是否接入了设备。不太明白。  </p>
<span id="more"></span>


<p>网上翻了一遍，没找到安卓上层接口可以直接判断USB端口的状态，只能简单地获得USB设备的数量。类似这种:  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFirstUsbStoragePath</span><span class="params">(Context mContext)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> StorageVolume[] volumes = StorageManager.getVolumeList(mContext.getUserId(), StorageManager.FLAG_FOR_WRITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; volumes.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (volumes[i].getPathFile().getAbsolutePath().contains(<span class="string">"emulated"</span>)) {</span><br><span class="line">            <span class="comment">// ignore internal path</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            DebugLog.d(<span class="string">"USB storage path:"</span> + volumes[i].getPathFile() + <span class="string">"; index:"</span> + i);</span><br><span class="line">            <span class="keyword">return</span> volumes[i].getPathFile().getAbsolutePath();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>sda1</code>和<code>sdb1</code>也不能跟板卡的物理端口对应上，不知道怎么做。  </p>
<p>后来获悉原厂有如下做法：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getUsb1StorageState</span><span class="params">()</span> </span>{</span><br><span class="line">	File checkfile = <span class="keyword">null</span>;</span><br><span class="line">	checkfile = <span class="keyword">new</span> File(<span class="string">"/sys/bus/usb/devices/1-1:1.0"</span>);</span><br><span class="line">	<span class="keyword">if</span>(checkfile != <span class="keyword">null</span> &amp;&amp; checkfile.exists() &amp;&amp; checkfile.isDirectory())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getUsb2StorageState</span><span class="params">()</span> </span>{</span><br><span class="line">	File checkfile = <span class="keyword">null</span>;</span><br><span class="line">	checkfile = <span class="keyword">new</span> File(<span class="string">"/sys/bus/usb/devices/1-2:1.0"</span>);</span><br><span class="line">	<span class="keyword">if</span>(checkfile != <span class="keyword">null</span> &amp;&amp; checkfile.exists() &amp;&amp; checkfile.isDirectory())</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际拔插U盘：<br>当板卡两路USB都没有接上U盘时：  </p>
<blockquote>
<p>console:/ $ ls sys/bus/usb/devices/ -l<br>total 0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-0:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 2-0:1.0 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2/2-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb2 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2</p>
</blockquote>
<p>当板卡两路USB都接上U盘时：  </p>
<blockquote>
<p>console:/ $ ls sys/bus/usb/devices/ -l<br>total 0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-0:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-1:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-1/1-1:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-2:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-2/1-2:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.0 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 1-3:1.2 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1/1-3/1-3:1.2<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 2-0:1.0 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2/2-0:1.0<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb1 -&gt; ../../../devices/platform/usb/18013000.ehci_top/usb1<br>lrwxrwxrwx    1 0        0                0 Apr 22 07:54 usb2 -&gt; ../../../devices/platform/usb/18013400.ohci_top/usb2</p>
</blockquote>
<p>可看到两路USB分别对应<code>sys/bus/usb/devices/1-1</code>、<code>sys/bus/usb/devices/1-1:1.0</code>和<code>sys/bus/usb/devices/1-2</code>、<code>sys/bus/usb/devices/1-2:1.0</code>，并且能跟物理地址对应上。所以可以认为当U盘接入时，对应的文件就生成了。因此通过这个文件判断对应的USB Port是否有接上设备。  </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
        <tag>usb</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓生成二维码demo</title>
    <url>/2020/04/15/android-qrcode-demo/</url>
    <content><![CDATA[<p>举个栗子。  </p>
<span id="more"></span>

<ol>
<li><p>需要用到<code>zxing</code>这个库。<br>下载<code>core-3.4.0.jar</code>这个东西，修改<code>Android.mk</code>,将<code>core-3.4.0.jar</code>写到<code>LOCAL_STATIC_JAVA_LIBRARIES</code>和<code>LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES</code>，用于编译。  </p>
</li>
<li><p>添加二维码工具类<code>QRCodeUtils.java</code>  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.menu.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.WriterException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.QRCodeWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QRCodeUtils</span> </span>{</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"QRCodeUtil"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">createQRImage</span><span class="params">(String url, <span class="keyword">final</span> <span class="keyword">int</span> width, <span class="keyword">final</span> <span class="keyword">int</span> height)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span> (url == <span class="keyword">null</span> || <span class="string">""</span>.equals(url) || url.length() &lt; <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            Hashtable&lt;EncodeHintType, String&gt; hints = <span class="keyword">new</span> Hashtable&lt;EncodeHintType, String&gt;();</span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">            BitMatrix bitMatrix = <span class="keyword">new</span> QRCodeWriter().encode(url,</span><br><span class="line">                    BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">            <span class="keyword">int</span>[] pixels = <span class="keyword">new</span> <span class="keyword">int</span>[width * height];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) {</span><br><span class="line">                    <span class="keyword">if</span> (bitMatrix.get(x, y)) {</span><br><span class="line">                        pixels[y * width + x] = <span class="number">0xff000000</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        pixels[y * width + x] = <span class="number">0xffffffff</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(width, height,</span><br><span class="line">                    Bitmap.Config.ARGB_8888);</span><br><span class="line">            bitmap.setPixels(pixels, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        } <span class="keyword">catch</span> (WriterException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>制作菜单<br>略  </p>
</li>
<li><p>把二维码图片设置到菜单<br>二维码图片的内容是往<code>createQRImage</code>传入的字符串。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String allString = <span class="string">"helloworld"</span>;</span><br><span class="line">mImageView.setImageBitmap(QRCodeUtils.createQRImage(allString, <span class="number">128</span>, <span class="number">128</span>));</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>qrcode</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙扫描demo</title>
    <url>/2020/04/23/scan-bluetooth-device-demo/</url>
    <content><![CDATA[<p>安卓扫描附近的蓝牙设备。  </p>
<span id="more"></span>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.bluetoothtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.bluetooth.BluetoothAdapter;</span><br><span class="line"><span class="keyword">import</span> android.bluetooth.BluetoothDevice;</span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.net.ConnectivityManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.content.ContextCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"SystemInfoFragment"</span>;</span><br><span class="line">    <span class="keyword">private</span> ConnectivityManager mConnectivityManager;</span><br><span class="line">    <span class="keyword">private</span> BluetoothAdapter btAdapt;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mBluetoothList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mBluetoothList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        btAdapt = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(btAdapt.getState() != BluetoothAdapter.STATE_ON) {</span><br><span class="line">            btAdapt.enable();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mBluetoothList.clear();</span><br><span class="line">        <span class="keyword">if</span> (btAdapt.isDiscovering()) {</span><br><span class="line">            btAdapt.cancelDiscovery();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {</span><br><span class="line">                <span class="comment">//需要动态申请权限</span></span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, <span class="number">10</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        btAdapt.startDiscovery();</span><br><span class="line"></span><br><span class="line">        IntentFilter intent = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        intent.addAction(BluetoothDevice.ACTION_FOUND);</span><br><span class="line">        intent.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);</span><br><span class="line">        intent.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);</span><br><span class="line">        registerReceiver(scanBluetoothDevices, intent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(scanBluetoothDevices != <span class="keyword">null</span>) {</span><br><span class="line">            unregisterReceiver(scanBluetoothDevices);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (btAdapt.isDiscovering()) {</span><br><span class="line">            btAdapt.cancelDiscovery();</span><br><span class="line">        }</span><br><span class="line">        mBluetoothList.clear();</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BroadcastReceiver scanBluetoothDevices = <span class="keyword">new</span> BroadcastReceiver() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (action.equals(BluetoothDevice.ACTION_FOUND)) {</span><br><span class="line">                <span class="comment">//found device</span></span><br><span class="line">                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br><span class="line">                <span class="keyword">int</span> deviceType = device.getType();</span><br><span class="line">                String str = device.getName() + <span class="string">"("</span> + device.getAddress() + <span class="string">")"</span>;</span><br><span class="line">                Log.d(TAG, <span class="string">"found bluetooth device: "</span> + deviceType + <span class="string">" - "</span> + str);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mBluetoothList.indexOf(str) == -<span class="number">1</span>) {</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_CLASSIC)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_CLASSIC"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_LE)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_LE"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_DUAL)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_DUAL"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(deviceType == BluetoothDevice.DEVICE_TYPE_UNKNOWN)</span><br><span class="line">                        Log.d(TAG, <span class="string">"deviceType: DEVICE_TYPE_UNKNOWN"</span>);</span><br><span class="line"></span><br><span class="line">                    mBluetoothList.add(str);</span><br><span class="line">                    Log.d(TAG, <span class="string">"add bluetooth device: "</span> + str);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {</span><br><span class="line">                <span class="comment">//Scanning</span></span><br><span class="line">                Log.d(TAG, <span class="string">"start scanning bluetooth devices... "</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {</span><br><span class="line">                <span class="comment">//Scan Finished</span></span><br><span class="line">                Log.d(TAG, <span class="string">"scan bluetooth devices finished"</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"mBluetoothList size = "</span> + mBluetoothList.size());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>AndroidManifest.xml</code>需要添加如下权限：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>


<p>简单总结就是：先<code>startDiscovery()</code>，然后注册一个搜索监听广播<code>scanBluetoothDevices</code>。<br><code>startDiscovery()</code>这个接口能扫所有设备，包括经典蓝牙和BLE。<br>网上资料说，不设定扫描周期的话，默认12秒，但是实测并不都是12秒。<br>顺便一提，BLE最大的广播间隔是10.25秒。<br>顺便再提，蓝牙耳机都是经典蓝牙，BLE目前的协议是不支持音频传输的。  </p>
<p>遇到的问题：  </p>
<ol>
<li>编译不过。”error: cannot find symbol registerReceiver/unregisterReceiver”，当时是写在<code>Fragment</code>中，但是<code>Fragment</code>是没有这个方法的。最终在<code>onAttach(Activity activity)</code>中<code>activity.registerReceiver(scanBluetoothDevices, intent);</code>，在<code>onDetach()</code>中<code>getActivity().unregisterReceiver(scanBluetoothDevices);</code>。  </li>
<li>菜单上看到一些空白设备。当时以为是扫不到设备，检查打印才知道有扫到了，只是设备没有名字，所以就空白了，但是打印能看到有<code>mac</code>地址。  </li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi扫描demo</title>
    <url>/2020/04/23/scan-wifi-demo/</url>
    <content><![CDATA[<p>安卓扫描WiFi。  </p>
<span id="more"></span>


<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.wifitest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.ScanResult;</span><br><span class="line"><span class="keyword">import</span> android.net.wifi.WifiManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.ActivityCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.content.ContextCompat;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> WifiManager mWifiManager;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ScanResult&gt; mWifiList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {</span><br><span class="line">		<span class="comment">//需要动态申请权限</span></span><br><span class="line">                ActivityCompat.requestPermissions(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, <span class="number">10</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        mWifiManager = (WifiManager) <span class="keyword">this</span>.getSystemService(Context.WIFI_SERVICE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mWifiManager.isWifiEnabled()) {</span><br><span class="line">            mWifiManager.setWifiEnabled(<span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">        mWifiList.clear();</span><br><span class="line">        mWifiManager.startScan();</span><br><span class="line">        mWifiList = mWifiManager.getScanResults();</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"mWifiList.size(): "</span> + mWifiList.size());</span><br><span class="line">        <span class="keyword">if</span>(mWifiList.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mWifiList.size(); ++i) {</span><br><span class="line">                Log.d(TAG, <span class="string">"mWifiList["</span> + i + <span class="string">"].SSID : "</span> + mWifiList.get(i).SSID);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>AndroidManifest.xml</code>需要添加如下权限：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CHANGE_NETWORK_STATE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以上。  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统属性</title>
    <url>/2020/05/27/android-system-property/</url>
    <content><![CDATA[<p>来源网络</p>
<span id="more"></span>


<h3 id="属性的分类"><a href="#属性的分类" class="headerlink" title="属性的分类"></a>属性的分类</h3><p>ro开头的属性，表明该属性是只读的，一旦设置，不能更改。<br>persist开头的属性，表明该属性是可修改的，以persist开始的属性会在/data/property存一个副本。也就是说，如果程序调property_set设了一个以persist为前缀的属性，系统会在/data/property/persistent_properties记录这个属性，重启之后这个属性还会存在。<br>ctl.start和ctl.stop属性。用来启动和停止init.rc中定义的服务。<br>其他格式的属性都可修改，重启不保存，因为属性是在内存里存的，所以重启后这个属性就没有了。  </p>
<h3 id="属性的设置和获取"><a href="#属性的设置和获取" class="headerlink" title="属性的设置和获取"></a>属性的设置和获取</h3><p>Java  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line">SystemProperties.set(<span class="string">"persist.sys.miracast.hdcp2"</span>,”<span class="number">1</span>”);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SystemProperties.get(<span class="string">"persist.sys.miracast.hdcp2"</span>).equals(<span class="string">"1"</span>)) {</span><br><span class="line">    Log.d(TAG, <span class="string">"666"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Native  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/properties.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">property_get(<span class="string">"persist.sys.miracast.hdcp2"</span>, value, <span class="string">"1"</span>);</span><br><span class="line">property_set(<span class="string">"persist.sys.miracast.hdcp2"</span>, value);</span><br></pre></td></tr></tbody></table></figure>

<p>Shell  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">setprop persist.sys.miracast.hdcp2 0</span><br><span class="line">getprop persist.sys.miracast.hdcp2</span><br></pre></td></tr></tbody></table></figure>

<h3 id="属性的权限"><a href="#属性的权限" class="headerlink" title="属性的权限"></a>属性的权限</h3><p>程序要正确获取/设置权限，需要有system权限。  </p>
<ol>
<li>在AndroidManifest.xml中，在manifest加入android:sharedUserId=”android.uid.system”  </li>
<li>在Android.mk中，將LOCAL_CERTIFICATE := XXX修改成LOCAL_CERTIFICATE := platform  </li>
</ol>
<p>运行时候可能还会有“libc access denied finding property android”的问题，需要把相关avc denied的报错信息修掉  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>SELinux的问题</title>
    <url>/2020/05/27/selinux/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>在setenforce 0和配置了allow system_app self:udp_socket ioctl;后操作依然被denied，log信息如下：  </p>
<blockquote>
<p>08-07 10:49:20.149 4795 4795 I iwpriv: type=1400 audit(0.0:3457): avc: denied {ioctl} for path=”socket:[1607798]” dev=”sockfs” ino=1607798 ioctlcmd=8bfc scontext=u:r:system_app:s0 tcontext=u:r:system_app:s0 tclass=udp_socket permissive=1  </p>
</blockquote>
<p>这是由于ioctl的控制在底层划分得更细，需要允许对应ioctlcmd的操作。  </p>
<p>具体方法是：  </p>
<ol>
<li>查找对应的ioctlcmd在ioctl_defines(system/sepolicy/public/ioctl_defines)中的定义，如上文的8bfc，对应的是SIOCIWFIRSTPRIV_1C  </li>
<li>在对应的文件中加入如下的配置：<br> allowxperm system_app self:udp_socket ioctl SIOCIWFIRSTPRIV_1C;  </li>
</ol>
<p>这样，在ioctl操作时，对应的ioctlcmd就会被允许了。  </p>
<p>[参考]  </p>
<ul>
<li><a href="https://www.jianshu.com/p/66062e509d13">android selinux-170821</a>  </li>
<li><a href="https://blog.csdn.net/zxlworking1/article/details/85249796">Android SELinux配置</a>  </li>
</ul>
<p>不过还有一种更快的处理方法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">allow system_app self:udp_socket rw_file_perms;</span><br></pre></td></tr></tbody></table></figure>
<p><code>ioctl</code>直接改用<code>rw_file_perms</code>编译不报错，运行也不会有权限问题。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">define(`rw_file_perms<span class="string">', `{ ioctl read getattr lock write append }'</span>)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>This line defines the macros rw_file_perms which contains the permissions ioctl (for ioctl’s), read (read file), getattr (get attributes) and then lock, write and append.  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
        <tag>selinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开机任务和定时任务</title>
    <url>/2020/05/27/linux-task/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<h3 id="开机任务"><a href="#开机任务" class="headerlink" title="开机任务"></a>开机任务</h3><p>编辑<code>/etc/rc.local</code>文件，加上需要执行的命令。  </p>
<p>但是有的Linux版本没有这个文件，添加这个文件，依然能够生效：  </p>
<ol>
<li><p>添加这个文件  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></tbody></table></figure>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ifconfig ens33 192.168.52.128 netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>添加权限  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod 755 /etc/rc.local</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置启动  </p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart rc-local</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重启，开机任务有被执行  </p>
</li>
</ol>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">crontab -l #列出工作表里的命令</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">crontab -e #编辑定时工作表</span><br></pre></td></tr></tbody></table></figure>

<p><code>crontab</code>命令构成为<code>时间</code>+<code>动作</code>，时间有：  </p>
<ul>
<li>分(0-59)</li>
<li>时(0-23)</li>
<li>日(1-31)</li>
<li>月(1-12)</li>
<li>周(0-6，其中0代表星期日)</li>
</ul>
<p>操作符有：  </p>
<ul>
<li>* 取值范围内的所有数字  </li>
<li>/ 每过多少个数字，表示频率  </li>
<li>- 表示范围  </li>
<li>, 散列数字  </li>
</ul>
<p>举个例子：  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">*/360 * * * * /usr/sbin/ntpdate time.nist.gov # 时间同步，每隔六小时同步一次</span><br><span class="line">2 * * * * /home/foo/test.sh # 这个cron作业会在每天各小时的第2分钟执行脚本test.sh</span><br><span class="line">0 5,6,7 * * * /home/foo/test.sh # 每天的第5、6、7小时执行脚本</span><br><span class="line">0 2 * * * /sbin/shutdown -h # 在每天凌晨2点钟关闭计算机</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>dlopen failed处理</title>
    <url>/2020/07/15/dlopen-failed/</url>
    <content><![CDATA[<p>如题</p>
<span id="more"></span>


<p>使用的是Android7.1平台。<br>应用本来是系统预置的，但是有些客户需要做推送。使用U盘安装测试的时候，闪退。AndroidRuntime报错：  </p>
<blockquote>
<p>java.lang.UnsatisfiedLinkError: dlopen failed: library “/system/lib/librtk-mediaplayer_jni.so” needed<br>or dlopened by “/system/lib/libnativeloader.so” is not accessible for the namespace “classloader-namespace”  </p>
</blockquote>
<p>找到librtk-mediaplayer_jni.so在系统中的/system/lib目录，修改代码/system/core/libnativeloader/native_loader.cpp文件，把  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kWhitelistedDirectories = <span class="string">"/data:/mnt/expand"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>改成  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span>* kWhitelistedDirectories = <span class="string">"/data:/mnt/expand:/system/lib"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>编译、升级、测试，运行时有新的报错提示：  </p>
<blockquote>
<p>java.lang.UnsatisfiedLinkError: dlopen failed: library “libutils.so” not found  </p>
</blockquote>
<p>找到系统的/system/etc/public.libraries.txt文件，发现其中没有libutils.so，通过  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ su</span><br><span class="line">foo@bar:~$ mount -o rw,remount /</span><br><span class="line">foo@bar:~$ mount -o rw,remount /system</span><br><span class="line">foo@bar:~$ sed -i '1alibutils.so' /system/etc/public.libraries.txt</span><br><span class="line">foo@bar:~$ sync</span><br><span class="line">foo@bar:~$ reboot</span><br></pre></td></tr></tbody></table></figure>
<p>修改测试，继续有libnativehelper.so、librtk-mediaplayer.so找不到的报错，依次添加到public.libraries.txt，最后应用能正常使用了。<br>接着修改代码/system/core/rootdir/etc/public.libraries.android.txt，添加libutils.so、libnativehelper.so和librtk-mediaplayer.so，重新编译、升级、测试，运行OK。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://stackoverflow.com/questions/54234905/how-to-modify-vendor-etc-public-libraries-txt-when-building-pure-aosp">How to modify “vendor/etc/public.libraries.txt” when building pure AOSP</a>  </li>
<li><a href="https://www.cnblogs.com/Qunter/p/7485090.html">【Android N兼容问题】Android N上系统预置应用调用so库失败问题的看法</a>  </li>
<li><a href="https://www.jianshu.com/p/a4af2bdcc3c0">android N : java.lang.UnsatisfiedLinkError</a>  </li>
<li><a href="https://www.jianshu.com/p/4be3d1dafbec">Framework基础：Android N 公共so库怎么定义呢？</a>  </li>
<li><a href="https://blog.csdn.net/duan_xiaosu/article/details/81031174">Android 7.0以后 .so link 加载链接过程中 dlopen failed 问题</a>  </li>
<li><a href="https://segmentfault.com/a/1190000021461854">Android 动态链接库隔离</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>boot到kernel的传递</title>
    <url>/2020/08/03/uboot-kernel/</url>
    <content><![CDATA[<p>理解不深，简单记录一下。</p>
<span id="more"></span>


<p>新IC出来了，要移植配置，有个问题是，增减遥控器，无作用。遥控解码是在内核处理的，debug发现：配置里没有选上的遥控器，内核也有在解析，因为ir_table用的是内核里配置的，新ir_table不是在内核里面配置的，所以我们分离出来的定制配置没有效果，所以要把内核的ir_table改成由我们定制的配置的ir_table，那要怎么做呢？定制的新ir_table在上电的时候，在boot被解析，然后被填到<code>arch/arm/include/asm/arch-rtk/system.h</code>的这个地址<code>POWER_ON_IR_TABLE_ADDR</code>。这个地址出干嘛的：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory for power on music, video, and image. Include stream buffer and decode buffer */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_IR_TABLE_ADDR                  (0x1ffff000)    <span class="comment">// 0x1ffff000 ~ 0x20000000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_IR_TABLE_SIZE                  (0x1000 - 128 - 8)              <span class="comment">// 4k</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_KEYPAD_TABLE_ADDR              (POWER_ON_IR_TABLE_ADDR + POWER_ON_IR_TABLE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_ON_KEYPAD_TABLE_SIZE              (128 + 8)</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个是共享内存的物理地址，内核可以从这里拿到东西。  </p>
<p>但是内核怎么知道地址是多少？强制定义也可以（感觉不会有问题）。这里是通过<code>cmdline</code>把东西传给内核，看看boot的启动参数：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">console:/ # cat /proc/cmdline                                                  </span><br><span class="line">androidboot.console=ttyS1 console=ttyS1,115200 androidboot.dtbo_idx=0 bufsize=80000  envp=e4100 wdt=&lt;NULL&gt;  flashtype=emmc mmcparts=rtkemmc:304927k,2097152k(/super),4718592k(/userdata),281808k(/cache),1024k(/persist),1024k(/misc),16384k(/metadata),32768k(/boot),32768k(/recovery),8192k(/dtbo),16384k(/tvconfigs),32768k(/tvdata),24576k(/impdata),1024k(/vbmeta),65536k(/smarttv)  androidboot.boot_devices=18010800.emmc loop.max_part=7 buildvariant=userdebug initrd=0x10000000,0xbd000 keepinitrd reclaim=54M@40M last_image=8M@160M VIP=2M@766M OD=8M@768M bootcode_git_version=c422e6b no_console_suspend androidboot.vbmeta.device=179:13 androidboot.vbmeta.avb_version=1.1 androidboot.vbmeta.device_state=locked androidboot.vbmeta.hash_alg=sha256 androidboot.vbmeta.size=3968 androidboot.vbmeta.digest=7d27ba8f742e398b5827d4a1ab61aec26e4f0ee5192105877cad1e8ebb960359 androidboot.vbmeta.invalidate_on_error=yes androidboot.veritymode=enforcing androidboot.verifiedbootstate=green androidboot.hardware.sku=ATV00003919R01 loglevel=4 earlyprintk androidboot.bootreason=watchdog chip=RTD2851A chip_model=4K androidboot.serialno=001020304050 irda=1-hk irda_powerup=74,221,189,16e,2f5,2f6 irda1=7-hk dvfs_low=0xC6 dvfs_high=0xFD rtk_rcs=0x4eff000 ir_table=0x1ffff000</span><br></pre></td></tr></tbody></table></figure>

<p>可以找到ir_table=0x1ffff000，内核怎么做？<br>通过<code>early_param</code>解析拿到地址：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">venus_ir_input_table_addr_parse</span><span class="params">(<span class="keyword">char</span> *options)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ir_table_phy_address = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(options == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(options, <span class="string">"%lx"</span>, &amp;ir_table_phy_address) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    g_ir_boot_memory_address = ir_table_phy_address;</span><br><span class="line">    IR_INFO(<span class="string">"g_ir_boot_memory_address == %lx\n"</span>, g_ir_boot_memory_address);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">early_param(<span class="string">"ir_table"</span>, venus_ir_input_table_addr_parse);</span><br></pre></td></tr></tbody></table></figure>

<p>把物理地址转换成虚拟地址，并拿到ir_table：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">venus_ir_input_early_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *ir_boot_table = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//carvedout_buf_query(CARVEDOUT_IR_TABLE, &amp;ir_boot_table);</span></span><br><span class="line">    <span class="keyword">if</span>(g_ir_boot_memory_address) {</span><br><span class="line">        ir_boot_table = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)phys_to_virt (g_ir_boot_memory_address);</span><br><span class="line">	<span class="keyword">if</span>(!ir_boot_table) {</span><br><span class="line">	    g_ir_boot_memory_address = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	IR_INFO(<span class="string">"venus_ir_input__table_parse: %px, %x,%d\n"</span>, ir_boot_table, ir_boot_table[<span class="number">0</span>], ir_boot_table[<span class="number">1</span>]);</span><br><span class="line">	rwlock_init(&amp;g_ir_user_key_table.lock);</span><br><span class="line">	g_ir_user_key_table.keys = (IR_USER_KEY *)(ir_boot_table + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ir_boot_table[<span class="number">0</span>] == <span class="number">0x49525442</span> &amp;&amp;  ir_boot_table[<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; ir_boot_table[<span class="number">1</span>] &lt;= MAX_IR_USER_KEY_NUM) {</span><br><span class="line">	    g_ir_user_key_table.size = ir_boot_table[<span class="number">1</span>];</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">	    g_ir_user_key_table.size = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	g_ir_user_key_table.is_init = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.csdn.net/RyanLiu_/article/details/78925515">高通平台aboot通过shared memory保存uart log到kernel</a>  </li>
<li><a href="https://blog.csdn.net/sgmenghuo/article/details/41251739?utm_source=copy">linux驱动——cmdline原理及利用</a>  </li>
<li><a href="https://www.cnblogs.com/tlnshuju/p/6851812.html">linux kernel的cmdline參数解析原理分析</a>  </li>
<li><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/46711601">谈高端内存和低端内存</a>  </li>
<li><a href="https://blog.csdn.net/tienham/article/details/9493615">ioremap 和 phys_to_virt区别</a>  </li>
<li><a href="https://blog.csdn.net/angle_birds/article/details/8804033">Linux驱动修炼之道-内存映射 mmap()/phys_to_virt()</a>  </li>
<li><a href="https://wenku.baidu.com/view/0319a8c408a1284ac85043d4.html">虚拟地址转换为物理地址</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>boot</tag>
        <tag>kernel</tag>
        <tag>cmdline</tag>
      </tags>
  </entry>
  <entry>
    <title>HIDL demo</title>
    <url>/2020/08/04/hidl-demo/</url>
    <content><![CDATA[<p>简单记录，可以直接使用。</p>
<span id="more"></span>

<h3 id="1-添加hal目录、定义hal接口"><a href="#1-添加hal目录、定义hal接口" class="headerlink" title="1.添加hal目录、定义hal接口"></a>1.添加hal目录、定义hal接口</h3><figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir -p vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/IHello.hal</span><br></pre></td></tr></tbody></table></figure>

<p>接口如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//IHello.hal</span></span><br><span class="line"></span><br><span class="line">package vendor.realtek.hello@<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">interface IHello {</span><br><span class="line">    <span class="built_in">helloWorld</span> (string name) <span class="built_in">generates</span> (string result);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-根据hal自动生成cpp实现"><a href="#2-根据hal自动生成cpp实现" class="headerlink" title="2.根据hal自动生成cpp实现"></a>2.根据hal自动生成cpp实现</h3><figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ source build/envsetup.sh</span><br><span class="line">foo@bar:~$ lunch</span><br><span class="line">foo@bar:~$ make hidl-gen</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br><span class="line">foo@bar:~$ chmod u+x vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/hello/genImpHidl.sh</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//genImpHidl.sh</span><br><span class="line"></span><br><span class="line">PACKAGE=vendor.realtek.hello@1.0</span><br><span class="line">LOC=vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default</span><br><span class="line"></span><br><span class="line">hidl-gen -o $LOC -Lc++-impl -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces \</span><br><span class="line">    -randroid.hidl:system/libhidl/transport $PACKAGE</span><br><span class="line">hidl-gen -o $LOC -Landroidbp-impl -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces \</span><br><span class="line">    -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></tbody></table></figure>

<p>执行genImpHidl.sh后，default目录生成Android.bp、Hello.cpp和Hello.h文件。  </p>
<p><img src="https://i.loli.net/2020/08/04/KfyYMuRGtl16PSD.png" alt="1_genImplHidl.png">  </p>
<p>编写Hello.cpp  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/Hello.cpp</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Hello.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> your file license if you have one</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> vendor {</span><br><span class="line"><span class="keyword">namespace</span> realtek {</span><br><span class="line"><span class="keyword">namespace</span> hello {</span><br><span class="line"><span class="keyword">namespace</span> V1_0 {</span><br><span class="line"><span class="keyword">namespace</span> implementation {</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::vendor::realtek::hello::V1_0::IHello follow.</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">Hello::helloWorld</span><span class="params">(<span class="keyword">const</span> hidl_string&amp; name, helloWorld_cb _hidl_cb)</span> </span>{</span><br><span class="line">    <span class="comment">// TODO implement</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    ::<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    ::<span class="built_in">snprintf</span>(buf, <span class="number">100</span>, <span class="string">"Hello World, %s"</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="function">hidl_string <span class="title">result</span><span class="params">(buf)</span></span>;</span><br><span class="line">    _hidl_cb(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods from ::android::hidl::base::V1_0::IBase follow.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IHello* HIDL_FETCH_IHello(const char* /* name */) {</span></span><br><span class="line">    <span class="comment">//return new Hello();</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">}  <span class="comment">// namespace implementation</span></span><br><span class="line">}  <span class="comment">// namespace V1_0</span></span><br><span class="line">}  <span class="comment">// namespace hello</span></span><br><span class="line">}  <span class="comment">// namespace realtek</span></span><br><span class="line">}  <span class="comment">// namespace vendor</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>HIDL的实现有两种方式，如果打开HIDL_FETCH的注释，就是passthrough，否则是Binderized方式，这里使用默认的Binderized方式。  </p>
<h3 id="3-开机启动服务"><a href="#3-开机启动服务" class="headerlink" title="3.开机启动服务"></a>3.开机启动服务</h3><p>添加service.cpp文件；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/service.cpp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//service.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"vendor.realtek.hello@1.0-service"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vendor/realtek/hello/1.0/IHello.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hidl/HidlTransportSupport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Hello.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> android::hardware::configureRpcThreadpool;</span><br><span class="line"><span class="keyword">using</span> android::hardware::joinRpcThreadpool;</span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::IHello;</span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::implementation::Hello;</span><br><span class="line"><span class="keyword">using</span> android::sp;</span><br><span class="line"><span class="keyword">using</span> android::<span class="keyword">status_t</span>;</span><br><span class="line"><span class="keyword">using</span> android::OK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> vendor::realtek::hello::V1_0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> tune the max thread count.</span></span><br><span class="line">    <span class="built_in">configureRpcThreadpool</span>(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">    sp&lt;IHello&gt; mHello = <span class="keyword">new</span> <span class="built_in">Hello</span>();</span><br><span class="line">    <span class="keyword">status_t</span> status = mHello-&gt;<span class="built_in">registerAsService</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(status != OK, <span class="string">"Could not register IHello"</span>);</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">"IHello vendor.realtek.hello@1.0-service start\n"</span>);</span><br><span class="line">    <span class="comment">// other interface registration comes here</span></span><br><span class="line">    <span class="built_in">joinRpcThreadpool</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>添加<a href="mailto:vendor.realtek.hello@1.0-service.rc">vendor.realtek.hello@1.0-service.rc</a>文件；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/vendor.realtek.hello@1.0-service.rc</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">//vendor.realtek.hello@1.0-service.rc</span><br><span class="line">service hello-1-0 /vendor/bin/hw/vendor.realtek.hello@1.0-service</span><br><span class="line">    class hal</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br></pre></td></tr></tbody></table></figure>

<p>修改Android.bp；  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/default/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">//hello/1.0/default/Android.bp</span><br><span class="line"></span><br><span class="line">// FIXME: your file license if you have one</span><br><span class="line"></span><br><span class="line">cc_library_shared {</span><br><span class="line">    // FIXME: this should only be -impl for a passthrough hal.</span><br><span class="line">    // In most cases, to convert this to a binderized implementation, you should:</span><br><span class="line">    // - change '-impl' to '-service' here and make it a cc_binary instead of a</span><br><span class="line">    //   cc_library_shared.</span><br><span class="line">    // - add a *.rc file for this module.</span><br><span class="line">    // - delete HIDL_FETCH_I* functions.</span><br><span class="line">    // - call configureRpcThreadpool and registerAsService on the instance.</span><br><span class="line">    // You may also want to append '-impl/-service' with a specific identifier like</span><br><span class="line">    // '-vendor' or '-&lt;hardware identifier&gt;' etc to distinguish it.</span><br><span class="line">    name: <span class="string">"vendor.realtek.hello@1.0-impl"</span>,</span><br><span class="line">    relative_install_path: <span class="string">"hw"</span>,</span><br><span class="line">    // FIXME: this should be 'vendor: true' for modules that will eventually be</span><br><span class="line">    // on AOSP.</span><br><span class="line">    proprietary: true,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"Hello.cpp"</span>,</span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"libhidltransport"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cc_binary {</span><br><span class="line">    name: <span class="string">"vendor.realtek.hello@1.0-service"</span>,</span><br><span class="line">    defaults: [<span class="string">"hidl_defaults"</span>],</span><br><span class="line">    proprietary: true,</span><br><span class="line">    relative_install_path: <span class="string">"hw"</span>,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"Hello.cpp"</span>,</span><br><span class="line">	<span class="string">"service.cpp"</span></span><br><span class="line">    ],</span><br><span class="line">    init_rc: [<span class="string">"vendor.realtek.hello@1.0-service.rc"</span>],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">	<span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"libhidltransport"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"libcutils"</span>,</span><br><span class="line">	<span class="string">"libbinder"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-生成hal接口的Android-bp"><a href="#4-生成hal接口的Android-bp" class="headerlink" title="4.生成hal接口的Android.bp"></a>4.生成hal接口的Android.bp</h3><p>看下update-makefiles.sh内容是什么：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">source system/tools/hidl/update-makefiles-helper.sh</span><br><span class="line"></span><br><span class="line">do_makefiles_update \</span><br><span class="line">    "vendor.realtek:vendor/realtek/common/ATV/hardware/interfaces" \</span><br><span class="line">    "android.hidl:system/libhidl/transport"</span><br></pre></td></tr></tbody></table></figure>

<p>执行该脚本：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/update-makefiles.sh</span><br></pre></td></tr></tbody></table></figure>

<p>1.0目录就生成了Android.bp文件。  </p>
<p><img src="https://i.loli.net/2020/08/04/zIsYiW4gtxKh5Ue.png" alt="2_update-makefiles.png">  </p>
<h3 id="5-更新哈希值"><a href="#5-更新哈希值" class="headerlink" title="5.更新哈希值"></a>5.更新哈希值</h3><p>编写genHash.sh  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br><span class="line">foo@bar:~$ chmod u+x vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br><span class="line">foo@bar:~$ ./vendor/realtek/common/ATV/hardware/interfaces/hello/genHash.sh</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">PACKAGE=vendor.realtek.hello@1.0::IHello</span><br><span class="line"></span><br><span class="line">hidl-gen -L hash -rvendor.realtek:vendor/realtek/common/ATV/hardware/interfaces/ -randroid.hidl:system/libhidl/transport $PACKAGE</span><br></pre></td></tr></tbody></table></figure>

<p>把输出的hash添加到current.txt  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim ./vendor/realtek/common/ATV/hardware/interfaces/current.txt</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-添加client测试"><a href="#6-添加client测试" class="headerlink" title="6.添加client测试"></a>6.添加client测试</h3><p>添加如下目录和文件：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir -p vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional/VtsHalHelloV1_0TargetTest.cpp</span><br><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/1.0/vts/functional/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>以下是其内容：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">cc_test {</span><br><span class="line">    name: <span class="string">"VtsHalHelloV1_0TargetTest"</span>,</span><br><span class="line">    defaults: [<span class="string">"hidl_defaults"</span>],</span><br><span class="line">    srcs: [<span class="string">"VtsHalHelloV1_0TargetTest.cpp"</span>],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libbase"</span>,</span><br><span class="line">	<span class="string">"libhidlbase"</span>,</span><br><span class="line">	<span class="string">"liblog"</span>,</span><br><span class="line">	<span class="string">"libutils"</span>,</span><br><span class="line">	<span class="string">"vendor.realtek.hello@1.0"</span>,</span><br><span class="line">    ],</span><br><span class="line">    static_libs: [<span class="string">"VtsHalHidlTargetTestBase"</span>],</span><br><span class="line">    cflags: [</span><br><span class="line">        <span class="string">"-O0"</span>,</span><br><span class="line">	<span class="string">"-g"</span>,</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//VtsHalHelloV1_0TargetTest.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"HelloHidlHalTest"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;VtsHalHidlTargetTestBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android-base/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vendor/realtek/hello/1.0/IHello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> vendor::realtek::hello::V1_0::IHello;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_string;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::hidl_vec;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line"><span class="keyword">using</span> ::android::hardware::Void;</span><br><span class="line"><span class="keyword">using</span> ::android::sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    sp&lt;IHello&gt; hello = IHello::<span class="built_in">getService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hello == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"Failed to get hello service\n"</span>);</span><br><span class="line">	ret = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        hello-&gt;<span class="built_in">helloWorld</span>(<span class="string">"Hikari"</span>, [&amp;](hidl_string result) {</span><br><span class="line">	    <span class="built_in">ALOGD</span>(<span class="string">"%s\n"</span>,result.<span class="built_in">c_str</span>());</span><br><span class="line">	});</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-添加hello目录的Android-bp"><a href="#7-添加hello目录的Android-bp" class="headerlink" title="7.添加hello目录的Android.bp"></a>7.添加hello目录的Android.bp</h3><p><span style="color:red"> 跑update-makefiles.sh的时候为啥没有生成这个？ </span> 跟rtk代码makefile架构有关吗。</p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim vendor/realtek/common/ATV/hardware/interfaces/hello/Android.bp</span><br></pre></td></tr></tbody></table></figure>

<p>内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">// This is an autogenerated file, do not edit.</span><br><span class="line">subdirs = [</span><br><span class="line">    <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="string">"1.0/vts/functional"</span>,</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-小编"><a href="#8-小编" class="headerlink" title="8.小编"></a>8.小编</h3><p>hello最终文件架构如下：<br><img src="https://i.loli.net/2020/08/04/jSbq4dc63CHeI7D.png" alt="3_end.png">  </p>
<p>小编试试添加的hello能不能编过：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mmm vendor/realtek/common/ATV/hardware/interfaces/hello/</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-注册hello并添加进编译"><a href="#9-注册hello并添加进编译" class="headerlink" title="9.注册hello并添加进编译"></a>9.注册hello并添加进编译</h3><p>注册：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/manifest.xml</span><br></pre></td></tr></tbody></table></figure>

<p>添加内容如下：  </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">"hidl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>vendor.realtek.hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>IHello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>编译：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/product/rtk_base.mk</span><br></pre></td></tr></tbody></table></figure>

<p>添加内容如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    vendor.realtek.hello@1.0 \</span><br><span class="line">    vendor.realtek.hello@1.0-impl \</span><br><span class="line">    vendor.realtek.hello@1.0-impl \</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-添加seLinux规则"><a href="#10-添加seLinux规则" class="headerlink" title="10.添加seLinux规则"></a>10.添加seLinux规则</h3><p>如果没有此步骤，开机之后<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>会跑不起来。<br>修改file_contexts文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/file_contexts</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：</p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/(vendor|system/</span>vendor)<span class="regexp">/bin/</span>hw/vendor\.realtek\.hello@<span class="number">1</span>\.<span class="number">0</span>-service        u:object_r:hal_hello_default_exec:s0</span><br></pre></td></tr></tbody></table></figure>

<p>修改hwservice_contexts文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hwservice_contexts</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：  </p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">vendor<span class="selector-class">.realtek</span><span class="selector-class">.hello</span>::IHello        u:object_r:hal_hello_service:s0</span><br></pre></td></tr></tbody></table></figure>

<p>修改hwservice.te文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hwservice.te</span><br></pre></td></tr></tbody></table></figure>
<p>补充如下：  </p>
<figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">hal_hello_service,   </span>hwservice_manager_type;</span><br></pre></td></tr></tbody></table></figure>

<p>添加hal_hello_default.te文件  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ vim device/realtek/common/sepolicy/hal_hello_default.te</span><br></pre></td></tr></tbody></table></figure>
<p>内容如下：  </p>
<figure class="highlight ceylon"><table><tbody><tr><td class="code"><pre><span class="line">type hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>, domain;</span><br><span class="line">type hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span><span class="number">_</span>exec, exec<span class="number">_</span>type, vendor<span class="number">_f</span>ile<span class="number">_</span>type, file<span class="number">_</span>type;</span><br><span class="line"></span><br><span class="line">init<span class="number">_</span>daemon<span class="number">_</span>domain(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>);</span><br><span class="line"></span><br><span class="line">hwbinder<span class="number">_u</span>se(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>)</span><br><span class="line">add<span class="number">_</span>hwservice(hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span>, hal<span class="number">_</span>hello<span class="number">_</span>service)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hwservicemanager<span class="number">_p</span>rop:file r<span class="number">_f</span>ile<span class="number">_p</span>erms;</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hwservicemanager:binder { transfer call };</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hal<span class="number">_</span>hello<span class="number">_</span>service:binder call;</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hal<span class="number">_</span>hello<span class="number">_</span>service:hwservice<span class="number">_m</span>anager { add find };</span><br><span class="line">allow hal<span class="number">_</span>hello<span class="number">_</span><span class="keyword">default</span> hidl<span class="number">_</span>base<span class="number">_</span>hwservice:hwservice<span class="number">_m</span>anager add;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>到此为止，开机之后服务依然有可能跑不起来，可以dmesg查看权限相关的avc报错，把相关的报错修掉之后，还有可能跑不起来，直接运行./vendor/bin/hw/<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>，把avc denied修掉，应该就可以了。如果不确定是不是权限问题引起，可以先setenforce 0后直接运行服务，如果能跑起来，那么就是权限有问题。另外，客户端调用的时候如果看不到效果，可以先用client（参考第6点）调试。  </p>
<h3 id="11-全编代码验证"><a href="#11-全编代码验证" class="headerlink" title="11.全编代码验证"></a>11.全编代码验证</h3><p>开机可以看到<a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>的log：  </p>
<blockquote>
<p>01-01 01:01:03.490   328   328 I ServiceManagement: Registered <a href="mailto:vendor.realtek.hello@1.0">vendor.realtek.hello@1.0</a>::IHello/default (start delay of 261ms)<br>01-01 01:01:03.491   328   328 I ServiceManagement: Removing namespace from process name <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a> to <a href="mailto:hello@1.0-service">hello@1.0-service</a>.<br>01-01 01:01:03.491   328   328 D <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a>: IHello <a href="mailto:vendor.realtek.hello@1.0-service">vendor.realtek.hello@1.0-service</a> start  </p>
</blockquote>
<p>在data/nativetest/VtsHalHelloV1_0TargetTest目录可以找到VtsHalHelloV1_0TargetTest文件，这个就是测试client，执行这个程序：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ ./data/nativetest/VtsHalHelloV1_0TargetTest/VtsHalHelloV1_0TargetTest</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到：  </p>
<blockquote>
<p>08-04 10:06:24.211  2063  2063 D HelloHidlHalTest: Hello World, Hikari  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>demo</tag>
        <tag>hidl</tag>
      </tags>
  </entry>
  <entry>
    <title>新建分区</title>
    <url>/2020/08/05/new-android-partition/</url>
    <content><![CDATA[<p>可能有遗漏。  </p>
<span id="more"></span>


<p>添加分区，修改kernel/android/android-10/vendor/realtek/tool/image_file_creator/configs/Frigga_2851a.cfg，添加  </p>
<figure class="highlight apache"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">part14</span> = smarttv /smarttv ext<span class="number">4</span> package<span class="number">7</span>/smarttv.tar.bz<span class="number">2</span> <span class="number">67108864</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>编译系统升级测试，这个时候，执行cat /proc/partitions应该能看到新添加的分区，但是df -h却看不到这个分区有挂载上来；  </p>
<p>需要一个挂载点，文件系统根目录需要一个smarttv目录，用于挂载，  </p>
<p>修改system/core/rootdir/Android.mk文件，添加如下：  </p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">LOCAL_POST_INSTALL_CMD += ; mkdir -p <span class="variable">$(TARGET_ROOT_OUT)</span>/smarttv</span><br></pre></td></tr></tbody></table></figure>

<p>添加目录权限，修改device/realtek/common/sepolicy/file_contexts，添加如下：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#smarttv partition</span></span><br><span class="line"><span class="regexp">/smarttv(/</span>.*)?          u:object_r:rtk_data_file:s0</span><br></pre></td></tr></tbody></table></figure>

<p>光有挂载点还不够，挂载规则呢？需要修改device/realtek/common/root/rtd2851a/fstab.gsi<br>添加如下：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line"><span class="regexp">/dev/</span>block<span class="regexp">/by-name/</span>smarttv    /smarttv      ext4 noatime,defaults               defaults</span><br></pre></td></tr></tbody></table></figure>

<p>还需要挂载动作，这个在device/realtek/common/root/rtd2851a/init.gsi.rc已经做好了：  </p>
<figure class="highlight awk"><table><tbody><tr><td class="code"><pre><span class="line">on fs</span><br><span class="line">    mount_all <span class="regexp">/system/</span>etc/fstab.gsi</span><br></pre></td></tr></tbody></table></figure>

<p>系统起来需要执行一次restorecon_recursive /smarttv，用于重新加载sepolicy context，否则分区可能无法正常读写，会有  </p>
<blockquote>
<p>[2020/11/9 星期一 9:27:02] 01-01 00:00:19.826   338   338 D SmartTVService: SmartTvInit::SmartTvInit<br>[2020/11/9 星期一 9:27:02] 01-01 00:00:19.809   338   338 W vendor.realtek.: type=1400 audit(0.0:15): avc: denied { search } for name=”/“ dev=”mmcblk0p14” ino=2 scontext=u:r:hal_smarttv_default:s0 tcontext=u:object_r:unlabeled:s0 tclass=dir permissive=0  </p>
</blockquote>
<p>这种报错信息。  </p>
<p>修改device/realtek/common/root/rtd2851a/init.rtd2851a.rc  </p>
<figure class="highlight dart"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">on</span> <span class="keyword">late</span>-fs</span><br><span class="line">    restorecon_recursive /tvconfigs</span><br><span class="line">    restorecon_recursive /smarttv</span><br></pre></td></tr></tbody></table></figure>
<p>注意restorecon_recursive这个动作要做在mount之后。  </p>
<p>编译系统升级测试，df -h应该能看到新建的分区挂载信息。  </p>
<p>完。  </p>
<p>[参考]<br><a href="https://blog.csdn.net/ZC_25/article/details/104027721">[AOSP]Android 9.0添加分区unlabeled的原因分析及解决办法</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>TV一些概念</title>
    <url>/2020/09/09/tv/</url>
    <content><![CDATA[<p>一些名词或概念。  </p>
<span id="more"></span>


<h3 id="AVC-AVL"><a href="#AVC-AVL" class="headerlink" title="AVC/AVL"></a>AVC/AVL</h3><p>自动音量控制。电视节目中的音频信号由于片源出自不同的电视台和采编单位，导致其音频水平不固定，因此容易出现在不调节电视音量的情况下，有的电视节目声音很大，有的电视节目又声音很小。使用AVC功能后，电视机可以根据节目输入的音量大小，自动调节输出音量水平，保持声音的稳定，减少或消除爆音，同时放大较小的声音至适宜的范围。  </p>
<h3 id="PreScale"><a href="#PreScale" class="headerlink" title="PreScale"></a>PreScale</h3><p>由于各个通道原始音量不尽相同，会先透过PreScale将各通道音量调整一致。  </p>
<h3 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h3><ul>
<li>行消隐：电子束在每一行从右边回到左边的时间  </li>
<li>场消隐：电子束从每一场的右下角回到左上角的时间。在场消隐期间可能输出一些CC或者TT等信息  </li>
</ul>
<h3 id="解调"><a href="#解调" class="headerlink" title="解调"></a>解调</h3><ul>
<li>高频头把射频信号解调成中频信号  </li>
<li>中频解调把中频信号解调成视频信号  </li>
<li>声音解调把SIF解调成声音信号  </li>
</ul>
<h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>Closed Caption：美国在VBI里面传输的字幕信息，帮助聋哑人看电视  </p>
<h3 id="MTS"><a href="#MTS" class="headerlink" title="MTS"></a>MTS</h3><p>一个通用称呼，所有多声道伴音均可称作MTS。  </p>
<ul>
<li>NICAM是数字多声道伴音广播  </li>
<li>BTSC是模拟多声道伴音广播  </li>
<li>A2  </li>
<li>EIAJ  </li>
</ul>
<h3 id="AGC"><a href="#AGC" class="headerlink" title="AGC"></a>AGC</h3><p>自动增益控制。自动对增益进行控制来得到稳定的输出幅度。  </p>
<ul>
<li>在高频头内部，有射频AGC和中频AGC，来针对从40dBuV到100dBuV的射频信号都得到相近的中频输出  </li>
<li>在视频解码芯片内部，有视频AGC来针对不同幅度的视频信号进行增益控制，得到相同的信号输出。也就是说，不论你输入300mVpp还是1.5Vpp的视频信号，得到的输出幅度都是相等的  </li>
<li>对色度信号处理时，有AGC来完成类似的处理  </li>
</ul>
<p>ADC内部是没有AGC的，所以RGB信号和色差信号都被认为是标准幅度而不会进行AGC控制。  </p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>复合视频信号：包含同步信号、亮度信号、色度信号  </li>
<li>CVBS：复合视频基带信号  </li>
<li>分量信号：通常在数字领域称作YCbCr(Digital color difference signals)，模拟领域称作YPbPr(Analog color difference signals)<br><img src="https://i.loli.net/2020/09/09/KRrwjhmNSOe3YJs.png" alt="差分信号.png">  </li>
</ul>
<h3 id="DDC"><a href="#DDC" class="headerlink" title="DDC"></a>DDC</h3><p>指主机与显示设备的通讯方式。包括DDC1/DDC2B/DDC2B+等方式。目前主要采用DDC2B方式：主机与显示设备双向通讯，基于I2C协议，只有主机向显示器发出需求信号，并得到显示器的响应后，显示器才送出EDID资料。  </p>
<h3 id="Auto-Color"><a href="#Auto-Color" class="headerlink" title="Auto Color"></a>Auto Color</h3><p>VGA和YPBPR通道需要人爲做AUTO COLOR， 其它AV/S-VIDEO/TV通道是通過Video Decode內的digital clamping和digital gain做實時調整，不需要用人爲AUTO COLOR的方式。  </p>
<p>原理：在三路R/G/B or Y/Pb/Pr 模拟信号输入到主芯片时，由于存在硬件上的偏差，导致进入到芯片的信号范围和标准值有一定的差别，所以需要对输入信号进行ADC 校正，校验需要使100% colorbar图像，以保证进到主芯片的模拟输入信号符合标准；共有R/G/B GAIN（增益量）和R/G/B OFFSET（偏移量）六个参数。  </p>
<h3 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h3><ul>
<li>PCM数据：指经过解码后的数据或未经编码的裸数据  </li>
<li>透传数据：指编码数据没经过解码，直接封装IEC61937协议后往端口输出，由外围设备解码。透传数据分为低码率透传数据（简称LBR，主要有DD、DTS）和高码率透传数据（简称HBR，主要有DDP、DTSHD）。  </li>
</ul>
<h3 id="电视机的同步范围"><a href="#电视机的同步范围" class="headerlink" title="电视机的同步范围"></a>电视机的同步范围</h3><p>电视机的同步范围是指同步信号能够控制扫描电路的频率范围，要求行同步保持范围（图像保持同步的范围）在正负400Hz之间，行同步引入范围（从断开至接入信号时，图像引入同步范围）在正负200Hz之间，帧同步范围为-4~2Hz，保持同步的电源电压变化范围不超过正负10%。  </p>
<p>对于电视机的行扫描电路来说，当电视机的行频fH在某一频率范围内时，只要有同步脉冲存在，即使由于干扰而失去同步，也还能被“拉回”到与同步脉冲相同步的状态，这个行频fH的范围叫捕捉范围；当电视机已处于同步状态时，慢慢改变行频，在失去同步之前能够保持同步的fH范围叫保持范围。由于电视机中设有行频自动控制（AFC）电路，所以它的行频保持范围大于捕捉范围，如果没有AFC系统，则电视机的行频捕捉范围和保持范围是相同的。我国广播电视接收机的标准规定，甲级和乙级电视机的行同步捕捉范围分别为不小于正负400Hz和正负200Hz，行同步的保持范围分别为不小于正负800Hz和正负400Hz。  </p>
<h3 id="丽音"><a href="#丽音" class="headerlink" title="丽音"></a>丽音</h3><p>属于立体音的一种。  </p>
<ul>
<li>单声道方式： 两个声道分别传送一路声音信号和一路数据  </li>
<li>双语言方式： 传两路声音信号，适合于多语言、语种地区  </li>
<li>立体音方式： 两个数字通道分别传送立体声左右两个声道的声音信号  </li>
</ul>
<h3 id="Overscan"><a href="#Overscan" class="headerlink" title="Overscan"></a>Overscan</h3><p>过扫描。在电视系统中，为避免元器件的老化或者参数变化导致的影响，必须有一定的过扫描。也就是说，扫描的大小超过显示屏的大小，四周有一小部分的图像看不到。  </p>
<p>如果没有过扫描，在图像亮度变化时，由于束流变化，会导致图像扫描的区域变化，从而导致图像变小或者变大，显像管四周出现黑边。为避免这种情况，就需要一定的过扫描。  </p>
<p>点对点比例模式不做Overscan。  </p>
<p>USB/DVI/VGA通道不做Overscan。VGA是接电脑的，不是看电视用的；相当于在用电脑；电脑信号也不会出现杂波干扰。  </p>
<p><a href="https://wenku.baidu.com/view/bbb35dafd0f34693daef5ef7ba0d4a7302766c32.html">什么是点对点显示</a>  </p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.codenong.com/cs106786798">模拟电视ATV常见知识点</a>  </li>
</ul>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
      </tags>
  </entry>
  <entry>
    <title>HDMI相关</title>
    <url>/2020/09/08/hdmi/</url>
    <content><![CDATA[<p>简单记录相关知识点。  </p>
<span id="more"></span>


<h2 id="PIN"><a href="#PIN" class="headerlink" title="PIN"></a>PIN</h2><p>HDMI引脚定义如图：<br><img src="https://i.loli.net/2020/09/08/m68ojqtpgZ9Ifn4.jpg" alt="HDMI引脚定义.jpg"><br><img src="https://i.loli.net/2020/09/08/jxsLhZ5eEn68VaT.jpg" alt="HDMI端子.jpg">  </p>
<p>其中  </p>
<ul>
<li>1-9是TMDS数据传输实际上用到的引脚，一共3组  </li>
<li>10-12为TMDS时钟信号  </li>
<li>13为CEC控制引脚  </li>
<li>14为保留引脚  </li>
<li>15-16是I2C引脚，用于DDC传输，DDC通道除了用作EDID信息的传输，还用来做HDCP的验证，其对应I2C写地址一般是0x74。EDID的I2C写地址0xA0  </li>
<li>17接地  </li>
<li>18为5V供电  </li>
<li>19为Hotplug引脚  </li>
</ul>
<h2 id="Hotplug"><a href="#Hotplug" class="headerlink" title="Hotplug"></a>Hotplug</h2><p>热插拔，当接上接口时就可以判断设备是否存在，以进行后续工作。  </p>
<p>当计算机通过HDMI接口与显示器相连接时，主机通过HDMI的18脚向显示器供电，显示器接收到+5V电压后，通过内部电路使HDMI接口第19脚HPD转变为高电平，主机检测到HPD为高电平后，认为主机与显示器已经连接上，于是通过I2C读取显示器的EDID，满足条件后（比如显示器支持主机当前设置的分辨率），做HDCP交互认证，然后TMDS发送电路开始工作，输出图像和声音。  </p>
<p>其中有两种Hotplug相关的情况会导致HDMI被识别为DVI：  </p>
<ul>
<li>Hotplug为High，不过EDID并没有准备好，那么信号源设备会由于无法读到EDID而认为接收设备为DVI，这样会导致HDMI有图像无声的问题。  </li>
<li>Hotplug为Low，也会导致信号源无法读到EDID而认为接收设备为DVI，从而导致HDMI有图无声。  </li>
</ul>
<p>在TV这种有多个HDMI通道的情况下，有时会在多个HDMI通道进行切换，切换后HDMI通道应当先初始化，即先把Hotplug拉低，通知HDMI source device之前所用的EDID已经改变，需要重新读取，那么source device在Hotplug被拉高的时候会去读取新的EDID，但是拉低这个过程至少需要100ms，否则source device有可能不会去读取新的EDID，从而输出DVI信号。  </p>
<h2 id="EDID"><a href="#EDID" class="headerlink" title="EDID"></a>EDID</h2><p>相当于一个身份证，告诉主机，此显示器的参数、支持的特征。包括基本EDID和扩展EDID。存在于程序，由系统初始化，或存在与EEPROM。    </p>
<ul>
<li><p>EDID中有一块数据是VSDB（Vendor-Specific Data Block），如果包含IEEE分配给HDMI的固定数值，则认为是HDMI，否则被认为是DVI。<br>HDMI1.4b 的 VSDB (H14b VSDB): 第一个Byte，Length至少是5，最多31；接下来3个Byte是IEEE分配给HDMI的固定数值：030C00h；随后2个Byte是物理地址。以上是至少包含的信息，后续内容为Extension Field。<br><img src="https://i.loli.net/2020/09/08/YramXM9hlvwRT5b.png" alt="vsdb1.4.png"><br>HDMI2.0 的 VSDB (HF-VSDB): 第1个Byte，Length至少是5，最多31；接下来3个Byte是IEEE分配给HDMI的固定数值：D85DC4h；随后1个Byte是物理地址。以上是至少包含的信息，后续内容为Extension Field。<br><img src="https://i.loli.net/2020/09/08/yx9krTW7vdwBAIe.png" alt="vsdb2.0.png"><br>注意HF—VSDB不能与H14b VSDB相混淆、即使接收端支持HDMI2.0版本，也必须包含H14b VSDB（由HDMI H1.4b）定义，在E-EDID中是否包含是可选的。<br><img src="https://i.loli.net/2020/09/08/58NWlSXLdgszGJh.png" alt="vsdb.png">  </p>
</li>
<li><p>EDID中有一块数据描述了CEC物理地址。  </p>
</li>
</ul>
<h2 id="CEC"><a href="#CEC" class="headerlink" title="CEC"></a>CEC</h2><p>允许用户控制HDMI接口上所连接的设备。  </p>
<p>在HDMI CEC最小系统里，所有通过HDMI连接在一起的设备（包括电视、DVD、机顶盒等）在物理连接上，各自的CEC是全部连接在一起，可以看做，在一条CEC线（标准HDMI接口的第13引脚）上挂着所有的设备。  </p>
<p>Youtube上的一堂CEC课，讲得很不错。  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Q6S2FabX2WA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>  

<h3 id="Handshake"><a href="#Handshake" class="headerlink" title="Handshake"></a>Handshake</h3><p>当一个带CEC功能的设备得到一个新的物理地址时，它将进行如下处理：</p>
<ol>
<li>主动申请分配与之设备类型相应的逻辑地址；  </li>
<li>通过广播<report physical="" address="">来报告它的物理地址与逻辑地址的绑定。  </report></li>
</ol>
<p><img src="https://i.loli.net/2020/09/08/U2xWgmBi4ktYTue.png" alt="CEC Physical Address.png"><br><img src="https://i.loli.net/2020/09/08/mGKIQEc9rLuOwgB.png" alt="CEC Physical Address Discovery.png"><br>Physical Address: Root display(TV) is always 0.0.0.0<br>Logical Address: Root display(TV) is always 0<br><img src="https://i.loli.net/2020/09/08/Jr1HthQoIkSEyY3.png" alt="CEC addressing.png"></p>
<p>CEC设备的逻辑地址也是动态分配的，其分配方式如下：  </p>
<ol>
<li>根节点（通常是TV）直接设逻辑地址：0；  </li>
<li>当设备A插入后，该设备的类型是已知的，因此可以为该设备A预设一个逻辑地址（如DVD，其预设地址为DVD1，即是4），并通过<polling message="">广播此地址；  </polling></li>
<li>当该逻辑地址已经被占用时，对应的占用设备会应答确认信息。设备A收到确认后，重设其他逻辑地址（如：DVD1-&gt;DVD2），并广播<polling message="">；  </polling></li>
<li>当检测到没有确认时，此逻辑地址可用，因此设备A占用此逻辑地址；  </li>
<li>占用后，发送广播<report physical="" address="">，其中包含了其物理地址和逻辑地址，声明对地址的占用。若询问一圈后，逻辑地址均被占用，则设备A的逻辑地址为15。  </report></li>
</ol>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>总线保持高电平是闲态（IDLE）；<br>要发送消息，看总线是否空闲？如果是，则拉低总线电平，发送，否则，延迟发送；<br>一条CEC具体传输的指令：起始信号（一个3.7ms低电平+一个0.8ms高电平）+头部数据（起始设备的逻辑地址+接收设备的逻辑地址）+操作码+操作数。  </p>
<p>因为，所有设备的CEC都挂在一条线上，所以，大家都能看到所有指令。如果头部数据里的接收逻辑地址是和自己相关的，此设备就会对操作码进行响应，如果头部数据里的接收逻辑地址和自己无关，此设备就忽略这个指令。  </p>
<p>CEC通信信息结构模块包括：Header引导块和Data数据块。所有的Header块和Data块都是10bit大小。  </p>
<p>Header = 源逻辑地址(source) + 目的逻辑地址(destination) + 信息结束位(EOM) + 应答位(ACK)<br>Data = 操作码(opcode)/操作数(operand) + EOM(End of Message) + ACK(Acknowledge)<br>EOM: 0表示还有一个或更多的数据块，1表示消息已完整<br><img src="https://i.loli.net/2020/09/08/qz5T7dAIv9inhM3.png" alt="CEC Message Structure.png"><br><img src="https://i.loli.net/2020/09/08/gsplSfNFZCeovx3.png" alt="CEC Protocol.png">  </p>
<p>例子：Standby指令：起始信号+00FF+0x36；其中，00表示电视的逻辑地址，FF表示广播地址，这里表示所有接收设备的集合，36表示Standby待机操作。此条指令可以翻译为：电视告诉所有设备，大家都进入待机状态。  </p>
<h2 id="HDCP"><a href="#HDCP" class="headerlink" title="HDCP"></a>HDCP</h2><p>HDCP用于保护版权视频，通过DDC传输。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.znds.com/forum.php?mod=viewthread&amp;tid=825004&amp;page=1">干货知识：一篇文看懂HDMI1.0到HDMI2.1的规格变化</a><br><a href="https://www.cnblogs.com/TaigaCon/p/3840653.html">HDMI介绍与流程</a><br><a href="https://www.cnblogs.com/zhongguo135/p/9197995.html">HDMI之HPD</a><br><a href="https://www.cnblogs.com/zhongguo135/p/9458884.html">HDMI EDID 处理过程</a>  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>edid</tag>
        <tag>hdmi</tag>
        <tag>cec</tag>
      </tags>
  </entry>
  <entry>
    <title>搜台与解析</title>
    <url>/2020/09/10/tuning/</url>
    <content><![CDATA[<p>搜台与解析的概念。  </p>
<span id="more"></span>


<h2 id="搜台"><a href="#搜台" class="headerlink" title="搜台"></a><strong>搜台</strong></h2><h3 id="两种搜台方式"><a href="#两种搜台方式" class="headerlink" title="两种搜台方式"></a>两种搜台方式</h3><h4 id="AFT"><a href="#AFT" class="headerlink" title="AFT"></a>AFT</h4><p>自动频率微调电路。主要是依据AFT反馈电压来判别当前频点与正确频点的接近情况。它的任务是保证图像中频信号的频率固定在规定的38MHz标准值上，从而使图像及伴音处于最佳状态。  </p>
<p>获得AFT反馈电压的两种方式：  </p>
<ol>
<li>外接比较电路。当图像中频偏离38MHz时，AFT电路检测这种频率偏移，并将频率偏移转换成直流误差控制电压，去调节本振电路的震荡频率，使图像中频恢复到38MHz上。  </li>
<li>Tuner内置AD，通过I2C从Tuner芯片中获得。  </li>
</ol>
<h4 id="AFC"><a href="#AFC" class="headerlink" title="AFC"></a>AFC</h4><p>自动频率控制。在搜台过程中，频率进入AFC可控范围前提下，通过读取Tuner的AFC状态寄存器，来判断当前频点与正确频点相差多少，从而直接加减相应的频点即可。<br>这种搜台算法与AFT算法相比，搜台会更快更准。  </p>
<p><img src="https://i.loli.net/2020/09/09/fldZ8jAH1FeuNI5.png" alt="变频的方法.png">  </p>
<p>总结：<br>写Tuner频点，检测同步信号输入端，判断是否存在稳定的同步信号，如果存在，判断AFT电压是否为标准值/Tuner AFC状态寄存器，如果是，则存台，判断图像、声音制式并进行相应设置，该频点搜台结束。  </p>
<p>无法搜台：<br>排查信号是否正常，Tuner是否能正常初始化，Tuner I2C通信是否正常，Tuner的晶振、中频和AGC管脚配置是否和硬件一致。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wenku.baidu.com/view/bd0cefd133d4b14e85246882.html">Tuner搜台基础</a><br><a href="https://wenku.baidu.com/view/168d33e60975f46527d3e126.html">电视机搜台原理</a><br><a href="https://wenku.baidu.com/view/3b771f8b84868762caaed514">自动搜台原理</a>  </p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h2><h3 id="TS流"><a href="#TS流" class="headerlink" title="TS流"></a>TS流</h3><ul>
<li>ES流：基本码流，不分段的音频、视频或其他信息的连续码流。  </li>
<li>PES流： 把基本流ES分割成段，并加上相应头文件打包成形的打包基本码流。  </li>
<li>PS流： 节目流，将具有共同时间基准的一个或多个PES组合（复合）而成的单一数据流（用于播放或编辑系统，如m2p）。  </li>
<li>TS流： 传输流，将具有共同时间基准或独立时间基准的一个或多个PES组合（复合）而成的单一数据流（用于数据传输）。  </li>
</ul>
<p>TS流的包结构长度是固定的，PQ流的包结构长度是可变的，TS流的抵抗传输误码能力强于PS流。  </p>
<p>视频ES和音频ES分别打包成视频PES和音频PES，PES再复用成TS传输流。  </p>
<p>TS流是基于Packet的位流格式，由n个包组成。每个包由Packet Header和Packet Data组成。其中Packet Header指示了该Packet是什么属性的，并给出了该Packet Data的数据的唯一网络标识符PID。如果一个TS流中的一个Packet的Packet Header中的PID是0x0000，那么这个Packet的Packet Data就是DVB的PAT表而非其他类型数据（如Video、Audio或其他业务信息）。  </p>
<h3 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h3><h4 id="业务与事件"><a href="#业务与事件" class="headerlink" title="业务与事件"></a>业务与事件</h4><p>按照普通人的习惯来说，CCTV1是一个频道，但其标准说法应该是“业务(Service)”，《新闻联播》是一个节目，其标准说法是“事件(Event)”。  </p>
<p>“Channel”指的是“频点”或者“信道”，每个“Channel”里会有一个或多个“Service”。  </p>
<h4 id="PSI-SI-Table"><a href="#PSI-SI-Table" class="headerlink" title="PSI/SI Table"></a>PSI/SI Table</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">全称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PAT</td>
<td align="left">节目关联表</td>
<td align="left">将节目号码和节目映射表PID相关联，获取数据的开始</td>
</tr>
<tr>
<td align="left">PMT</td>
<td align="left">节目映射表</td>
<td align="left">指定一个或多个节目的PID</td>
</tr>
<tr>
<td align="left">CAT</td>
<td align="left">条件接收表</td>
<td align="left">将一个或多个专用EMM流分别与唯一的PID相关联</td>
</tr>
<tr>
<td align="left">NIT</td>
<td align="left">网络信息表</td>
<td align="left">描述整个网络，如多少TS流、频点和调制方式等信息</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2020/09/09/put7hxKGnPaQFE9.png" alt="SI.png">  </p>
<p>PSI只提供了单个TS流的信息，使接收机能够对单个TS流中的不同节目进行解码。 但是，它不能提供多个TS流的相关业务，也不能提供节目的类型、节目名称、开始时间、节目简介等信息。 因此，DVB对PSI进行了扩展，提供了其他不同类型的表，形成了SI。  </p>
<p>SI定义的表，并不需要全部传输， 其中，SDT、EIT和TDT是必须传输的； 而又以SDT和EIT最为重要，利用这2个表可以构成功能不同的EPG， 如提供节目附加信息、节目分类、节目预定和家长分级控制等。  </p>
<p>通过PAT及其他PSI信息，我们可以一点一点地把整个TS流的信息组织和管理起来，从而分离出不同的业务(Service)， 以及该业务的视频、音频、图文(Teletext)、字幕(Subtitle)、其他音轨等分量；再根据SI信息，我们就可以得到每个业务的名称、事件(Event)等附加信息，从而形成EPG，更好地管理各个业务。  </p>
<p>Decoder在解析TS流的时候进行数据的同步，等待完整的Packet到来，首先寻找PAT表，根据PAT获取所有PMT表的PID；再寻找PMT表，获取该频段所有节目数据并保存。 这样，只需要知道节目的PID就可以根据PacketHeade给出的PID过滤出不同的Packet，从而观看不同的节目。 这些就是PAT表和PMT表之间的关系。  </p>
<h4 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h4><ul>
<li>PAT表描述TS流中有几个节目，以及它们的PMT PID分别是多少。通过program_map_PID找到了对应的PMT表。  </li>
<li>PMT表给出了节目号与组成这个节目元素之间的映射。通过program_number与SDT表中的service_id关联起来。    </li>
<li>NIT：搜索主频点的同时解析NIT表，就可以得到这个网络的频点列表，按顺序对这个列表的频点锁频、解析，就可以将整个网络的业务搜索出来。  </li>
<li>CAT表描述了节目的加密方式。  </li>
<li>SDT表将节目名称和该节目的PID对应起来。描述业务内容及信息，连接了NIT、EIT和PMT。    </li>
<li>EIT表按时间顺序提供每一个业务所包含的事件信息。通过service_id与SDT表中的service_id以及PMT表的program_number关联起来。  </li>
<li>TDT表仅传送UTC时间和日期信息。  </li>
<li>TOT表包含了UTC时间和日期信息，以及当地时间偏移（时差）等信息。  </li>
<li>BAT表将网络中的所有业务分成了多个业务群，以此界定用户。  </li>
</ul>
<p><img src="https://i.loli.net/2020/09/09/PEXyujYZ24xVUMh.png" alt="SI关联.png">  </p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.onelib.biz/doc/stb/">林晓州OneLib智库</a>  </p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>scan</tag>
        <tag>tuning</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/09/14/quick-sort/</url>
    <content><![CDATA[<p>快速排序，基本思想是：通过一趟排序将要排序的数据分割成独立两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序数列。  </p>
<span id="more"></span>


<p><span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>一趟快速排序的算法是：  </p>
<ol>
<li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；  </li>
<li>以第一个数组元素作为关键数据，赋值给key，即key=A[0]；  </li>
<li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的A[j]，将A[j]的值赋给A[i]；  </li>
<li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]的值赋给A[j]；  </li>
<li>重复第3、4步，直到i=j。  </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> tmp = src[left];</span><br><span class="line">	src[left] = src[right];</span><br><span class="line">	src[right] = tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partArray</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> pivot = src[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; src[high] &gt;= pivot)</span><br><span class="line">		{</span><br><span class="line">			high--;</span><br><span class="line">		}</span><br><span class="line">		swap(src,low,high);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; src[low] &lt;= pivot)</span><br><span class="line">		{</span><br><span class="line">			low++;</span><br><span class="line">		}</span><br><span class="line">		swap(src,low,high);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_quick_sort</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> pivot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(low &lt;= high)</span><br><span class="line">	{</span><br><span class="line">		pivot = partArray(src,low,high);</span><br><span class="line">		do_quick_sort(src,low,pivot<span class="number">-1</span>);</span><br><span class="line">		do_quick_sort(src,pivot+<span class="number">1</span>,high);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> src[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	do_quick_sort(src, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">int</span> a[] = {<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="number">4</span>;</span><br><span class="line">        quick_sort(a,length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"a[%d] = %d\n"</span>,i,a[i]);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>c</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TV 蓝牙遥控适配</title>
    <url>/2020/09/17/android-bluetooth-remote/</url>
    <content><![CDATA[<p>HID(Human Interface Device)设备，即人机交互设备。常见的有鼠标、键盘、游戏手柄等。一般有线方式都是通过USB连线连接到机器设备，作为用户输入设备。在蓝牙技术中，HID设备的接入就是无线的。所以客户的蓝牙遥控器也是HID设备，本文记录蓝牙遥控器适配方法。  </p>
<span id="more"></span>


<p>通过客户提供的文档或者<code>getevent</code>命令（遥控跟TV需要先匹配上）确定遥控的HID码值（不是红外码值），比如按下语音键会得到如下信息：<br><code>getevent</code>:  </p>
<blockquote>
<p>/dev/input/event3: 0004 0004 000c0221<br>/dev/input/event3: 0001 00d9 00000001<br>/dev/input/event3: 0000 0000 00000000<br>/dev/input/event3: 0004 0004 000c0221<br>/dev/input/event3: 0001 00d9 00000000<br>/dev/input/event3: 0000 0000 00000000  </p>
</blockquote>
<p><code>getevent -l</code>:  </p>
<blockquote>
<p>/dev/input/event3: EV_MSC       MSC_SCAN             000c0221<br>/dev/input/event3: EV_KEY       KEY_SEARCH           DOWN<br>/dev/input/event3: EV_SYN       SYN_REPORT           00000000<br>/dev/input/event3: EV_MSC       MSC_SCAN             000c0221<br>/dev/input/event3: EV_KEY       KEY_SEARCH           UP<br>/dev/input/event3: EV_SYN       SYN_REPORT           00000000  </p>
</blockquote>
<p>通过上述打印可以得到如下信息：<br>0221是这个按键的HID码值，page类型是000c，00d9是这个Linux的键值（对应了KEY_SEARCH这个名字，这个名字起得很疑惑，明明是语音功能<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。  </p>
<p>KEY_SEARCH是在kernel/linux/linux-4.14/include/uapi/linux/input-event-codes.h这个文件定义的：  </p>
<blockquote>
<p>#define KEY_SEARCH              217  </p>
</blockquote>
<p>十进制的217就是等于十六进制的d9。  </p>
<p>通过kernel/linux/linux-4.14/drivers/hid/hid-input.c这个文件:  </p>
<blockquote>
<p>case 0x221: map_key_clear(KEY_SEARCH);          break;  </p>
</blockquote>
<p>把HID码值跟Linux键值匹配在一起。  </p>
<p>蓝牙键值有不同类型，“07”代表普通蓝牙键值，“0C”代表多媒体键值，“0C”类型需要修改hid-input.c的<code>HID_UP_CONSUMER</code>，“07”类型则需要修改<code>hid_keyboard[256]</code>。  </p>
<p>现在知道了HID码值（0x0221）及其对应的Linux键值(0xd9)(217)了，但是功能实现还需要Android键值。Linux键值与Android键值是通过<code>kl</code>文件匹配的。怎么知道是哪个kl文件？  </p>
<p>通过<code>cat /proc/bus/input/devices</code>命令确认遥控器的<code>Vendor</code>ID和<code>Product</code>ID  </p>
<blockquote>
<p>I: Bus=0005 Vendor=1d5a Product=c081 Version=0000<br>N: Name=”H016A001”<br>P: Phys=<br>S: Sysfs=/devices/virtual/misc/uhid/0005:1D5A:C081.0001/input/input3<br>U: Uniq=20:19:10:23:00:f6<br>H: Handlers=event3<br>B: PROP=0<br>B: EV=12001f<br>B: KEY=1 8000000 0 3007f 0 0 0 0 403ffff 17aff32d bf540446 0 0 1 130f97 8b17e007 ffff7bfa d9415fff febeffd7 ffefffff ffffffff fffffffe<br>B: REL=40<br>B: ABS=1 0<br>B: MSC=10<br>B: LED=3ff  </p>
</blockquote>
<p>所以需要的kl文件是：Vendor_1d5a_Product_c081.kl<br>该文件有如下信息：  </p>
<blockquote>
<p>key 217   VOICE_ASSIST  </p>
</blockquote>
<p>Android Framework会把VOICE_ASSIST转化成Android键值，实现对应的功能。<br>Framework改到的文件有如下4个：<br><img src="https://i.loli.net/2020/09/17/x5E4wOcneVz7BJ9.png" alt="android_keycode.png">  </p>
<p>到此，基本适配完成了。  </p>
<p>另外，dumpsys input还可以得到如下信息：  </p>
<blockquote>
<p>4: H016A001<br>Classes: 0x80000121<br>Path: /dev/input/event3<br>Enabled: true<br>Descriptor: 83b91aadd3b6814a870f118082cde683c34f199e<br>Location:<br>ControllerNumber: 0<br>UniqueId: 20:19:10:23:00:f6<br>Identifier: bus=0x0005, vendor=0x1d5a, product=0xc081, version=0x0000<br>KeyLayoutFile: /system/usr/keylayout/Vendor_1d5a_Product_c081.kl<br>KeyCharacterMapFile: /system/usr/keychars/Generic.kcm<br>ConfigurationFile:<br>HaveKeyboardLayoutOverlay: false  </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>bluetooth</tag>
        <tag>hid</tag>
      </tags>
  </entry>
  <entry>
    <title>定义新的Property</title>
    <url>/2020/11/19/customize-property/</url>
    <content><![CDATA[<p>自定义新属性。<dd23>  </dd23></p>
<span id="more"></span>


<p><span class="github-emoji"><span>👇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  </p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>希望新增自定义的属性，单纯使用  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">android.os.SystemProperties.set(<span class="string">"json.smarttv.config.order.backlight.home"</span>,<span class="string">"80"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>会报错：  </p>
<blockquote>
<p>libc    : Unable to set property “json.smarttv.config.order.backlight.home” to “80”: error code: 0x18  </p>
</blockquote>
<p>需要在device/realtek/common/sepolicy/property_contexts定义自己的属性  </p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">json. </span>                          u:object_r:<span class="keyword">json_prop:s0 </span> </span><br></pre></td></tr></tbody></table></figure>

<p>在device/realtek/common/sepolicy/property.te定义新增加的json_prop域  </p>
<figure class="highlight ada"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">json_prop, </span>property_type;  </span><br></pre></td></tr></tbody></table></figure>

<p>重新编译运行，可能还会有错。<br>可能还需要补充权限，比如：<br>修改device/realtek/common/sepolicy/hal_smarttv_default.te：  </p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">set<span class="constructor">_prop(<span class="params">hal_smarttv_default</span>, <span class="params">json_prop</span>)</span>;  </span><br><span class="line">get<span class="constructor">_prop(<span class="params">hal_smarttv_default</span>, <span class="params">json_prop</span>)</span>;  </span><br></pre></td></tr></tbody></table></figure>
<p>修改device/realtek/common/sepolicy/system_app.te：  </p>
<figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line">allow system_app json_prop:file { read open getattr map };  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.itread01.com/content/1546437184.html">system.prop新增自己的欄位</a><br><a href="https://my.oschina.net/u/4339087/blog/3306403">Android coredomain 如何使用自定义的 property type？</a>  </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>编译<code>user</code>版本的image，添加的<code>property</code>属性无法在console通过<code>getprop</code>获得，但是查看out/target/product/RealtekATV/system/build.prop文件却有这些属性，可能与<code>selinux</code>规则有关，把这些属性修改到system/sepolicy/private/property_contexts</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ro.yndx.build           u:object_r:system_prop:s0</span><br><span class="line">yndx.config             u:object_r:system_prop:s0</span><br></pre></td></tr></tbody></table></figure>
<p>OK，但是不知道为什么：  </p>
<ol>
<li><a href="https://source.android.google.cn/security/selinux/device-policy?hl=zh-cn">编写 SELinux 政策</a>  </li>
<li><a href="https://lishiwen4.github.io/android/selinux-security-context">SELinux 安全上下文</a>  </li>
<li><a href="https://gaozhipeng.me/posts/permissive-domain-in-userbuild/">permissive domains not allowed in user builds</a>  </li>
<li><a href="https://www.jianshu.com/p/e95cd0c17adc">Android 9 SELinux</a>  </li>
<li><a href="https://source.android.com/security/selinux/customize?hl=zh-cn%5C">自定义 SELinux</a>  </li>
</ol>
<h3 id="深入理解SELinux-SEAndroid"><a href="#深入理解SELinux-SEAndroid" class="headerlink" title="深入理解SELinux SEAndroid"></a>深入理解SELinux SEAndroid</h3><ul>
<li><a href="https://blog.csdn.net/Innost/article/details/19299937">第一部分</a>  </li>
<li><a href="https://blog.csdn.net/Innost/article/details/19641487">第二部分</a>  </li>
<li><a href="https://blog.csdn.net/Innost/article/details/19767621">第三部分</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>Android:一个菜单刷新很慢的问题</title>
    <url>/2020/10/30/android-ui-update-slowly/</url>
    <content><![CDATA[<p>低端打工人之日常疑惑。  </p>
<span id="more"></span>


<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>一个串口自动化测试程序：<br>是一个服务：<code>FactoryAutomationService</code> （FactoryAutomationService.java文件）<br>服务启动之后准备创建子线程：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> FactoryUartThread mFacUartThread;  </span><br><span class="line">mFacUartThread = <span class="keyword">new</span> FactoryUartThread(<span class="keyword">this</span>);  </span><br><span class="line">mFacUartThread.startChangHongUartThread();  </span><br></pre></td></tr></tbody></table></figure>

<p>具体创建了子线程：（FactoryUartThread.java文件）  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Thread changhongUartThread;  </span><br><span class="line">changhongUartThread = <span class="keyword">new</span> Thread(ChangHongUartTest);  </span><br><span class="line">changhongUartThread.start();  </span><br></pre></td></tr></tbody></table></figure>

<p>子线程主要干的事情是<code>handleChangHongFactoryCommand</code>:  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable ChangHongUartTest = <span class="keyword">new</span> Runnable() {  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">while</span> (RunChangHongUartThread) {  </span><br><span class="line">	    <span class="comment">//...  </span></span><br><span class="line">	    handleChangHongFactoryCommand(ReceiveBuffer);  </span><br><span class="line">	    <span class="comment">//...  </span></span><br><span class="line">	}  </span><br><span class="line">    }  </span><br><span class="line">};  </span><br></pre></td></tr></tbody></table></figure>

<p><code>handleChangHongFactoryCommand</code>里面拿到正常的数据后，要刷新菜单，这个时候通过<code>handler</code>切换主线程去刷新菜单，如果有一些耗时的比如保存数据等操作，则还是在原来的子线程上操作。<br>如果测试完毕，要关闭<code>FactoryAutomationService</code>服务了，会关子线程，  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">changhongUartThread.join();  </span><br></pre></td></tr></tbody></table></figure>
<p><code>join()</code>会阻塞主线程，等子线程结束，保证数据存储完成，主线程可以继续跑下去。  </p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>在子线程<code>handleChangHongFactoryCommand</code>中有如下代码：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法1</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下：</span></span><br><span class="line"><span class="comment">    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">    mHandlerComands.post(new Runnable() {</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">	public void run() {</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "AAA");</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">	    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">    });</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        Log.d(TAG, <span class="string">"BBB"</span>);</span><br><span class="line">	GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储。按理说不应切到主线程？</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>以上写法，菜单要等一会才会被刷新出来。<br>稍作修改：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法2</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下:</span></span><br><span class="line"><span class="comment">    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">    mHandlerComands.post(new Runnable() {</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">	public void run() {</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "AAA");</span></span><br><span class="line"><span class="comment">	    Log.d(TAG, "System.currentTimeMillis() = " + System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">	    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">	}</span></span><br><span class="line"><span class="comment">    });</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储</span></span><br></pre></td></tr></tbody></table></figure>

<p>菜单刷新就很及时，为什么？<br>正常来说，耗时操作应该放在子线程，所以要按照写法2写代码。<br>但是如果按照写法1的话，为什么菜单刷新变慢了？看打印是先打印AAA，再打印BBB，刷新菜单的操作没有被存储数据的操作阻塞，那么它是堵在哪？不懂啊。  </p>
<p>顺便一提，无论是写法1还是写法2，System.currentTimeMillis()时间差都是25左右。  </p>
<p>再修改下：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写法3</span></span><br><span class="line">saveChangHongColorTemp(getcommand[<span class="number">2</span>]); <span class="comment">//刷新菜单</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    刷新菜单的实现如下：</span></span><br><span class="line"><span class="comment">    showRGBValue(cTyte, r_value, g_value, b_value);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mHandler.post(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        GetSys().SetValueInt(<span class="string">"Misc_PRE_SAVE_TEMP_VALUE"</span>, getcommand[<span class="number">2</span>]&amp;<span class="number">0xFF</span>); <span class="comment">//数据存储</span></span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>这样，菜单刷新跟写法2一样快。但是风险点在于子线程刷新UI，以及把耗时操作放到主线程。  </p>
<p>总结起来就是：刷新菜单和存储数据不在同一个线程，菜单就能正常刷新。菜单刷新在主线程，数据存储在子线程，所以写法2较为更为合理。  </p>
<p>问题在于，写法1是怎么阻塞的？可能要了解一下handler原理？  </p>
<h4 id="rocket"><a href="#rocket" class="headerlink" title=":rocket:"></a><span class="github-emoji"><span>🚀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f680.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>判断是否是主线程还是子线程：  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getId()) == Looper.getMainLooper().getThread().getId();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>thread</tag>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title>Android10 super.img解包方法</title>
    <url>/2020/11/19/extract-super-img/</url>
    <content><![CDATA[<p>如题。  </p>
<span id="more"></span>


<p>对于super.img，这份Android10的代码提供了system/extras/partition_tools工具，mmm system/extras/partition_tools会在out/host/linux-x86/bin目录（全编代码后，out/host/linux-x86/bin/目录下的工具基本齐全了。登录终端后，进android代码根目录执行source build/envsetup.sh;lunch后，lpunpack这些命令都可以直接像系统命令跑 了，不用加路径）生成lpdump、lpflash、lpmake、lpunpack文件。其中：  </p>
<ul>
<li>lpdump displays pretty-printed partition metadata.  </li>
<li>lpflash writes a non-sparse image from lpmake to a block device.   </li>
<li>lpmake is a command-line tool for generating a “super” partition image.  </li>
<li>lpunpack is a command-line tool for extracting partition images from super.  </li>
</ul>
<p>直接解编译出来的super.img包看看：<br>执行命令：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpunpack super.img  </span><br></pre></td></tr></tbody></table></figure>
<p>得到  </p>
<blockquote>
<p>lpunpack E 11-19 17:09:36 233504 233504 reader.cpp:77] [liblp]Logical partition metadata has invalid geometry magic signature.<br>lpunpack E 11-19 17:09:36 233504 233504 reader.cpp:77] [liblp]Logical partition metadata has invalid geometry magic signature.<br>This image appears to be a sparse image. It must be unsparsed to be unpacked.  </p>
</blockquote>
<p>解包失败，需要将super.img转换成unsparsed格式。  </p>
<p>Android提供了system/core/libsparse工具，mmm system/core/libsparse可在out/host/linux-x86/bin目录得到simg2img文件，这个工具可以将sparse格式转换成unsparsed格式。  </p>
<p>先转换格式：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ simg2img super.img super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>再解包：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpunpack super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>得到odm.img、product.img、system.img、vendor.img这4个文件。  </p>
<p>顺便用lpdump工具dump一下unsparsed格式的super.img，执行命令：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ lpdump super.raw.img  </span><br></pre></td></tr></tbody></table></figure>

<p>可以得到：  </p>
<blockquote>
<p>Metadata version: 10.0<br>Metadata size: 592 bytes<br>Metadata max size: 65536 bytes<br>Metadata slot count: 2<br>Partition table:  </p>
<hr>
<p>  Name: system<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 1734399 linear super 2048  </p>
<hr>
<p>  Name: vendor<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 496975 linear super 1736704  </p>
<hr>
<p>  Name: product<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 664919 linear super 2234368  </p>
<hr>
<p>  Name: odm<br>  Group: realtek_dynamic_partitions<br>  Attributes: readonly<br>  Extents:<br>    0 .. 1295 linear super 2899968  </p>
<hr>
<h2 id="Block-device-table"><a href="#Block-device-table" class="headerlink" title="Block device table:  "></a>Block device table:  </h2><p>  Partition name: super<br>  First sector: 2048<br>  Size: 2147483648 bytes<br>  Flags: none  </p>
<hr>
<h2 id="Group-table"><a href="#Group-table" class="headerlink" title="Group table:  "></a>Group table:  </h2><p>  Name: default<br>  Maximum size: 0 bytes<br>  Flags: none  </p>
<hr>
<p>  Name: realtek_dynamic_partitions<br>  Maximum size: 2147483648 bytes<br>  Flags: none  </p>
<hr>
</blockquote>
<p>确实是有这4个分区。  </p>
<p>看下文件属性：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ file *  </span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>odm.img:       Linux rev 1.0 ext2 filesystem data, UUID=e1cf857c-334d-40cb-aa89-7634b14a39a2, volume name “odm” (extents) (large files) (huge files)<br>product.img:   Linux rev 1.0 ext2 filesystem data, UUID=9e1933ad-3f1b-4441-a314-f95987dc6c29, volume name “product” (extents) (large files) (huge files)<br>super.img:     data<br>super.raw.img: data<br>system.img:    Linux rev 1.0 ext2 filesystem data, UUID=3dab5a90-e84d-4e0c-a1e1-cc8779c3e0b2 (extents) (large files) (huge files)<br>vendor.img:    Linux rev 1.0 ext2 filesystem data, UUID=830ef149-3c4e-4455-ad55-f80faad5c8e1, volume name “vendor” (extents) (large files) (huge files)  </p>
</blockquote>
<p>如果查看各个分区的文件？<br>Linux rev 1.0 ext2 filesystem data 这个类型的文件可以直接mount：  </p>
<figure class="highlight console"><table><tbody><tr><td class="code"><pre><span class="line">foo@bar:~$ mkdir vendor_partition; mount vendor.img vendor_partition  </span><br></pre></td></tr></tbody></table></figure>

<p>或者在Windows平台用7zip工具直接打开（右键-&gt;7-Zip-&gt;打开压缩包）。  </p>
<p>至此，算是解包完成了。  </p>
<p>最后贴一个纯Windows平台的教程：  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/J5cQdzivtXk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>  

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>jq使用</title>
    <url>/2021/05/31/jq/</url>
    <content><![CDATA[<p>使用<code>json</code>做客制化配置，一开始每份客制化用一份<code>json</code>配置，直接用复制替换的方式切换，虽然不高明但是很实用。后来领导的要求越来越花哨，大致需要先去解析<code>json</code>的内容，然后再去客制化，这里记录过程中用到的<code>jq</code>操作，方便以后有类似需求时直接参考。<br>官方文档在<a href="https://stedolan.github.io/jq/manual/">这里</a>  ，虽然是英文，但是还算方便，虽说不一定看懂。</p>
<span id="more"></span>


<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>较简单使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat built.json | jq <span class="comment"># 不使用过滤器，则原样输出</span></span><br><span class="line">$ cat built.json | jq <span class="string">'.'</span> <span class="comment"># 使用 . 过滤器获取 key 的值，这里原样输出</span></span><br><span class="line">$ jq <span class="string">'.'</span> built.json <span class="comment"># 使用 . 过滤器获取 key 的值，这里原厂输出</span></span><br><span class="line">$ jq <span class="string">'.config.built'</span> built.json <span class="comment"># 使用 . 过滤器获取 key 的值</span></span><br><span class="line">$ jq <span class="string">'.config.built.fw_builtdate | tonumber'</span> built.json <span class="comment"># 将格式正确的字符串转换成对应的数字</span></span><br><span class="line">$ jq -c <span class="string">'.'</span> built.json <span class="comment"># 将json在一行输出</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>简单使用</p>
<ul>
<li><p><code>--slurp/-s</code>参数</p>
<blockquote>
<p>Instead of running the filter for each JSON object in the input, read the entire input stream into a large array and run the filter just once.</p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ jq -s <span class="string">'.[0] * .[1]'</span> built.json irmap.json <span class="comment"># 将两份json合并</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>--argjson</code>参数</p>
<p>将一个<code>json</code>对象给变量赋值。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">SMARTTVJSON=smarttv/smarttv.json</span><br><span class="line">jq -n --argjson order <span class="string">"<span class="subst">$(&lt;<span class="string">"<span class="variable">${SMARTTVJSON}</span>"</span>)</span>"</span> <span class="string">'{"smarttv":null} | .smarttv = $order'</span> &gt; smarttv.json</span><br></pre></td></tr></tbody></table></figure>

<p>将smarttv.json的内容，转换成<code>json</code>对象，然后把这个<code>json</code>对象，赋给变量order；</p>
<p>过滤器添加一个smarttv的空key，接着把变量order的值给到smarttv这个key；</p>
<p>最后把处理后的数据重定向到一个<code>json</code>文件。</p>
</li>
<li><p><code>--slurpfile</code>参数</p>
<p>将一个<code>json</code>文件给变量赋值。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">COMMON_JSON=public/public.json</span><br><span class="line">ORDER_JSON=order/order.json</span><br><span class="line">jq --slurpfile public <span class="variable">${COMMON_JSON}</span> <span class="string">'paths(scalars) as $order | $public[] | getpath($order)'</span> <span class="variable">${ORDER_JSON}</span></span><br></pre></td></tr></tbody></table></figure>

<p>将public.json文件，赋给变量public；</p>
<p>过滤器，将order.json文件的非null（这个不太理解，只是刚好功能OK）的key的路径赋给order变量，然后拿到public.json对应的这些路径的key的值（如果是null，说明public.json没有这个key）。</p>
<p>过滤器这样设计，是要找出order.json里比public.json多的有效值（这个key的值不是null）。</p>
<p><code>paths(scalars)</code>在<code>builtin.jq</code>里的定义：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">def scalars: select(<span class="built_in">type</span>|. != <span class="string">"array"</span> and . != <span class="string">"object"</span>);</span><br><span class="line">def paths(node_filter): . as <span class="variable">$dot</span>|paths|select(. as <span class="variable">$p</span>|<span class="variable">$dot</span>|getpath(<span class="variable">$p</span>)|node_filter);</span><br><span class="line">def leaf_paths: paths(scalars);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>-f</code>参数</p>
<p>从文件中读取过滤器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">jq -f mergeorder.jq -s public.json order.json &gt; order.json</span><br></pre></td></tr></tbody></table></figure>

<p>过滤器mergeorder.jq内容如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">def mergeorder(a;b):</span><br><span class="line">    reduce b[] as <span class="variable">$item</span> (a;</span><br><span class="line">        reduce (<span class="variable">$item</span> | keys_unsorted[]) as <span class="variable">$key</span> (.;</span><br><span class="line">            <span class="variable">$item</span>[<span class="variable">$key</span>] as <span class="variable">$val</span> | (<span class="variable">$val</span> | <span class="built_in">type</span>) as <span class="variable">$type</span> | .[<span class="variable">$key</span>] = <span class="keyword">if</span> (<span class="variable">$type</span> == <span class="string">"object"</span>) <span class="keyword">then</span></span><br><span class="line">            mergeorder({}; [<span class="keyword">if</span> .[<span class="variable">$key</span>] == null <span class="keyword">then</span> {} <span class="keyword">else</span> .[<span class="variable">$key</span>] end, <span class="variable">$val</span>])</span><br><span class="line">            <span class="keyword">elif</span> (<span class="variable">$type</span> == <span class="string">"null"</span>) <span class="keyword">then</span></span><br><span class="line">            .[<span class="variable">$key</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="variable">$val</span></span><br><span class="line">            end)</span><br><span class="line">        );</span><br><span class="line">    mergeorder({}; .)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p><span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</li>
</ul>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><ol>
<li><p>准备交叉编译链</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar -xf asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810.tar.bz2</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>配置环境变量</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ vim /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p>添加</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/me/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin</span><br></pre></td></tr></tbody></table></figure>

<p>使环境变量即时生效</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p>检查交叉编译链是否配置成功</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ arm-linux-gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=/home/me/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin/arm-linux-gnueabi-xgcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/home/me/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin/../libexec/gcc/arm-linux-gnueabi/6.4.1/lto-wrapper</span><br><span class="line">Target: arm-linux-gnueabi</span><br><span class="line">Configured with: Realtek SDK Builder release 5</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 6.4.1 20170707 (Realtek ASDK-6.4.1 Build 2641)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>准备<code>jq</code>代码</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/stedolan/jq.git</span><br><span class="line">$ <span class="built_in">cd</span> jq</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>配置并编译</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git submodule update --init</span><br><span class="line">$ autoreconf -<span class="keyword">fi</span></span><br><span class="line">$ CC=arm-linux-gcc ./configure --host=arm --disable-maintainer-mode --with-oniguruma=<span class="built_in">builtin</span></span><br><span class="line">$ make LDFLAGS=-all-static</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>检查</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ file jq</span><br><span class="line">jq: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=84b312b91d525513129861f40ef6359ee0188eb0, not stripped</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>最后</p>
<p>把这个二进制文件预置到开发板就可以使用啦</p>
</li>
</ol>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>上述提到的这个例子</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">jq -f mergeorder.jq -s public.json order.json &gt; order.json</span><br></pre></td></tr></tbody></table></figure>

<p>发现有问题（用的是1.6版本的<code>jq</code>），还是说其实是过滤器有问题？不确定，留个心眼。</p>
<p>当把一个json文件当做input时，不能同时重定向作为<code>jq</code>处理后的输出，否则结果跟预想的可能不一样。</p>
<p>以下命令，输出总是对的：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ jq -f mergeorder.jq -s public.json order.json</span><br></pre></td></tr></tbody></table></figure>

<p>但是重新重定向到order.json后，结果就不一样。</p>
<p>因为这个差异，卡了好久！</p>
<p>最后这样处理，就能按预想的跑了：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cp order.json order_bak.json</span><br><span class="line">jq -f mergeorder.jq -s public.json order_bak.json &gt; order.json</span><br></pre></td></tr></tbody></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cloud.tencent.com/developer/ask/40577">如何使用JQ合并2个 JSON文件？</a></p>
<p><a href="https://stackoverflow.com/questions/66024299/how-to-merge-two-json-files-using-jq-or-any-tool">How to merge two JSON files using jq or any tool?</a></p>
<p><a href="https://stackoverflow.com/questions/19529688/how-to-merge-2-json-objects-from-2-files-using-jq">How to merge 2 JSON objects from 2 files using jq?</a></p>
<p><a href="https://justcode.ikeepstudying.com/2018/02/shell%EF%BC%9A%E6%97%A0%E6%AF%94%E5%BC%BA%E5%A4%A7%E7%9A%84shell%E4%B9%8Bjson%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7jq-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90json-jq%E8%A7%A3%E6%9E%90-json/">Shell：无比强大的shell之json解析工具jq , Linux命令行解析json, jq解析 json 实例</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/7565371.html">JSON格式化输出和解析工具 - jq</a></p>
<p><a href="https://e.printstacktrace.blog/merging-json-files-recursively-in-the-command-line/">Merging JSON files recursively in the command-line</a></p>
<p><a href="https://wiki.netmodule.com/development/toolchain">Cross-compilation</a></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uIKvYgix-L4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe> 

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>json</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title>repo常用指令</title>
    <url>/2021/06/27/repo/</url>
    <content><![CDATA[<p>速查。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ repo init -u ssh://git.hk.com.cn/hk/manifest -b RTK/android11 -m hk_config.xml</span><br><span class="line">$ repo sync -d -c -v --force-sync --no-tags</span><br><span class="line">$ repo start 分支名字 --all <span class="comment">#新建分支</span></span><br><span class="line">$ repo upload</span><br><span class="line">$ repo upload . --no-verify</span><br><span class="line">$ repo forall -c <span class="string">"git命令"</span></span><br><span class="line">$ repo forall -c <span class="string">"git branch | sed -e /^*/d | xargs git branch -D"</span> <span class="comment">#清理所有分支</span></span><br><span class="line">$ repo forall -c <span class="string">"git clean -xdf .;git reset --hard"</span> <span class="comment">#清理本地所有修改</span></span><br><span class="line">$ repo manifest -ro snapshot.xml</span><br><span class="line">$ repo list</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>repo</tag>
      </tags>
  </entry>
  <entry>
    <title>打印函数调用堆栈</title>
    <url>/2021/07/06/trace-stack/</url>
    <content><![CDATA[<p>有时候希望知道函数被哪里调用了，但是源码太多，逐个加打印肯定是不方便的，以下记录跟踪函数调用栈信息的方法。</p>
<span id="more"></span>

<h3 id="Native-C"><a href="#Native-C" class="headerlink" title="Native C++"></a>Native C++</h3><ol>
<li><p>头文件包含</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/CallStack.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在需要打印堆栈的地方添加</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">android::CallStack <span class="title">stack</span><span class="params">(<span class="string">"CALLSTACK"</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>CALLSTACK是在<code>logcat</code>中输出的<code>TAG</code>。</p>
</li>
<li><p>Android.mk添加</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">LOCAL_SHARED_LIBRARIES += libutilscallstack</span><br><span class="line">LOCAL_SHARED_LIBRARIES += libutils</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="Native-C-1"><a href="#Native-C-1" class="headerlink" title="Native C"></a>Native C</h3><p>通过C语言调用C++的函数，即extern C。</p>
<p>在项目里添加一个c++文件callstack.cpp</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/CallStack.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"callstack.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dumping_callstack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="function">android::CallStack <span class="title">stack</span><span class="params">(<span class="string">"CALLSTACK"</span>)</span></span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>添加一个callstack.h</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CALLSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CALLSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dumping_callstack</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>修改Android.mk</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">LOCAL_SRC_FILES += callstack.cpp</span><br><span class="line">LOCAL_SHARED_LIBRARIES += libutilscallstack</span><br><span class="line">LOCAL_SHARED_LIBRARIES += libutils</span><br></pre></td></tr></tbody></table></figure>

<p>在native C里面包含头文件</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"callstack.h"</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>然后调用</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">dumping_callstack();</span><br></pre></td></tr></tbody></table></figure>



<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Exception e = <span class="keyword">new</span> Exception(<span class="string">"CALLSTACK"</span>);</span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></tbody></table></figure>

<p>log在<code>logcat</code>中可以看到。</p>
<h3 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">dump_stack();</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言利用iniparser库解析INI文件</title>
    <url>/2021/06/12/parse-ini-in-c/</url>
    <content><![CDATA[<p>没什么好说的。  </p>
<span id="more"></span>

<p><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><a href="https://github.com/ndevilla/iniparser">iniparser</a><br><code>Linux</code>应用程序编程的例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iniparser.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NAME <span class="meta-string">"RTK_4K2K_VBY1_1Seg8Port_new.ini"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIFILE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  dictionary * ini;</span><br><span class="line">  ini = iniparser_load(CONFIG_NAME);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIFILE</span></span><br><span class="line">  FILE * panel_ini = <span class="literal">NULL</span>;</span><br><span class="line">  panel_ini = fopen(CONFIG_NAME,<span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == panel_ini)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open %s fail!\n"</span>, CONFIG_NAME);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  iniparser_set(ini,<span class="string">"PANEL:BACKLIGHT_PWM_MAX"</span>,<span class="string">"199"</span>);</span><br><span class="line">  iniparser_dump_ini(ini, panel_ini);</span><br><span class="line">  fclose(panel_ini);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  iniparser_dump_ini(ini, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  iniparser_freedict(ini);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>iniparser</code>支持读写，但是u-boot不能调用C标准库，移植的话比较麻烦，要重新实现这些用到的库函数。<br>有一个比较热门的开源库是<a href="https://github.com/benhoyt/inih">inih</a>，但是只发现读（解析）操作，没找到是怎么写的。  </p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>ini</tag>
        <tag>opensource</tag>
      </tags>
  </entry>
  <entry>
    <title>fsck的一个场景</title>
    <url>/2021/07/03/fsck/</url>
    <content><![CDATA[<p>添加的一个<code>vfat</code>文件系统，概率性发现有些板子开机起来后发现多了FSCK0000.REC、FSCK0001.REC…FSCK0023.REC这些文件。</p>
<span id="more"></span>

<h3 id="REC文件"><a href="#REC文件" class="headerlink" title="REC文件"></a>REC文件</h3><p>这些命名以FSCK开头，后缀为REC的是什么文件？</p>
<blockquote>
<p>A REC file is a data recovery file created by fsck, a utility used to check the integrity of a file system in Unix and Unix-like operating systems. It contains a log of “inconsistencies” in a filesystem that were detected during an fsck check that can be analyzed by users to investigate issues in a file system. REC files are similar to .chk files created by the “CHKDSK” system tool for Windows.</p>
<p>The fsck tool is typically used in Unix-like operating systems, such as Linux, macOS, Free BSD. The utility typically runs during the bootup of the operating system to check the consistency of the filesystem. If the utility finds any issues, it logs them in one or more REC files to be analyzed.</p>
<p>When fsck creates REC files it names them as <strong>FSCK####.REC</strong> with the #### ascending from 0000 for each data recovery file created. For example, the first REC file is <strong>FSCK0000.REC</strong>, the second is <strong>FSCK0001.REC</strong>, the third is <strong>FSCK0002.REC</strong>, and so on.</p>
<p>REC files store data in plain text and can be opened with a text editor, such as Apple TextEdit or gedit. The files can also be deleted without affecting the performance of the system but they may be regenerated during the operating system bootup process.</p>
<p><strong>NOTE:</strong> fsck is short for File System Consistency Check.</p>
</blockquote>
<h3 id="dosfstools"><a href="#dosfstools" class="headerlink" title="dosfstools"></a>dosfstools</h3><p>还好这个系统分区里面的其他文件看起来都正常，没有被损坏，如果文件系统损坏了，<a href="https://github.com/dosfstools/dosfstools">dosfstools</a>这个工具可以帮助修复。</p>
<ol>
<li><p>下载</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/dosfstools/dosfstools.git</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>编译</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ./autogen.sh</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br></pre></td></tr></tbody></table></figure>

<p>根目录产生一个<code>fsck.fat</code>文件。</p>
</li>
</ol>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>但是要在Android平台上运行，需要交叉编译：</p>
<p>找到平台编<code>kernel</code>用的<code>gcc</code>工具，查看<code>kernel</code>根目录的<code>.config</code>文件，得到：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">CONFIG_CROSS_COMPILE=<span class="string">"asdk-linux-"</span></span><br></pre></td></tr></tbody></table></figure>

<p>把<code>asdk-linux-</code>的实际路径，添加到环境变量：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/me/hk2851/kernel/system/tmp/toolchain/asdk-6.4.1-a55-EL-4.4-g2.26-a32nut-170810/bin</span><br></pre></td></tr></tbody></table></figure>

<p>编译<code>fsck.fat</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ make CC=arm-linux-gnueabi-gcc</span><br></pre></td></tr></tbody></table></figure>

<p>得到<code>fsck.fat</code>，将其拷贝到平台，<code>chmod</code>添加权限，但无法运行。</p>
<p>执行<code>file</code>命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ file fsck.fat</span><br><span class="line">fsck.fat: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=5500515d59327f7001948e5159d6158b2a37e840, with debug_info, not stripped</span><br></pre></td></tr></tbody></table></figure>

<p>执行<code>readelf</code>命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ readelf -d fsck.fat</span><br></pre></td></tr></tbody></table></figure>

<p>得到如下信息：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Dynamic section at offset 0xaf18 contains 24 entries:</span><br><span class="line">Tag        Type                         Name/Value</span><br><span class="line">0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line">0x0000000c (INIT)                       0x10af4</span><br><span class="line">0x0000000d (FINI)                       0x185fc</span><br><span class="line">0x00000019 (INIT_ARRAY)                 0x2af0c</span><br><span class="line">0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x0000001a (FINI_ARRAY)                 0x2af10</span><br><span class="line">0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x00000004 (HASH)                       0x101ac</span><br><span class="line">0x00000005 (STRTAB)                     0x106d0</span><br><span class="line">0x00000006 (SYMTAB)                     0x10330</span><br><span class="line">0x0000000a (STRSZ)                      454 (bytes)</span><br><span class="line">0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line">0x00000015 (DEBUG)                      0x0</span><br><span class="line">0x00000003 (PLTGOT)                     0x2b000</span><br><span class="line">0x00000002 (PLTRELSZ)                   408 (bytes)</span><br><span class="line">0x00000014 (PLTREL)                     REL</span><br><span class="line">0x00000017 (JMPREL)                     0x1095c</span><br><span class="line">0x00000011 (REL)                        0x1092c</span><br><span class="line">0x00000012 (RELSZ)                      48 (bytes)</span><br><span class="line">0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line">0x6ffffffe (VERNEED)                    0x1090c</span><br><span class="line">0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line">0x6ffffff0 (VERSYM)                     0x10896</span><br><span class="line">0x00000000 (NULL)                       0x0</span><br></pre></td></tr></tbody></table></figure>

<p>依赖<code>libc</code>，是这个原因吗？</p>
<p>编译一个静态的<code>fsck.fat</code>试试：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ make CC=arm-linux-gnueabi-gcc LDFLAGS=-static</span><br></pre></td></tr></tbody></table></figure>

<p><code>file</code>命令检查一下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ file fsck.fat</span><br><span class="line">fsck.fat: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=a6a69c42911b5ca79702e813773a7e4ebf7e5eaf, with debug_info, not stripped</span><br></pre></td></tr></tbody></table></figure>



<h3 id="fsck-fat使用"><a href="#fsck-fat使用" class="headerlink" title="fsck.fat使用"></a>fsck.fat使用</h3><p>将这个静态的<code>fsck.fat</code>拷贝到平台运行试试</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ umount /smarttv</span><br><span class="line">$ fsck.fat -atv -w /dev/block/mmcblk0p17</span><br><span class="line">fsck.fat 3.0.26 (2014-03-07)</span><br><span class="line">CP437: Invalid argument</span><br><span class="line">fsck.fat 3.0.26 (2014-03-07)</span><br><span class="line">Checking we can access the last sector of the filesystem</span><br><span class="line">Boot sector contents:</span><br><span class="line">System ID <span class="string">"mkdosfs"</span></span><br><span class="line">Media byte 0xf8 (hard disk)</span><br><span class="line">       512 bytes per logical sector</span><br><span class="line">       512 bytes per cluster</span><br><span class="line">         6 reserved sectors</span><br><span class="line">First FAT starts at byte 3072 (sector 6)</span><br><span class="line">         2 FATs, 32 bit entries</span><br><span class="line">    516608 bytes per FAT (= 1009 sectors)</span><br><span class="line">Root directory start at cluster 2 (arbitrary size)</span><br><span class="line">Data area starts at byte 1036288 (sector 2024)</span><br><span class="line">    129048 data clusters (66072576 bytes)</span><br><span class="line">16 sectors/track, 4 heads</span><br><span class="line">         0 hidden sectors</span><br><span class="line">    131072 sectors total</span><br><span class="line">Checking <span class="keyword">for</span> bad clusters.</span><br><span class="line">Reclaiming unconnected clusters.</span><br><span class="line">Checking free cluster summary.</span><br><span class="line">/dev/block/mmcblk0p17: 62 files, 14665/129048 clusters</span><br><span class="line">$</span><br><span class="line">$</span><br><span class="line">$ mount /dev/block/mmcblk0p17 /smarttv</span><br><span class="line">$ ls smarttv/</span><br><span class="line">FSCK0000.REC FSCK0006.REC FSCK0012.REC FSCK0018.REC common              </span><br><span class="line">FSCK0001.REC FSCK0007.REC FSCK0013.REC FSCK0019.REC smarttv.json        </span><br><span class="line">FSCK0002.REC FSCK0008.REC FSCK0014.REC FSCK0020.REC smarttv.json.backup </span><br><span class="line">FSCK0003.REC FSCK0009.REC FSCK0015.REC FSCK0021.REC </span><br><span class="line">FSCK0004.REC FSCK0010.REC FSCK0016.REC FSCK0022.REC </span><br><span class="line">FSCK0005.REC FSCK0011.REC FSCK0017.REC FSCK0023.REC</span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>

<p><code>fsck.fat</code>可以正常使用，但是REC文件还在，这个应该是留着修复文件系统损坏的。</p>
<p>详细用法：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ fsck.vat</span><br><span class="line">usage: fsck.fat [-aAbflrtvVwy] [-d path -d ...] [-u path -u ...]</span><br><span class="line">            device</span><br><span class="line">-a       automatically repair the filesystem</span><br><span class="line">-A       toggle Atari filesystem format</span><br><span class="line">-b       make read-only boot sector check</span><br><span class="line">-c N     use DOS codepage N to decode short file names (default: 437)</span><br><span class="line">-d path  drop that file</span><br><span class="line">-f       salvage unused chains to files</span><br><span class="line">-l       list path names</span><br><span class="line">-n       no-op, check non-interactively without changing</span><br><span class="line">-p       same as -a, <span class="keyword">for</span> compat with other *fsck</span><br><span class="line">-r       interactively repair the filesystem</span><br><span class="line">-t       <span class="built_in">test</span> <span class="keyword">for</span> bad clusters</span><br><span class="line">-u path  try to undelete that (non-directory) file</span><br><span class="line">-v       verbose mode</span><br><span class="line">-V       perform a verification pass</span><br><span class="line">-w       write changes to disk immediately</span><br><span class="line">-y       same as -a, <span class="keyword">for</span> compat with other *fsck</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>fat</tag>
        <tag>vfat</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2019/08/10/java/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>


<h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><ul>
<li>变量：<br>  Java语言支持的变量类型有：  <pre><code>  1. 类变量：独立于方法之外的变量，用static修饰  
  2. 实例变量：独立于方法之外的变量，不过没有static修饰  
  3. 局部变量：类的方法中的变量  
</code></pre>
  实例：    <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>; <span class="comment">//类变量</span></span><br><span class="line">	String str = <span class="string">"hello world"</span>; <span class="comment">//实例变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//局部变量</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ul>
<li><p>Java中的受保护部分对于所有子类及同一个包中的所有其他类都可见。  </p>
</li>
<li><p>protected需要从以下两个点来分析说明：</p>
<ol>
<li>子类与基类在同一个包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；  </li>
<li>子类与基类不在同一个包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。  </li>
</ol>
</li>
<li><p>final  </p>
<ul>
<li>在Java中，用关键字final指示常量。  </li>
<li>关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。  </li>
<li>在Java中，经常希望某个变量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。  </li>
<li>final关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。（注：实例变量也可以被定义为final，被定义为final的变量不能被修改。被声明为final类的方法自动得声明为final，但是实例变量并不是final（如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域））</li>
</ul>
</li>
<li><p>构建字符串：StringBuilder  </p>
<ol>
<li>构建一个空的字符串构建器:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></tbody></table></figure></li>
<li>当每次需要添加一部分内容时，就调用append()方法:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">builder.append(ch); <span class="comment">//appends a single character</span></span><br><span class="line">builder.append(str); <span class="comment">//appends a string</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>在需要构建字符串时就调用toString()方法，将可以得到一个String对象，其中包括了构建器中的字符序列:   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String completedString = builder.toString();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>一旦创建了数组，就不能改变它的大小（尽管可以改变每一个数组元素）。如果经常需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 -- 数组列表。  </p>
</li>
<li><p>初始化数据域的方法：  </p>
<ol>
<li>在构造器中设置值  </li>
<li>在声明中赋值  </li>
<li>初始化块（首先运行初始化块，然后才运行构造器的主体部分，这种机制不是必需的，也不常见，通常，直接将初始化代码放在构造器中）</li>
</ol>
</li>
<li><p>在对象与对象变量之间存在着一个重要的区别。例如，语句 Date deadline；<br>  定义了一个对象变量deadline，它可以引用Date类型的对象，但是，一定要认识到：变量deadline不是一个对象，实际上也没有引用对象。此时，不能将任何Date方法应用于这个变量上。语句 s = deadline.toString(); 将产生编译错误。必须首先初始化变量deadline，这里有两个选择，可以用新构造的对象初始化这个变量：deadline = new Date(); 也可以让这个变量引用一个已存在的对象：deadline = birthday；  </p>
</li>
<li><p>一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅是引用了一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。  </p>
</li>
<li><p>可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象。deadline = null；  </p>
</li>
<li><p>局部变量不会自动地初始化为null，而必须通过调用new或将他们设置为null进行初始化。  </p>
</li>
<li><p>所有的Java对象都存储在堆中。  </p>
</li>
<li><p>在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。  </p>
</li>
<li><p>构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。  </p>
</li>
<li><p>注意不要编写返回引用可变对象的访问器方法。如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。如果需要返回一个可变数据域的拷贝，就应该使用clone。对象的克隆是指存放在另一个位置上的对象副本。修改前的代码：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> Date hireDay;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> hireDay;</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  修改后的代码：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getHireDay</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> hireDay.clone();</span><br><span class="line">	}</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>static游离块、一般游离块、子父类构造方法，执行顺序：父类静态游离块 &gt; 子类静态游离块 &gt; 父类游离块 &gt; 父类构造函数 &gt; 子类游离块 &gt; 子类构造函数  </p>
</li>
<li><p>块作用域：不能在嵌套的两个块中声明同名的变量。但是在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会覆盖在外层定义的变量。  </p>
</li>
<li><p>一个方法可以访问所属类的所有对象的私有数据。  </p>
</li>
</ul>
<h3 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h3><ul>
<li><p>静态域：<br>  如果将域定义为static，每个类中只有一个这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee类添加一个实例域id和一个静态域nextId：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  现在，每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。换句话说，如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。  </p>
</li>
<li><p>在下面两种情况下使用静态方法：  </p>
<ol>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）。  </li>
<li>一个方法只需要访问类的静态域（例如：Employee.getNextId）。  </li>
</ol>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。  </p>
</li>
<li><p>静态方法只能访问静态成员，实例方法可以访问静态和实例成员。  </p>
</li>
<li><p>之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。  </p>
</li>
</ul>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ul>
<li><p>方法参数共有两种类型：  </p>
<ol>
<li>基本数据类型（数字、布尔值）  </li>
<li>对象引用  </li>
</ol>
</li>
<li><p>方法参数的使用情况：  </p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。  </li>
<li>一个方法可以改变一个对象参数的状态。（实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。）  </li>
<li>一个方法不能让对象参数引用一个新的对象。 </li>
</ol>
</li>
<li><p>调用：<br>  按值调用：表示方法接收的是调用者提供的值。<br>  按引用调用：表示方法接收的是调用者提供的变量地址。<br>  一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。<br>  Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。<br>  Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递。</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamTest</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/* Test1: Methods can't modify numeric parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）</span></span><br><span class="line">		System.out.println(<span class="string">"Testing tripleValue:"</span>);</span><br><span class="line">		<span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">"Before: percent = "</span> + percent);</span><br><span class="line">		tripleValue(percent);</span><br><span class="line">		System.out.println(<span class="string">"After: percent = "</span> + percent);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Test2: Methods can change the state of object parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法可以改变一个对象参数的状态</span></span><br><span class="line">		System.out.println(<span class="string">"\nTesting tripleValue:"</span>);</span><br><span class="line">		Employee harry = <span class="keyword">new</span> Employee(<span class="string">"Harry"</span>,<span class="number">500000</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before: salary = "</span> + harry.getSalary());</span><br><span class="line">		tripleSalary(harry);</span><br><span class="line">		System.out.println(<span class="string">"After: salary = "</span> + harry.getSalary());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Test3: Methods can't attach new objects to object parameters*/</span></span><br><span class="line">		<span class="comment">//一个方法不能让对象参数引用一个新的对象</span></span><br><span class="line">		System.out.println(<span class="string">"\nTesting swap:"</span>);</span><br><span class="line">		Employee a = <span class="keyword">new</span> Employee(<span class="string">"Alice"</span>, <span class="number">70000</span>);</span><br><span class="line">		Employee b = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>, <span class="number">60000</span>);</span><br><span class="line">		System.out.println(<span class="string">"Before: a = "</span> + a.getName());</span><br><span class="line">		System.out.println(<span class="string">"Before: b = "</span> + b.getName());</span><br><span class="line">		swap(a,b);</span><br><span class="line">		System.out.println(<span class="string">"After: a = "</span> + a.getName());</span><br><span class="line">		System.out.println(<span class="string">"After: b = "</span> + b.getName());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span></span>{ <span class="comment">//doesn't work</span></span><br><span class="line">		x = <span class="number">3</span> * x;</span><br><span class="line">		System.out.println(<span class="string">"End of method: x = "</span> + x);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee x)</span></span>{ <span class="comment">//works</span></span><br><span class="line">		x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">		System.out.println(<span class="string">"End of method: salary = "</span> + x.getSalary());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x, Employee y)</span></span>{</span><br><span class="line">		Employee temp = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = temp;</span><br><span class="line">		System.out.println(<span class="string">"End of method: x = "</span> + x.getName());</span><br><span class="line">		System.out.println(<span class="string">"End of method: y = "</span> + y.getName());</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>{ <span class="comment">//simplified Employee class</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s)</span></span>{</span><br><span class="line">		name = n;</span><br><span class="line">		salary = s;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> salary;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>{</span><br><span class="line">		<span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">		salary += raise;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。然而，超类中的有些方法对子类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖（override）超类中的这个方法。<br>  那么如何实现这个方法呢？乍看起来似乎很简单，只要返回salary和bonus域的总和就可以了：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> salary + bonus; <span class="comment">// won't work</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>然而，这个方法并不能运行。这是因为Manger类的getSalary方法不能地访问超类的私有域。也就是说，尽管每一个Manager对象都拥有一个名为salary的域，但在Manager类的getSalary方法中并不能直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助于公有的接口，Employee类中的公有方法getSalary正是这样一个接口。  </p>
</li>
<li><p>现在，再试一下。将对salary域的访问替换成调用getSalary方法。  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">double</span> baseSalary = getSalary(); <span class="comment">// still won't work</span></span><br><span class="line">	<span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  上面这段代码仍然不能访问。问题出现在调用getSalary的语句上，这是因为Manager类也有一个getSalary方法（就是正在实现的这个方法），所以这条语句将会导致无限次地调用自己，直到整个程序崩溃为止。  </p>
</li>
<li><p>这里需要指出：我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此，可以使用特定的关键字super解决这个问题：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">	<span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。  </p>
</li>
<li><p>super在构造器中的应用：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(n,s,year,month,day);</span><br><span class="line">	bonus = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  这里的关键字super具有不同的含义。语句super(n,s,year,month,day);是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式。<br>  由于Manager类的构造器不能访问Employee类的私有域，所以必须利用Employee的构造器对这部分私有域进行初始化，我们可以通过super实现对超类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句。<br>  如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用其他构造器，则Java编译器将报告错误。（子类不能继承父类的构造器（构造方法或者构造函数），如果父类的构造器带有参数，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类构造器没有参数，则在子类的构造器中不需要使用super关键字调用父类构造器，系统会自动调用父类的无参构造器。）  </p>
</li>
<li><p>关键字this的两个用途：  </p>
<ol>
<li>引用隐式参数  </li>
<li>调用该类其他的构造器  </li>
</ol>
</li>
<li><p>关键字super的两个用途：  </p>
<ol>
<li>调用超类方法  </li>
<li>调用超类的构造器  </li>
</ol>
</li>
<li><p>重写(override)：  </p>
<ul>
<li>声明为final的方法不能被重写  </li>
<li>声明为static的方法不能被重写，但是能够被再次声明  </li>
<li>构造方法不能被重写  </li>
<li>如果不能继承一个方法，则不能重写这个方法  </li>
</ul>
</li>
<li><p>重载(overload)：  </p>
<ul>
<li>被重载的方法必须改变参数列表（参数个数或类型不一样）  </li>
<li>被重载的方法可以改变返回类型  </li>
<li>被重载的方法可以改变访问修饰符  </li>
<li>被重载的方法可以声明新的或更广的检查异常  </li>
<li>方法能够在同一个类中或者在一个子类中被重载  </li>
</ul>
</li>
</ul>
<ul>
<li><p>一个对象变量可以指示多种实际类型的现象被称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定。  </p>
</li>
<li><p>多态的实现方法：重写、接口、抽象类和抽象方法。  </p>
</li>
<li><p>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。  </p>
</li>
<li><p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。  </p>
</li>
<li><p>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联。如果方法很简短、被频繁调用且没有真正地被覆盖，那么虚拟机中的即时编译器就会将这个方法进行内联处理。  </p>
</li>
<li><p>强制类型转换：在将超类转换成子类之前，应该使用instanceof进行检查。  </p>
</li>
<li><p>abstract关键字：  </p>
<ol>
<li>包含一个或多个抽象方法的类本身必须声明为抽象的。  </li>
<li>除抽象方法之外，抽象类还可以包含具体数据和具体方法。  </li>
<li>抽象方法充当着占位的角色，它们的具体实现在子类中。  </li>
<li>扩展抽象类可以有两种选择。一种是在子类中定义部分抽象方法或者抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部抽象方法，这样一来，子类就不是抽象的了。  </li>
<li>类即使不含抽象方法，也可以将类声明为抽象类。  </li>
<li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。(抽象类不能直接通过new去实例化一个对象，那它就是不能实例化，要获取抽象类的对象，需要先用一个类继承抽象类，然后去实例化子类。也可以用匿名内部类，在抽象类中创建一个匿名的子类，继承抽象类，通过特殊的语法实例化子类的对象。)  </li>
<li>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。  </li>
<li>构造方法、类方法（用static修饰的方法）不能声明为抽象方法。  </li>
</ol>
</li>
</ul>
<h2 id="接口和内部类"><a href="#接口和内部类" class="headerlink" title="接口和内部类"></a>接口和内部类</h2><ul>
<li><p>接口绝不能含有实例域，也不能在接口中实现方法。提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例域的抽象类。  </p>
</li>
<li><p>接口不是类，尤其不能使用new运算符实例化一个接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Compare(...); <span class="comment">//ERROR</span></span><br></pre></td></tr></tbody></table></figure>
<p>  然而，尽管不能构造接口的对象，却能声明接口的变量：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Compare x; <span class="comment">//OK</span></span><br></pre></td></tr></tbody></table></figure>
<p>  接口变量必须引用实现了接口的类对象：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Employee(...); <span class="comment">//OK provided Employee implements Comparable</span></span><br></pre></td></tr></tbody></table></figure>
<p>  接下来，如同使用instanceof检查一个对象是否属于某个特定类一样，也可以使用instanceof检查一个对象是否实现了某个特定的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) {...}</span><br></pre></td></tr></tbody></table></figure>
<p>  与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，假设有一个称为Moveable的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">move</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  然后，可以以它为基础扩展一个叫做Powered的接口：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">milePerGallon</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  虽然在接口中不能包含实例域或静态方法，但却可以包含常量。<br>  与接口中的方法都自动地被设置为public一样，接口中的域将被自动设为public static final。  </p>
</li>
<li><p>为什么要使用内部类？  </p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。  </li>
<li>内部类可以对同一个包中的其他类隐藏起来。  </li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。  </li>
</ol>
</li>
<li><p>Java内部类还有另外一个功能，这使得它比C++的嵌套类更加丰富，用途更加广泛。内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。  </p>
</li>
<li><p>局部内部类：<br>  局部内部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。  </p>
</li>
<li><p>由外部方法访问final变量：<br>  局部类不仅能够访问包含它们的外部类，还可以访问局部变量，不过，这些局部变量必须被声明为final。  </p>
</li>
<li><p>final关键字可以应用于局部变量、实例变量和静态变量。在所有这些情况下，它们的含义都是：在创建这个变量之后，只能够为之赋值一次。此后，再也不能修改它的值了，这就是final。不过，在定义final变量的时候，不必进行初始化。  </p>
</li>
<li><p>匿名内部类：  </p>
<ol>
<li>如果构造器参数的闭圆括号跟一个开花括号，正在定义的就是匿名内部类。  </li>
<li>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类的构造器。尤其是在内部类实现接口的时候，不能有任何构造参数。  </li>
</ol>
</li>
<li><p>静态内部类：<br>  有时候，使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。    </p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p>Throwable  </p>
<ul>
<li>Error(未检查异常)  </li>
<li>Exception  <ul>
<li>IOException(已检查异常)  </li>
<li>RuntimeException(未检查异常)  </li>
</ul>
</li>
</ul>
</li>
<li><p>声明：方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类已检查异常。但是，不需要声明Java的内部错误，即从Error继承的错误。同样，也不应该声明从RuntimeException继承的那些未检查异常。总之，一个方法必须声明所有可能抛出的已检查异常，而未检查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）。  </p>
</li>
<li><p>由于程序错误导致的异常属于RuntimeException，而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。<br>  派生于RuntimeException的异常包含下面几种情况：  </p>
<ol>
<li>错误的类型转换  </li>
<li>数组访问越界  </li>
<li>访问空指针  </li>
</ol>
<p>  不是派生于RuntimeException的异常包括：  </p>
<ol>
<li>试图在文件尾部后面读取数据  </li>
<li>试图打开一个不存在的文件  </li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在  </li>
</ol>
<p>  “如果出现RuntimeException异常，那么就一定是你的问题”是一条相当有道理的规格。  </p>
</li>
<li><p>如果在子类中覆盖了超类的一个方法，子类方法中声明的已检查异常不能比超类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。特别需要说明的是，如果超类方法没有抛出任何已检查异常，子类也不能抛出任何已检查异常。  </p>
</li>
<li><p>如果想传递一个异常，就必须在方法的首部添加一个throws说明符，以便告知调用者这个方法可能会抛出异常。  </p>
</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li><p>对于一个static方法而言，无法访问泛型类型的参数。如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法。  </p>
</li>
<li><p>泛型类：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">	<span class="keyword">private</span> T first;</span><br><span class="line">	<span class="keyword">private</span> T second;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>{first = <span class="keyword">null</span>; second = <span class="keyword">null</span>;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>{<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second;}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>{<span class="keyword">return</span> first;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>{<span class="keyword">return</span> second;}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>{first = newValue;}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>{second = newValue;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>泛型方法：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>  类型变量放在修饰符（这里是public static）的后面，返回类型的前面。<br>  泛型方法可以定义在普通类中，也可以定义在泛型类中。<br>  当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q"</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>  大多数情况下，方法调用中可以省略<string>类型参数。编译器有足够信息能够推断出所调用的方法。也就是说，可以调用：  </string></p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>,<span class="string">"Q"</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>线程可以有如下6种状态：New(新创建)、Runnable(可运行)、Blocked(被阻塞)、Waiting(等待)、Timed waiting(计时等待)、Terminated(被终止)。  </p>
<ul>
<li>在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。  </li>
<li>当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。  </li>
<li>当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。  </li>
<li>有几个方法有一个超时参数，调用它们导致线程进入计时等待状态。  </li>
<li>线程因如下两个原因之一而被终止：因为run方法正常退出而自然死亡；因为一个没有捕获的异常终止了run方法而意外死亡。  </li>
</ul>
</li>
<li><p>同步：  </p>
<ol>
<li>锁和条件的关键之处：  <ul>
<li>锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。  </li>
<li>锁可以管理试图进入被保护代码段的线程。  </li>
<li>锁可以拥有一个或多个相关的条件对象。  </li>
<li>每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。  </li>
</ul>
</li>
<li>synchronize、wait()、notifyAll()  </li>
<li>除了调用同步方法获得锁，线程还可以通过进入一个同步阻塞获得锁：   <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">synchronize(obj) {</span><br><span class="line">	critical section</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。（volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。）  </li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓APP</title>
    <url>/2019/09/24/android/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<span id="more"></span>



<h3 id="声明周期和启动模式"><a href="#声明周期和启动模式" class="headerlink" title="声明周期和启动模式"></a>声明周期和启动模式</h3><ul>
<li>典型情况下的声明周期  <ol>
<li>onCreate: 表示Activity正在被创建。  </li>
<li>onRestart: 表示Activity正在重新启动。  </li>
<li>onStart: 表示Activity正在被启动。这时Activity已经可见，但还是没有出现在前台。  </li>
<li>onResume: 表示Activity已经可见了，并且出现在前台并开始活动。  </li>
<li>onPause: 表示Activity正在停止。  </li>
<li>onStop: 表示Activity即将停止。  </li>
<li>onDestroy: 表示Activity即将被销毁。  </li>
</ol>
</li>
</ul>
<h3 id="IPC基础概念"><a href="#IPC基础概念" class="headerlink" title="IPC基础概念"></a>IPC基础概念</h3><ul>
<li><p>在Android中使用多线程只有一种方法，那就是给四大组件在AndroidMenifest中指定android:process属性，除此之外没有其他办法，也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。其实还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程，但是这种方法属于特殊情况，也不是常用的创建多进程的方式。  </p>
</li>
<li><p>一般来说，使用多线程会造成如下几方面的问题：  </p>
<ol>
<li>静态成员和单例模式完全失效  </li>
<li>线程同步机制完全失效  </li>
<li>SharedPreferences的可靠性下降  </li>
<li>Application会多次创建  </li>
</ol>
</li>
<li><p>实现跨进程通信的方式很多，比如通过Intent来传递数据，共享文件和SharedPreferences，基于Binder的Messager和AIDL以及Socket等。  </p>
</li>
<li><p>IPC中的一些基础概念，主要包括三方面内容：Serializable接口、Parcelable接口以及Binder。  </p>
</li>
<li><p>什么是对象的序列化？<br>  对象序列化就是将对象的状态信息转化为可以存储或者传输的形式的过程，这些信息包括Class信息、继承关系信息、访问权限、变量类型以及数值信息等。<br>  将序列化对象写入文件后，也可以从文件中读取出来并对其进行反序列化操作。通过反序列化将对象的信息全部获取，然后可以在内存中根据这些信息新建对象。<br>  Java提供了Seriabizable接口来实现对象序列化。当对象在保存对象时，会把其状态保存为一组字节，反序列化时再将这些还原成对象再内存当中重新创建。需要注意的是类中的静态变量是不会被序列化的，因为它不属于对象而是属于类。  </p>
</li>
</ul>
<h4 id="Seriablizable"><a href="#Seriablizable" class="headerlink" title="Seriablizable"></a>Seriablizable</h4><ul>
<li><p>Serializable是Java锁提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。如下所示：<br>  User类是一个实现了Serializable接口的类，它是可以被序列化和反序列化的：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Seriablizable</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">519067123721295773L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">public</span> String userName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  只需要采用ObjectOutputStream和ObjectInputStream即可轻松实现对象的序列化和反序列化：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>, <span class="string">"Jake"</span>, <span class="keyword">true</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">User newUser = (User) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>上述代码演示了采用Serializable方式序列化对象的典型过程，很简单，只需要把实现了Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和user的内容完全一样，但是两者并不是同一个对象。  </p>
</li>
</ul>
<h4 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h4><ul>
<li><p>Parcelable接口。只要实现了这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递。  </p>
</li>
<li><p>以下是一个典型用法：  </p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">	<span class="keyword">public</span> String userName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Book book;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.userId = userId;</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">		<span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内容描述</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//几乎在所有情况下这个方法都应该返回0，仅当当前对象中存在文件描述符时，此方法返回1。</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//序列化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>{</span><br><span class="line">		out.writeInt(userId);</span><br><span class="line">		out.writeString(userName);</span><br><span class="line">		out.writeInt(isMale?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">		out.writeParcelable(book, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;User&gt;() {</span><br><span class="line">		<span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> User[] = newArray(<span class="keyword">int</span> size) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>{</span><br><span class="line">		userId = in.readInt();</span><br><span class="line">		userName = in.readString();</span><br><span class="line">		isMale = in.readInt() == <span class="number">1</span>;</span><br><span class="line">		book = in.readParcelable(Thread.currentThread().getContextClassLoader());</span><br><span class="line">		<span class="comment">//由于book是另一个可序列化对象，所以它的反序列化过程需要传递当前线程的上下文类加载器，否则会报找不到类的错误。</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>系统已经为我们提供了许多实现了Parcelable接口的类，它们都是可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是它们里面的每个元素都是可序列化的。  </p>
</li>
</ul>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等等）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务器端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。  </p>
<p>Android开发中，BInder主要用在Service中，包括AIDL和Messager，其中普通Service中的Binder不涉及进程间通信，所以较为简单，无法触及Binder的核心，而Messager的底层其实是AIDL。  </p>
<p><img src="https://i.loli.net/2019/09/26/xHhaYTteLmy8r53.jpg" alt="Binder的工作机制.jpg">  </p>
<h3 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h3><h4 id="使用Bundle"><a href="#使用Bundle" class="headerlink" title="使用Bundle"></a>使用Bundle</h4><p>Activity、Service、Receiver都支持在Intent中传递Bundle数据  </p>
<h4 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h4><p>文件共享方式适合在对数据同步要求不高的进程之前进行通信，并且要妥善处理并发读/写的问题。<br>但是，SharedPreferences是个特例，不建议在进程间通信中使用SharedPreferences。  </p>
<h4 id="使用Messenger"><a href="#使用Messenger" class="headerlink" title="使用Messenger"></a>使用Messenger</h4><p><img src="https://i.loli.net/2019/09/26/LEwqeRUbx7AVHvQ.jpg" alt="Messenger工作原理.jpg">  </p>
<h4 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h4><p>Messenger是已串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太适合了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。AIDL也是Messenger的底层实现，因此，Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。  </p>
<p>在Binder的基础上我们可以更容易地理解AIDL。这里先介绍使用AIDL来进行进程间通信的流程，分为服务端和客户端两个方面。  </p>
<ol>
<li><p>服务端<br> 服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。  </p>
</li>
<li><p>客户端<br> 客户端所要做的事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。  </p>
</li>
<li><p>AIDL接口的创建<br> 首先看AIDL接口的创建，如下所示，我们创建了一个后缀为AIDL的文件，在里面声明了一个接口和两个接口方法：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>{</span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> AIDL文件支持的数据类型：  </p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本数据类型</td>
<td align="left">int、long、char、boolean、double等</td>
</tr>
<tr>
<td align="left">String 和 CharSequence</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">只支持ArrayList，里面每个元素都必须能够被AIDL支持</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value</td>
</tr>
<tr>
<td align="left">Parcelable</td>
<td align="left">所有实现了Parcelable接口的对象</td>
</tr>
<tr>
<td align="left">AIDL</td>
<td align="left">所有的AIDL接口本身也可以在AIDL文件中使用</td>
</tr>
</tbody></table>
<p> 以上6种数据类型就是AIDL所支持的所有数据类型，其中自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前AIDL文件位于同一个包内。  </p>
<p> 另外一个需要注意的地方是，如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</span><br><span class="line"></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></tbody></table></figure>

<p> AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入性参数，out表示输出型参数，inout表示输入输出型参数。  </p>
<p> AIDL接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。  </p>
</li>
<li><p>远程服务端Service的实现<br> 上面讲述了如何定义AIDL接口，接下来我们就需要实现这个接口了。我们先创建一个Service，称为BookManagerService，代码如下：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BMS"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</span><br><span class="line">	<span class="comment">//CopyOnWriteArrayList支持并发读/写。</span></span><br><span class="line">	<span class="comment">//前面我们提到，AIDL方法是在服务端的Binder线程池执行的，因此，当多个客户端同时连接的时候，</span></span><br><span class="line">	<span class="comment">//会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，</span></span><br><span class="line">	<span class="comment">//而我们这里直接使用CopyOnWriteArrayList来进行自动的线程同步。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() {</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">        	        <span class="keyword">return</span> mBookList;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>{</span><br><span class="line">           			mBookList.add(book);</span><br><span class="line">       		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{</span><br><span class="line">       		<span class="keyword">super</span>.onCreate();</span><br><span class="line">	        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Android"</span>));</span><br><span class="line">	        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"Ios"</span>));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>{</span><br><span class="line">	        <span class="keyword">return</span> mBinder;</span><br><span class="line">   		}</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<p> 然后我们需要在XML中注册这个Service，如下所示：  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">	android:name=<span class="string">".aidl.BookManagerService"</span></span><br><span class="line">	android:process=<span class="string">":remote"</span> &gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></tbody></table></figure>
<p> 注意BookManagerService是运行在独立的进程中的，它和客户端的Activity不在同一个进程中，这样就构成了进程间通信的场景。  </p>
</li>
<li><p>客户端的实现<br> 客户端的实现就比较简单了，首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，代码如下所示。  </p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BookManagerActivity"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() {</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>{</span><br><span class="line">			IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">				Log.i(TAG, <span class="string">"query book list, list type:"</span> + list.getClass().getCanonicalName());</span><br><span class="line">				Log.i(TAG, <span class="string">"query book list:"</span> + list.toString());</span><br><span class="line">			} <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>{</span><br><span class="line">		}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_book_manager);</span><br><span class="line">		Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">		unbindService(mConnection);</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 绑定成功后，会通过bookManager去调用getBookList方法，然后打印出所获取的图书信息。需要注意的是，服务端的方法有可能需要很久才能执行完毕，这个时候下面的代码就会导致ANR，这一点是需要注意的，后面会再介绍这种情况，之所以先这么写是为了让读者更好地了解AIDL的实现步骤。  </p>
<p> 接着在XML中注册此Activity，运行程序。  </p>
<p> RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口。  </p>
<pre><code> - 虽然说多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们的底层的Binder对象是同一个。当客户端解注册的时候，我们只要遍历服务端所有的listener，找出那个和解注册listener具有相同Binder对象的服务端listener并把它删掉即可。  
 - RemoteCallbackList还有一个很有用的功能，那就是当客户端进程终止后，它能够自动移除客户端所注册的listener。  
 - RemoteCallbackList内部自动实现了线程同步功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。  
</code></pre>
</li>
</ol>
<p>到这里，AIDL的基本使用方法已经介绍完了，但是有几点还需要再次说明一下。我们知道，客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端线程会被挂起，这个时候如果服务端方法执行比较耗时，就会导致客户端线程长时间地阻塞在这里，而如果这个客户端线程是UI线程的话，就会导致客户端ANR，这当然不是我们想要看到的。因此，如果我们明确知道某个远程方法是耗时的，那么就要避免在客户端的UI线程中去访问远程方法。由于客户端的onServiceConnected和onSerivceDisconnected方法都运行在UI线程中，所以也不可以在它们里面直接调用服务端的耗时方法，这点要尤其注意。另外，由于服务端的方法本身就运行在服务端的Binder线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要在服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。  </p>
<p>同理，当远程服务端需要调用客户端的listener中的方法时，被调用的方法也运行在Binder线程池中，只不过是客户端的线程池。所以我们同样不可以在服务端中调用客户端的耗时方法。  </p>
<p>最后一步：权限验证！   </p>
<p>总结一下大致流程：<br>首先创建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。  </p>
<h4 id="使用ContentProvider"><a href="#使用ContentProvider" class="headerlink" title="使用ContentProvider"></a>使用ContentProvider</h4><h4 id="使用Socket"><a href="#使用Socket" class="headerlink" title="使用Socket"></a>使用Socket</h4><h3 id="四大组件的工作过程"><a href="#四大组件的工作过程" class="headerlink" title="四大组件的工作过程"></a>四大组件的工作过程</h3><p>Android的四大组件中除了BroadcastReceiver以外,其他三种组件都必须在AndroidManifest中注册，对于BroadcastReceiver来说，它既可以在AndroidManifest中注册，也可以通过代码来注册。在调用方式上，Activity、Service和BroadcastReceiver需要借助Intent，而ContentProvider则无须借助Intent。  </p>
<p>广播（BroadcastReceiver）的注册有两种方式：静态注册和动态注册。静态注册是指在AndroidManifest中注册广播，这种广播在应用安装时会被系统解析，此种形式的广播不需要应用启动就可以收到相应的广播。动态注册广播需要通过Context.registerReceiver()来实现，并且在不需要的时候要通过Context.unRegisterReceiver()来解除广播，此种形式的广播必须要应用启动才能注册并接收广播,因为应用不启动就无法注册广播,无法注册广播就无法收到相应的广播。  </p>
<p><a href="https://youtu.be/8KunR2xqkMM">Android层次分析 –从顶层到底层</a>  </p>
<h3 id="Android的线程和线程池"><a href="#Android的线程和线程池" class="headerlink" title="Android的线程和线程池"></a>Android的线程和线程池</h3><p>主线程是指进程所拥有的线程,在Java中默认情况下一个进程只有一个线程,这个线程就是主线程.主线程主要处理界面交互相关的逻辑,因为用户随时会和界面发生交互,因此主线程在任何时候都必须有较高的响应速度,否则就会产生一种界面卡顿的感觉.为了保持较高的响应速度,这就要求主线程中不能执行耗时的任务,这个时候子线程就派上用场了.子线程也叫工作线程,除了主线程以外的线程都是子线程.  </p>
<p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。  </p>
<p>Android的线程形态：传统的Thread、AsyncTask、HandlerThread、IntentService。  </p>
<p>Android线程的基本用法：  </p>
<ol>
<li><p>新建一个类继承自Thread，然后重写父类的run()方法，并在里面写耗时逻辑  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如何启动？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>实现Runnable接口的方式来定义一个线程  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如何启动？  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Mythread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread).start();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>使用匿名类的方式，这种方法更为常见  </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//处理具体的逻辑</span></span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><a href="https://houbb.github.io/2019/02/26/java-time-nanotime-02">Java 时间之 currentTimeMillis 与 nanoTime - 时间精确测量</a>  </p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>几个C语言知识点</title>
    <url>/2018/12/27/c/</url>
    <content><![CDATA[<p>重新整理以前的笔记，基本来自《C语言深度解剖》。  </p>
<span id="more"></span>

<h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码/反码/补码"></a>原码/反码/补码</h1><p>原码：原码就是这个数本身的二进制形式，其中最高位为符号位。<br>补码：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。<br>反码：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。  </p>
<p>求补码的方法：整数或零，则补码等于原码，负数则补码等于除符号位外，各位取反加一<br>求反码的方法：正数，反码与原码相同，负数，对其原码逐位取反，但符号位除外，符号位还是一  </p>
<p>在计算机系统中，数值一律用补码来表示。 </p>
<p>问题1：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">{</span><br><span class="line">	a[i] = <span class="number">-1</span>-i;</span><br><span class="line">}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">strlen</span>(a)); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><span style="color:red"> 以上代码输出为255 </span>  </p>
<p>问题2：<br>char a = -300，求 int a<br>300的原码：1 0010 1100<br>取反：1101 0011<br>加一：1101 0100<br>300的补码：1101 0100<br>符号位：1<br>求原码：101 0100<br>取反：010 1011<br>加一：010 1100<br>求得：-44  </p>
<p>问题3：<br>int i = -20;<br>unsigned j = 10;<br>i+j的值为多少？为什么？  </p>
<p>问题4：<br>下面的代码有什么问题？  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> i ;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">9</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%u\n"</span>,i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>基本类型 - 数值类型、字符类型</li>
<li>构造类型 - 数组、结构体、共用体、枚举类型</li>
<li>指针类型</li>
<li>空类型</li>
</ul>
<p>常用数据类型在32位和64位CPU上的字节数比较：<br>测试程序：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"char[%d], char*[%d], short int[%d], int[%d], unsigned int[%d], float[%d], double[%d], long[%d], long long[%d], unsigned long[%d]\n"</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="keyword">sizeof</span>(<span class="keyword">char</span> *),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>),<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">float</span>),<span class="keyword">sizeof</span>(<span class="keyword">double</span>),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">long</span>),<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>),<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>不同CPU类型的输出结果：<br>x86_64:  </p>
<blockquote>
<p>char[1], char*[8], short int[2], int[4], unsigned int[4], float[4], double[8], long[8], long long[8], unsigned long[8]  </p>
</blockquote>
<p>i686:  </p>
<blockquote>
<p>char[1], char*[4], short int[2], int[4], unsigned int[4], float[4], double[8], long[4], long long[8], unsigned long[4]  </p>
</blockquote>
<p>总结：很明显的比较结果，指针和长整形由4个字节升为8个字节  </p>
<h1 id="32个关键字"><a href="#32个关键字" class="headerlink" title="32个关键字"></a>32个关键字</h1><p>举例：<br>register - 声明寄存器变量<br>const - 声明只读变量<br>volatile - 说明变量在程序执行中可被隐含地改变。这个关键字声明的变量，编译器对访问该变&gt;量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。  </p>
<p>分析：<br>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。(对Java来说：Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。)</p>
<p>下面是volatile变量的几个例子：  </p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）  </li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)  </li>
<li>多线程应用中被几个任务共享的变量  </li>
</ol>
<p>  回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。 假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。  </p>
<p>有如下3个问题：  </p>
<ol>
<li>一个参数既可以是const还可以是volatile吗？解释为什么。  </li>
<li>一个指针可以是volatile 吗？解释为什么。  </li>
<li>下面的函数有什么错误：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>下面是答案： </p>
<ol>
<li>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。  </li>
<li>是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。  </li>
<li>这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">int</span> a,b; a = *ptr; </span><br><span class="line">    b = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * b; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">int</span> a; a = *ptr; </span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>extern: 说明变量是在其他文件中声明（也可以看作是引用变量）<br>sizeof: 计算对象所占内存空间大小  </p>
<p>函数参数的声明举例：void func(int i,char c)<br>定义声明最重要的区别：定义创建了对象，并为这个对象分配了内存，声明没有分配内存  </p>
<p>编译器在默认的缺省情况下，所有变量都是auto的。  </p>
<p>register变量必须是能被CPU寄存器所接受的类型。意味着register变量必须是一个单个的值，并且其长度应小于或等于整形的长度。而且register变量可能不存在内存中，所以不能用取址运算符“&amp;”来获取register变量的地址。比如说，32位的CPU，最多是4个字节，整形和长整形都是占4个字节的数据类型。<br>注意：register变量只是对编译器的建议，编译器并不一定会将该变量作为register变量。  </p>
<h1 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a>static关键字作用</h1><ol>
<li><p><strong>修饰变量</strong><br> 静态区是分配静态变量、全局变量空间的；初始化的全局变量放在数据段；局部变量放在栈；未初始化的全局变量放在bss段。<br> 从C程序运行的角度看，内存几大部分：静态存储区、堆区和栈区。<br> 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存在静态数据、全局数据和常量。<br> 全局区（静态区）（static） —- 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;			<span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;			<span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> b;			<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>;		<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2;			<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>;	<span class="comment">//123456\0在常量区，p3在栈上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;		<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);	<span class="comment">//堆</span></span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);	<span class="comment">//堆</span></span><br><span class="line">    p1 = <span class="string">"123456"</span>;		<span class="comment">//123456\0在常量区，编译器将p1与p3所指向的“123456\0”优化成同一个地方</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 全局变量、局部变量、静态全局变量、静态局部变量的区别，如下：  </p>
<ul>
<li>从作用域看  </li>
</ul>
<ol>
<li>全局变量具有全局域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。  </li>
<li>静态局部变量具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在。它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。  </li>
<li>局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。  </li>
<li>静态全局变量（其他文件即使使用extern声明也没法使用它）也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同的静态全局变量，它们也是不同的变量。  </li>
</ol>
<ul>
<li>从分配内存空间看<br>全局变量、静态全局变量、静态局部变量都在静态存储区分配空间，而局部变量在栈分配空间。  </li>
</ul>
<p> 把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生命周期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围，因此static这个说明符在不同的地方起的作用是不同的。  </p>
<p> 注意：<br> 对于静态局部变量的理解：  </p>
<ol>
<li>若全局变量仅在单个函数中使用，则可以将这个变量修改为改函数的静态局部变量  </li>
<li>由于被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值<br>直观的例子：<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k,ii = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    ii++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ii = %d\n"</span>,ii);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"j = %d\n"</span>,j);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)</span><br><span class="line">    {</span><br><span class="line">	func1();</span><br><span class="line">	func2();</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<ol start="2">
<li><strong>修饰函数</strong><br>函数前加static使得函数成为静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件（所以又称为内部函数）。</li>
</ol>
<ol start="3">
<li><p><strong>C++里对static赋予了第三个作用（如果成员声明为static，可以在外部直接访问）</strong>  </p>
<ol>
<li>静态数据成员  </li>
</ol>
</li>
</ol>
<ul>
<li>静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一个内存，供所有对象共用  </li>
<li>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义  <ol start="2">
<li>静态成员函数  </li>
</ol>
</li>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数  </li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员  </li>
<li>静态成员函数不能访问非静态成员函数（不包括构造函数）和非静态数据成员  </li>
</ul>
<h1 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h1><p>int i = 0;<br>A). sizeof(int);<br>B). sizeof(i);<br>C). sizeof int;<br>D). sizeof i;<br>A、B和D都正确，C错误。  </p>
<blockquote>
<p>sizeof(int) *p表示什么意思？<br>32位系统下：<br>int *p = NULL;<br>sizeof(p)的值是多少？ 4<br>sizeof(*p)呢？ 4<br>char *q = NULL;<br>sizeof(q)的值是多少？ 4<br>sizeof(*q)呢？ 1<br>int a[100];<br>sizeof (a) 的值是多少？ 400<br>sizeof(a[100])呢？ 4<br>sizeof(&amp;a)呢？ 4<br>sizeof(&amp;a[0])呢？ 4<br>int b[100];<br>void fun(int b[100])<br>{<br>    sizeof(b);// sizeof (b) 的值是多少？是个指针类型，把 int b[100] 改为 char b[100] 也是输出 4<br>}  </p>
</blockquote>
<h1 id="与零值比较"><a href="#与零值比较" class="headerlink" title="与零值比较"></a>与零值比较</h1><ol>
<li><p>bool变量<br> bool bTestFlag = FALSE;//为什么一般初始化为FALSE比较好？<br> FALSE在编译器里被定义为0，而TRUE则不一定是1，不同的编译器有不同的定义。  </p>
</li>
<li><p>float变量<br> float fTestVal = 0.0;<br> const float EPSINON = 0.00001;<br> if((fTestVal &gt;= -EPSIONON) &amp;&amp; (fTestVal &lt;= EPSINON))  </p>
</li>
</ol>
<h1 id="return关键字"><a href="#return关键字" class="headerlink" title="return关键字"></a>return关键字</h1><p>return可以返回些什么东西？如：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>str属于局部变量，位于栈内存中，在Func结束的时候被释放，所以返回str会导致错误。<br>规则：return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁。  </p>
<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><ol>
<li><p>const修饰的是只读变量，而不是常量  </p>
</li>
<li><p>节省空间，避免不必要的内存分配，同时提高效率<br> 例如：  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 <span class="comment">//宏常量</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>; <span class="comment">//此时并未将 N 放入内存中</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> i = N; <span class="comment">//此时为 N 分配内存，以后不再分配</span></span><br><span class="line"><span class="keyword">int</span> I = M; <span class="comment">//预编译期间进行宏替换，分配内存</span></span><br><span class="line"><span class="keyword">int</span> j = N; <span class="comment">//没有内存分配</span></span><br><span class="line"><span class="keyword">int</span> J = M; <span class="comment">//再进行宏替换，又一次分配内存</span></span><br></pre></td></tr></tbody></table></figure>

<p> const定义的只读变量从汇编的角度看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的只读变量在程序运行过程中只有一份拷贝（因为它是全局的只读变量，存放在静态区），而#define定义的宏常量在内存中有若干个拷贝。#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。#define宏没有类型，而const修饰的只读变量具有特定的类型。  </p>
</li>
</ol>
<p>注意：  </p>
<ul>
<li>当const修饰指针时  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p; <span class="comment">// p 可变，p 指向的对象不可变</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p; <span class="comment">// p 可变，p 指向的对象不可变</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// p 不可变，p 指向的对象可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p; <span class="comment">// 指针 p 和 p 指向的对象都不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">//前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>const修饰函数返回值（返回指针）<br>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。<br>例如函数：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
如下语句将出现编译错误：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = GetString();</span><br></pre></td></tr></tbody></table></figure>
正确的用法是：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = GetString();</span><br></pre></td></tr></tbody></table></figure></li>
<li>const修饰的只读变量不能用来作为定义数组的维数，也不能放在case关键字后面。  </li>
<li>常量指针与指针常量的区别<br>*（指针）和const（常量）谁在前先读谁；* 象征着地址，const 象征着内容；谁在前面谁就不允许改变。  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;b; <span class="comment">// const 在前，定义为常量指针</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;c; <span class="comment">// * 在前，定义为指针常量</span></span><br><span class="line"><span class="comment">//常量指针p1: 指向的地址可以变，但内容不可以重新赋值，内容的改变只能通过修改地址指向后变换。</span></span><br><span class="line"><span class="comment">//指针常量p2: 指向的地址不可以重新赋值，但内容可以改变，必须初始化，地址跟随一生。</span></span><br></pre></td></tr></tbody></table></figure>
问：C语言函数返回值为 const 型 有什么意义？<br>答：当为指针时，有意义，一般数值没有意义 当返回为const指针时，表示对返回指针所指向的数据内容不要进行修改。有修改则程序会报错。  </li>
<li>C语言可以通过指针修改const修饰的只读变量  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, *p, a);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ol>
<li><p>空结构体占一个字节</p>
</li>
<li><p>柔性数组</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 柔性数组允许在定义结构体的时候创建一个空数组，而这个数组的大小可以在程序运行的过程中根据你的需求进行更改<br> 这个空数组必须声明为结构体的最后一个成员，并且还要求这样的结构体至少包含一个其他类型的成员<br> 柔性数组不占用内存<br> 给结构体分配内存：  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">test *stpTest = (test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//分配100</span></span><br><span class="line">test *stpTest = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*test) + <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">strlen</span>(paddress) + <span class="number">1</span>); <span class="comment">//动态分配</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在 C++里 struct 关键字与 class 关键字一般可以通用，只有一个很小的区别。struct 的成员默认情况下属性是 public 的，而 class 成员却是 private 的。  </p>
</li>
<li><p>union维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。  </p>
</li>
<li><p>大端模式（ Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放 在高地址中。 小端模式（ Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放 在低地址中。<br> 判断系统大小端的方法 – 可以利用union类型数据的特点：所有成员的起始地址一致  </p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">check</span></span></span><br><span class="line"><span class="class">	{</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">	}c;</span><br><span class="line">	c.i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> (c.ch == <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	checkSystem() == <span class="number">1</span> ? <span class="built_in">printf</span>(<span class="string">"Little-endian/n"</span>) : <span class="built_in">printf</span>(<span class="string">"Big-endian/n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 在 x86 系统下，输出的值为多少？ // x86 - 小端</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">	<span class="keyword">int</span> *prt1 = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> *ptr2 = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %x\n"</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 答案： 5，2000000</span></span><br><span class="line"><span class="comment">// 解释：</span></span><br><span class="line"><span class="comment">// a 是数组首元素的首地址，而 &amp;a 是整个数组的首地址，a+1 是偏移 int 个字节， 而 &amp;a+1 是偏移整个数组的大小</span></span><br><span class="line"><span class="comment">// 所以，此题 &amp;a+1 偏移 20 个字节，ptr1[-1] = 5</span></span><br><span class="line"><span class="comment">// 数组 a 的分布是：{01 00 00 00， 02 00 00 00， 03 00 00 00， 04 00 00 00， 05 00 00 00}，地址从左到右递增</span></span><br><span class="line"><span class="comment">// (int)a + 1 是向后移动了 1 个字节，即 00 00 00 02，由于是小端，所以 02 00 00 00</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="define用法"><a href="#define用法" class="headerlink" title="#define用法"></a>#define用法</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR char*</span></span><br><span class="line">PCHAR p3,p4; <span class="comment">// 等效于 char * p3,p4;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR (char*)</span></span><br><span class="line">PCHAR p3,p4; <span class="comment">// 等效于 (char *) p3,p4;</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y X*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X 2</span></span><br><span class="line"><span class="keyword">int</span> z = Y;</span><br><span class="line"><span class="comment">// z 的值是多少？ 4</span></span><br></pre></td></tr></tbody></table></figure>


<h1 id="除法与取余运算"><a href="#除法与取余运算" class="headerlink" title="除法与取余运算"></a>除法与取余运算</h1><p>参与运算的量均为整形时，结果为整形，舍去小数。如果运算量中有一个为实型，结果为双精度实型。<br>例如：5/2=2, 1/2=0, 5/2.0=2.5<br>参与运算的量均为整形，求余运算的结果等于两个数相除后的余数。<br>例如：5%2=1, 1%2=1</p>
<p>5%2.0和5.0%2的结果是语法错误  </p>
<p>除号的正负取舍和一般的算数一样，符号相同为正，相异为负,求余符号的正负取舍和被除数符号相同。<br>-3/16=0, 16/-3=-5, -3%16=-3, 16%-3=1  </p>
<p>printf(“%d\n”,10/2.5);<br>整形数据默认为int，实型数据默认为double。<br>整形只能使用整形说明符 %d 等。<br>实型只能使用实型说明符。  </p>
<h1 id="pragma预处理"><a href="#pragma预处理" class="headerlink" title="#pragma预处理"></a>#pragma预处理</h1><ul>
<li>#pragma message(“消息文本”)<br>  当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。<br>  假设我们希望判断自己有没有在源代码的什么地方定义了_X86 这个宏可以用下面的方法    <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _X86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message(“_X86 macro activated!”)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。<br><img src="https://i.loli.net/2020/01/07/zawc7EXiB19HSU4.png" alt="32位CPU与内存模型.png">  </p>
<p>举例：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> x1;</span><br><span class="line">    <span class="keyword">short</span> x2;</span><br><span class="line">    <span class="keyword">float</span> x3;</span><br><span class="line">    <span class="keyword">char</span> x4;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于编译器默认情况下会对这个struct作自然边界对齐，结构的第一个成员x1，其偏移地址为0，占据了第1个字节。第二个成员x2为short类型，其起始地址必须2字节对界，因此，编译器在x2和x1之间填充了一个空字节。结构的第三个成员x3和第四个成员x4恰好落在其自然边界地址上，在它们前面不需要额外的填充字节。在test结构中，成员x3要求4字节对界，是该结构所有成员中要求的最大边界单元，因而test结构的自然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。  </p>
<p>使用指令#pragma pack (n)，编译器将按照 n 个字节对齐。<br>使用指令#pragma pack ()，编译器将取消自定义字节对齐方式。<br>在#pragma pack (n)和#pragma pack ()之间的代码按 n 个字节对齐。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct4</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">long</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct5</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    TestStruct4 d;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> e;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack ()</span></span><br></pre></td></tr></tbody></table></figure>
<p>问题：</p>
<ol>
<li>sizeof(TestStruct5)等于多少？  </li>
<li>TestStruct5 的 c 后面空了几个字节接着是 d？  </li>
</ol>
<p>TestStruct5 中,c 和 TestStruct4 中的 a 一样,按 1 字节对齐,而 d 是个结构,它是 8 个字节,它按什么对齐呢？<br>对于结构来说，它的默认对齐方式就是它的所有成员使用的对齐参数中最大的一个, TestStruct4 的就是 4 。<br>(复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度)  </p>
<p>TestStruct4的内存布局：  </p>
<table>
<thead>
<tr>
<th align="left">a</th>
<th align="left">b</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1***</td>
<td align="left">1111</td>
</tr>
</tbody></table>
<p>TestStruct5的内存布局：  </p>
<table>
<thead>
<tr>
<th align="left">c</th>
<th align="left">a</th>
<th align="left">b</th>
<th align="left">e</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1***</td>
<td align="left">1***</td>
<td align="left">1111****</td>
<td align="left">11111111</td>
</tr>
</tbody></table>
<p>答案：</p>
<ol>
<li>24  </li>
<li>3  </li>
</ol>
<p>注意：<br>对于数组,比如:char a[3];它的对齐方式和分别写 3 个 char 是一样的.也就是说，它还是按 1 个字节对齐.如果写: typedef char Array3[3];Array3 这种类型的对齐方式还是按 1 个字节对齐,而不是按它的长度。  </p>
<p>补充：联合体内存对齐的问题  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例1：</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">}u;</span><br><span class="line"><span class="comment">//sizeof(u) = 16</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例2：</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> a1;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> height;</span><br><span class="line">}stu;</span><br><span class="line"><span class="comment">//sizeof(stu) = 24</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//例3：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        <span class="keyword">long</span> a;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        {</span></span><br><span class="line">            <span class="keyword">char</span> a1;</span><br><span class="line">            <span class="keyword">short</span> a2;</span><br><span class="line">            <span class="keyword">char</span> a3;</span><br><span class="line">        }st_a;</span><br><span class="line">    }un_a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(un_a.st_a)), (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(un_a)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//sizeof(un_a.st_a) = 6</span></span><br><span class="line"><span class="comment">//sizeof(un_a) = 8</span></span><br></pre></td></tr></tbody></table></figure>
<p>从这里可以看出联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：  </p>
<ol>
<li>大小足够容纳最宽的成员  </li>
<li>大小能被其包含的所有基本数据类型的大小所整除</li>
</ol>
<h1 id="a-i"><a href="#a-i" class="headerlink" title="a[i]"></a>a[i]</h1><p>对于数组a[i]<br>数组首元素的地址：a、&amp;a[0]<br>数组的地址：&amp;a  </p>
<h1 id="指针和数组的定义与声明"><a href="#指针和数组的定义与声明" class="headerlink" title="指针和数组的定义与声明"></a>指针和数组的定义与声明</h1><ol>
<li><p>编译器会把存在指针变量中的任何数据当做地址来处理  </p>
</li>
<li><p>定义为数组，声明为指针<br> 文件1：char a[100]; //定义了数组a<br> 文件2：extern char *a; //声明它为指针 //这样做是错的  </p>
<p> 解析：extern char a[] 与 extern char a[100] 等价的原因，因为这是声明，不分配空间，所以编译器无需知道这个数组有多少个元素。这两个声明都告诉编译器 a 是在别的文件中被定义的一个数组， a 同时代表数组 a 的首元素的首地址，也就是这块内存的起始地址。数组内任何元素的地址都只需要知道这个地址就可以计算出来。但是，当你声明为 extern char *a 时，编译器理所当然的认为 a 是一个指针变量，在 32 位系统下，占 4 个 byte。这 4 个 byte 里保存了一个地址，这个地址上存的是字符类型数据。虽然在文件 1 中，编译器知道 a 是一个数组，但是在文件 2 中，编译器并不知道这点。大多数编译器是按文件分别编译的，编译器只按照本文件中声明的类型来处理。所以，虽然 a 实际大小为 100 个 byte，但是在文件 2 中，编译器认为 a 只占 4 个 byte。  </p>
</li>
<li><p>定义为指针，声明为数组<br> 文件1：char *p = “abcdefg”;<br> 文件2：extern char p[]; //这样的做法也是错误的</p>
<p> 解析：在文件 1 中， 编译器分配 4 个 byte 空间， 并命名为 p。 同时 p 里保存了字符串常量 “ abcdefg” 的首字符的首地址。这个字符串常量本身保存在内存的静态区，其内容不可更改。在文件 2 中，编译器认为 p 是一个数组，其大小为 4 个 byte，数组内保存的是 char 类型的数据。  </p>
</li>
</ol>
<h1 id="地址的强制转换"><a href="#地址的强制转换" class="headerlink" title="地址的强制转换"></a>地址的强制转换</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="keyword">char</span> *pcName;</span><br><span class="line">    <span class="keyword">short</span> sDate;</span><br><span class="line">    <span class="keyword">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">}*p;</span><br></pre></td></tr></tbody></table></figure>
<p>假设 p 的值为 0x100000，如下表达式的值分别为多少？  </p>
<ol>
<li>p + 0x1 = 0x____ ?  </li>
<li>(unsigned long) p + 0x1 = 0x____ ?  </li>
<li>(unsigned int *) p + 0x1 = 0x____ ?  </li>
</ol>
<p>指针变量与一个整数相加减并不是用指针变量里的地址直接加减这个整数。  </p>
<ol>
<li>p + 0x1 的值为 0x100000 + sizof（ Test） * 0x1 ，此结构体的大小为 20byte，所以 p + 0x1 的值为： 0x100014  </li>
<li>将指针变量 p 保存的值强制转换成无符号的长整型数。任何数值一旦被强制转换，其类型就改变了。所以这个表达式其实就是一个无符号的长整型数加上另一个整数。所以其值为： 0x100001  </li>
<li>p 被强制转换成一个指向无符号整型的指针。所以其值为： 0x100000 + sizeof（ unsigned int） * 0x1，等于 0x100004  </li>
</ol>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="comment">//问&amp;p[4][2] - &amp;a[4][2]的值为多少？</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>前面我们讲过，当数组名 a 作为右值时，代表的是数组首元素的首地址。这里的 a 为二维数组，我们把数组 a 看作是包含 5 个 int 类型元素的一维数组,里面再存储了一个一维数组。如此，则 a 在这里代表的是 a[0]的首地址。 a+1 表示的是一维数组 a 的第二个元素。 a[4]表示的是一维数组 a 的第 5 个元素，而这个元素里又存了一个一维数组。所以&amp;a[4][2]表示的是&amp;a[0][0]+4*5*sizeof(int) + 2*sizeof(int)。  </li>
<li>根据定义， p 是指向一个包含 4 个元素的数组的指针。也就是说 p+1 表示的是指针 p 向后移动了一个“包含 4 个 int 类型元素的数组”。这里 1 的单位是 p 所指向的空间，即4*sizeof(int)。所以， p[4]相对于 p[0]来说是向后移动了 4 个“包含 4 个 int 类型元素的数组”，即&amp;p[4]表示的是&amp;p[0]+4*4*sizeof(int)。由于 p 被初始化为&amp;a[0]，那么&amp;p[4][2]表示的是&amp;a[0][0]+4*4*sizeof(int)+2* sizeof(int)。  </li>
<li>其实我们最简单的办法就是画内存布局图  </li>
</ol>
<h1 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h1><h1 id="一维数组参数"><a href="#一维数组参数" class="headerlink" title="一维数组参数"></a>一维数组参数</h1><p>C语言中，当一维数组作为函数参数的时候，编译器总是把它解析成一个指向其首元素首地址的指针。<br>同样的，函数的返回值也不能是一个数组，而只能是指针。  </p>
<h1 id="一级指针参数"><a href="#一级指针参数" class="headerlink" title="一级指针参数"></a>一级指针参数</h1><p>问： 能否把指针变量本身传递给一个函数？<br>例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> c = p[<span class="number">3</span>]; <span class="comment">//或者是 char c = *(p+3)</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="string">"abcdefg"</span>;</span><br><span class="line">    fun(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>答： 无法把指针变量本身传递给一个函数。<br>func函数实际运行时，对 p2 做一份拷贝，假设其拷贝名为_p2。那传递到func函数内部的就是_p2 而并非 p2 本身。  </p>
<p>再看如下例子：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str); <span class="comment">//free 并没有起作用，内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在运行 strcpy(str,”hello”)语句的时候发生错误。这时候观察 str 的值， 发现仍然为 NULL。也就是说 str 本身并没有改变，我们 malloc 的内存的地址并没有赋给str，而是赋给了_str。而这个_str 是编译器自动分配和回收的，我们根本就无法使用。  </p>
<p>解决方法：  </p>
<ol>
<li>用return  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> * p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetMemory(str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>用二级指针  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span> <span class="params">(<span class="keyword">char</span> ** p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">"hello"</span>);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意，这里的参数是&amp;str 而非 str。这样的话传递过去的是 str 的地址，是一个值。在函数内部，用钥匙("*")来开锁： *(&amp;str)，其值就是 str。所以 malloc 分配的内存地址是真正赋值给了 str 本身。</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="二维数组参数与二维指针参数"><a href="#二维数组参数与二维指针参数" class="headerlink" title="二维数组参数与二维指针参数"></a>二维数组参数与二维指针参数</h1><p>Page 100</p>
<h1 id="函数指针使用"><a href="#函数指针使用" class="headerlink" title="函数指针使用"></a>函数指针使用</h1><h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><h1 id="函数指针数组的指针"><a href="#函数指针数组的指针" class="headerlink" title="函数指针数组的指针"></a>函数指针数组的指针</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>如果参数是指针，且仅作为输入参数用，则应在类型前加const，以防止该指针在函数体内被意外修改。例如：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_copy</span> <span class="params">(<span class="keyword">char</span> *strDestination， <span class="keyword">const</span> <span class="keyword">char</span> *strSource)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li>return语句不可返回指向“栈内存”的“指针”，因为该内存在函数体结束时被自动销毁。例如：  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>在函数体的“入口处”，对参数的有效性进行检查。尤其是指针参数，尽量使用assert宏做入口校验，而不使用if语句校验。  </li>
</ol>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>防止头文件被重复包含  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FN_FILENAME_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FN_FILENAME_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>其中“FN_FILENAME”一般为本头文件名大写，这样可以有效避免重复，因为同一个工程中不可能存在两个同名的头文件。  </p>
<h1 id="常见的内存错误及对策"><a href="#常见的内存错误及对策" class="headerlink" title="常见的内存错误及对策"></a>常见的内存错误及对策</h1><ol>
<li><p>指针没有指向一块合法的内存  </p>
<ol>
<li>结构体成员指针未初始化（解决方法是malloc一块空间）  </li>
<li>没有为结构体指针分配足够的内存  </li>
<li>函数的入口校验  <ul>
<li>不管什么时候，我们使用指针之前一定要确保指针是有效的  </li>
<li>一般在函数入口处使用 assert(NULL != p)对参数进行校验。在非参数的地方使用 if(NULL != p)来校验。但这都有一个要求，即 p 在定义的同时被初始化为 NULL 了  </li>
<li>assert 是一个宏，而不是函数，包含在 assert.h 头文件中。如果其后面括号里的值为假，则程序终止运行，并提示出错；如果后面括号里的值为真，则继续运行后面的代码  </li>
</ul>
</li>
</ol>
</li>
<li><p>为指针分配的内存太小  </p>
</li>
<li><p>内存分配成功，但并未初始化  </p>
</li>
<li><p>内存越界  </p>
</li>
<li><p>内存泄漏<br> 会产生泄漏的内存就是堆上的内存（这里不讨论资源或句柄等泄漏情况），也就是说由 malloc 系列函数或 new 操作符分配的内存。如果用完之后没有及时 free 或 delete，这块内存就无法释放，直到整个程序终止  </p>
<ul>
<li><p>malloc 函数的原型：(void *)malloc(int size)<br>  使用 malloc 函数同样要注意这点：如果所申请的内存块大于目前堆上剩余内存块（整块），则内存分配会失败，函数返回 NULL<br>  既然 malloc 函数申请内存有不成功的可能，那我们在使用指向这块内存的指针时，必须用 if(NULL != p)语句来验证内存确实分配成功了  </p>
</li>
<li><p>内存释放 free函数：free(p)<br>  指针变量 p 本身保存的地址并没有改变，但是它对这个地址处的那块内存却已经没有所有权了。那块被释放的内存里面保存的值也没有改变，只是再也没有办法使用了<br>  如果对 p 连续两次以上使用 free 函数，肯定会发生错误。因为第一使用 free 函数时， p 所属的内存已经被释放，第二次使用时已经无内存可释放了<br>  既然使用 free 函数之后指针变量 p 本身保存的地址并没有改变， 那我们就需要重新把 p的值变为 NULL：p = NULL<br>  释放完块内存之后，没有把指针置 NULL，这个指针就成为了“野指针”，这是很危险的，而且也是经常出错的地方。所以一定要记住一条：free 完之后，一定要给指针置 NULL  </p>
</li>
</ul>
</li>
</ol>
<h1 id="其他典型题目"><a href="#其他典型题目" class="headerlink" title="其他典型题目"></a>其他典型题目</h1><ul>
<li><p>当unsigned类型与signed类型运算时，默认转换成unsigned类型  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-6</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a+b&gt;0\n"</span>);<span class="comment">//这句话被打印</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a+b&lt;0\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> z = a+b;</span><br><span class="line">    <span class="keyword">if</span>(z &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"z&gt;0"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"z&lt;0"</span>);<span class="comment">//这句话被打印</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当int和unsigned int相加时，要将int转化为unsigned int，而int小于0，所以它的最高位是符号位，为1，所以转化的结果是一个很大的正数，在第一个if语句中，是两个“正数”相加，结果自然就大于0了。而在z = a+b这一句时，它把a+b的结果看做一个int类型，而a+b最高位为1，所以z是一个负数，所以打印的是第二个语句。  </p>
</li>
<li><p>在以下数组定义中，正确的有（AD）<br>A) int a[‘a’];<br>B) int a[3.4];<br>C) int a[][4];<br>D) int *a[10];<br>int a[][4]; 不明确的话，就不知道分配多少内存。  </p>
<p>  在定义二维数组的时候对其进行初始化，也可以省略第一维，编译器会根据你的初始化语句自动决定第一维度。（有初始化的时候，第二维的数字代表分配内存的长度，第一维的数字代表分配内存倍数，倍数可以让机器去数，但长度没有的话就不好开辟空间了）  </p>
<p>  多维数组声明时，可以省略第一维，但是不能省略第二维或者更高维的大小。这是由编译器原理限制的。<br>  设有数组int a[m][n]，如果要访问a[i][j]的值，编译器的寻址方式为：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">&amp;a[i][j]=&amp;a[<span class="number">0</span>][<span class="number">0</span>]+i*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n+j*<span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">//注意n为第二维的维数</span></span><br></pre></td></tr></tbody></table></figure>
<p>  因此，可以省略第一维的维数，不能省略其他维的维数。  </p>
</li>
<li><p>printf压栈<br>  例1：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>,++n,++n,n++,++n); <span class="comment">// 9 9 6 9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>,n); <span class="comment">// 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>  例2：  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, i, --i, i, i--);</span><br></pre></td></tr></tbody></table></figure>

<p>  “对于a++的结果，是有ebp寻址函数栈空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。”  </p>
</li>
<li><p>数组和指针  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  结果是：0 0 1 1<br>  解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间。而str5,str6,str7,str8是指针，它们指向相同的常量区域。  </p>
</li>
<li><p>字符串常量</p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* s=<span class="string">"AAA"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">'B'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></tbody></table></figure>
<p>  有什么错？<br>  “AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。<br>  cosnt char* s=”AAA”;<br>  然后又因为是常量，所以对是s[0]的赋值操作是不合法的。  </p>
</li>
<li><p>优先级<br>  () &gt; [] &gt; *  </p>
<p>  指针数组：int *(ap[])<br>  数组指针：int (*ap) []<br>  所以 int * ap[]是指针数组，因为 [] 的优先级高于 *  </p>
<p>  指针函数：int * ( fp() )  // () 优先级高，先与 fp 结合成一个函数，再由 int * 说明这是一个整形的指针函数<br>  函数指针：int (*fp) ()  // () 运算符，自左至右，首先说明 fp 是一个指针，指向一个返回值是整形的函数<br>  所以 int *fp() 是指针函数，因为 () 的优先级高于 *  </p>
</li>
<li><p>定义  </p>
</li>
</ul>
<ol>
<li>变量的定义中，除了 变量名 以外的内容就是该变量的类型<br> int a; a 变量名, int 类型<br> int b[10];   b 变量名  ，int [10] 数组的类型<br> int * p   p  变量名   int * 指针的类型  </li>
<li>数组的定义中，除了 数组名[元素数目] 以外的内容就是该数组的元素类型<br> int a[10]  int 元素类型   整形数组<br> int a [3][5] int[5] 数组类型   二维数组<br> int * p[5]   int *  指针类型  指针数组  </li>
<li>指针的定义中，除了 * 指针变量名，以外的内容就是该指针指向对象的类型<br> int *p;   int 整形    整形指针<br> int (*p)[5];  int[5]  数组    数组指针<br> int (*p) ();      int () 返回值为int类型的函数    函数指针   </li>
</ol>
<ul>
<li><p>函数指针和指针函数<br>函数指针的本质是一个变量，该变量的内容指向一个函数。<br>指针函数的本质是一个函数，只不过其返回值是一个指针类型的变量。  </p>
</li>
<li><p>地址<br>  要对绝对地址0x100000赋值，我们可以用  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="number">0x100000</span> = <span class="number">1234</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>  那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br></pre></td></tr></tbody></table></figure>

<p>  首先要将0x100000强制转换成函数指针,即:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span> (*)())<span class="number">0x100000</span></span><br></pre></td></tr></tbody></table></figure>
<p>  然后再调用它:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br></pre></td></tr></tbody></table></figure>
<p>  用typedef可以看得更直观些:  </p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>为什么有垃圾值？<br>  因为操作系统释放内存只是释放对这个内存地址的使用权限（回收内存空间），下一个变量使用这个内存地址的时候，内存地址上保存的值还是上一次遗留下来的值，这就是垃圾值，因此变量需要初始化。  </p>
</li>
<li><p>如果两指针属于同一数组，则可以相减  </p>
</li>
<li><p>一个字节一个地址。所有的指针变量只占4个字节，用第一个字节的地址表示整个变量的地址。  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>扫台</title>
    <url>/2021/09/16/scan/</url>
    <content><![CDATA[<p>梳理一下扫台流程。</p>
<span id="more"></span>

<p>无论何种扫台方式，都会创建一个ScanThread线程：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;m_thread, <span class="literal">NULL</span>, ScanThread, (<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/ChScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CChScanner::ScanThread</span><span class="params">(<span class="keyword">void</span> *pParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    CChScanner *pThis = (CChScanner *)pParam;</span><br><span class="line">    pThis-&gt;m_scanState = CH_SCAN_STATE_INIT;</span><br><span class="line">    pThis-&gt;m_threadIsRunning = <span class="literal">true</span>;</span><br><span class="line">    pThis-&gt;m_runThread = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pThis-&gt;m_runThread == <span class="literal">true</span>)</span><br><span class="line">        pThis-&gt;<span class="built_in">xWorkerThread</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Manual/seekscan needs to set this variable before ending scan message is sent out.</span></span><br><span class="line">    pThis-&gt;m_threadIsRunning = <span class="literal">false</span>;</span><br><span class="line">    pThis-&gt;m_cancelScan = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ScanThread线程的整个扫台状态机xWorkerThread：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xWorkerThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Verify scan mode is valid.</span></span><br><span class="line">    <span class="keyword">if</span> ((m_scanMode == CH_SCAN_MODE_IDLE) || (m_scanMode &gt;= CH_SCAN_MODE_MAX))</span><br><span class="line">        <span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (m_scanState)</span><br><span class="line">    {</span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_INIT:</span><br><span class="line">            	<span class="built_in">xStageInit</span>();</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_BEGIN_FREQ:</span><br><span class="line">            	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_BEGIN_FREQ start\n"</span>, __func__, __LINE__);</span><br><span class="line">            	<span class="built_in">xStageBeginFreq</span>();</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_SCANNING:</span><br><span class="line">            	<span class="comment">// wait scan done</span></span><br><span class="line">            	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING start\n"</span>, __func__, __LINE__);</span><br><span class="line">            	<span class="keyword">while</span> (!m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>())</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    m_pFreqScanDetector-&gt;<span class="built_in">RunStateProc</span>();</span><br><span class="line">                    <span class="keyword">if</span> (m_cancelScan != <span class="literal">true</span> &amp;&amp; !m_pFreqScanDetector-&gt;<span class="built_in">Mf_IsScanDone</span>())</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(m_scanMode == CH_SCAN_MODE_BLIND_SCAN||m_scanMode == CH_SCAN_MODE_BLIND_SCAN_NETWORK)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">int</span> Index = <span class="number">0</span>, Total = <span class="number">0</span>;</span><br><span class="line">                            UINT32 freq = m_pFreqScanDetector-&gt;<span class="built_in">Mf_GetFrequency</span>(&amp;Index,&amp;Total);</span><br><span class="line">                            <span class="keyword">if</span>(freq&gt;<span class="number">0</span>)</span><br><span class="line">                            {</span><br><span class="line">                                m_curFreqIndex = Index;</span><br><span class="line">                                m_freqListSize = Total;</span><br><span class="line">                                m_curFreq = freq;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="built_in">usleep</span>(SCAN_THREAD_CS_TIME*<span class="number">1000</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_SCANNING end\n"</span>, __func__, __LINE__);</span><br><span class="line">            	m_scanState = CH_SCAN_STATE_END_FREQ;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_END_FREQ:</span><br><span class="line">            	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] CH_SCAN_STATE_END_FREQ begin\n"</span>, __func__, __LINE__);</span><br><span class="line">            	<span class="built_in">xStageEndFreq</span>();</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_SCAN_FAILED:</span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_EXIT:</span><br><span class="line">            	<span class="built_in">xStageExit</span>();</span><br><span class="line">            	<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CH_SCAN_STATE_IDLE:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            	<span class="keyword">goto</span> EXIT_SCANNING;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (m_cancelScan == <span class="literal">true</span>)</span><br><span class="line">        m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">EXIT_SCANNING:</span><br><span class="line">    m_runThread = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="CH-SCAN-STATE-INIT"><a href="#CH-SCAN-STATE-INIT" class="headerlink" title="CH_SCAN_STATE_INIT"></a>CH_SCAN_STATE_INIT</h3><p>xWorkerThread状态机运行前，ScanThread设置了状态机初始状态<strong>CH_SCAN_STATE_INIT</strong>，等状态机正式开始，xStageInit()函数做了一些初始化工作，比如：扫台模式设置、一些状态位初始化、si状态设置等等。大致涉及的函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xStageInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanInit</span>(scanMode, param, m_bDelNosignalMux,scanModeEx);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_scanState = CH_SCAN_STATE_BEGIN_FREQ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanInit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CH_SCAN_MODE scanMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 param,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> bDelNoSignalMux,</span></span></span><br><span class="line"><span class="params"><span class="function">    CH_SCAN_MODE_EX modeEx</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanInit</span>(<span class="built_in">getSiScanType</span>(scanMode), param, typeEx);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Si/DvbSiMgr.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanInit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_MGR_SCAN_TYPE type,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> antennaIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_MGR_SCAN_TYPE_EX typeEx</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI *siHandle = (SI*)m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>()-&gt;<span class="built_in">GetSiHandle</span>();</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="built_in">SI_SetState</span>(siHandle, SI_STATE_AUTOSCAN);</span><br><span class="line">    <span class="built_in">SI_AutoScanInit</span>(siHandle,antennaIndex,type==SI_MGR_SCAN_TYPE_AUTO_QUICK?TRUE:FALSE,FALSE);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/api/SI_Api.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_AutoScanInit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI *pSI,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> antennaIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bSkipPMT,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bUpdateMode</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(bSkipPMT||SI_IS_UNITYMEDIA(pSI))</span><br><span class="line">    {</span><br><span class="line">        pSI-&gt;bSkipPMT=TRUE;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pSI-&gt;bSkipPMT=FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    SI_Database_Reset(pSI-&gt;db,antennaIndex,TRUE);</span><br><span class="line">    SI_Channel_Reset(pSI-&gt;chMgr,antennaIndex,pSI-&gt;spec,pSI,SI_IS_SATELLITE(pSI));</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    setRelocatedService(pSI,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    SiMessage_Reset(&amp;pSI-&gt;mq);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后把状态设置为<strong>CH_SCAN_STATE_BEGIN_FREQ</strong>。</p>
<h3 id="CH-SCAN-STATE-BEGIN-FREQ"><a href="#CH-SCAN-STATE-BEGIN-FREQ" class="headerlink" title="CH_SCAN_STATE_BEGIN_FREQ"></a>CH_SCAN_STATE_BEGIN_FREQ</h3><p>在这个状态里，xStageBeginFreq()函数好像也是做一些初始化工作而已，如果是DVB-S盲扫，则在这里根据LNB Type设置不同的盲扫流程，以及根据本振频率设定扫台的起始频率和范围：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xStageBeginFreq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">    <span class="keyword">if</span>(m_scanMode == CH_SCAN_MODE_BLIND_SCAN||m_scanMode == CH_SCAN_MODE_BLIND_SCAN_NETWORK)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 省略代码段</span></span><br><span class="line">        <span class="comment">/*Low/Horizontal,Low/Vertical,High/Horizontal,High/Vertical*/</span></span><br><span class="line">        <span class="keyword">if</span>(lnbType != LNB_TYPE_KU_UNIVERSAL) <span class="comment">// 单本振盲扫</span></span><br><span class="line">        {</span><br><span class="line">            m_blindScanTotalStep=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(m_blindScanStep==<span class="number">0</span>) <span class="comment">// 单本振盲扫 第一阶段</span></span><br><span class="line">            {</span><br><span class="line">                m_curLoHz = loLow*<span class="number">100000</span>;</span><br><span class="line">                m_curPolarization=<span class="number">0</span>;</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_blindScanStep==<span class="number">1</span>) <span class="comment">// 单本振盲扫 第二阶段</span></span><br><span class="line">            {</span><br><span class="line">                m_curLoHz = loLow*<span class="number">100000</span>;</span><br><span class="line">                m_curPolarization=<span class="number">1</span>;</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 双本振盲扫</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">bool</span> bIsCBand = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>((loLow == <span class="number">5150</span>) &amp;&amp; (loHigh == <span class="number">5750</span>))</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">/*Low/Horizontal,,High/Vertical*/</span></span><br><span class="line">                bIsCBand = <span class="literal">true</span>;</span><br><span class="line">                m_blindScanTotalStep=<span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                m_blindScanTotalStep=<span class="number">4</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(m_blindScanStep==<span class="number">0</span>) <span class="comment">// 双本振盲扫 C波段和Ku波段 第一阶段 Low/Horizontal</span></span><br><span class="line">            {</span><br><span class="line">                m_curLoHz = loLow*<span class="number">100000</span>;</span><br><span class="line">                m_curPolarization=<span class="number">0</span>;</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_blindScanStep==<span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(bIsCBand) <span class="comment">// 双本振盲扫 C波段 第二阶段 High/Vertical</span></span><br><span class="line">                {</span><br><span class="line">                    m_curLoHz = loHigh*<span class="number">100000</span>;</span><br><span class="line">                    m_curPolarization=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 双本振盲扫 Ku波段 第二阶段 Low/Vertical</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">/* coverity[copy_paste_error : FALSE] */</span></span><br><span class="line">                    m_curLoHz = loLow*<span class="number">100000</span>;</span><br><span class="line">                    m_curPolarization=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_blindScanStep&gt;=m_blindScanTotalStep)</span><br><span class="line">            {</span><br><span class="line">                m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_blindScanStep==<span class="number">2</span>) <span class="comment">// 双本振盲扫 Ku波段 第三阶段 High/Horizontal</span></span><br><span class="line">            {</span><br><span class="line">                m_curLoHz = loHigh*<span class="number">100000</span>;</span><br><span class="line">                m_curPolarization=<span class="number">0</span>;</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_blindScanStep==<span class="number">3</span>) <span class="comment">// 双本振盲扫 Ku波段 第四阶段 High/Vertical</span></span><br><span class="line">            {</span><br><span class="line">                m_curLoHz = loHigh*<span class="number">100000</span>;</span><br><span class="line">                m_curPolarization=<span class="number">1</span>;</span><br><span class="line">                m_blindScanStep++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                m_scanState = CH_SCAN_STATE_EXIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        #define kCBandMinFreq  950</span></span><br><span class="line"><span class="comment">        #define kCBandMaxFreq  1750</span></span><br><span class="line"><span class="comment">        #define kCBandScanRange  (kCBandMaxFreq-kCBandMinFreq)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        #define kKuBandLowIFMinFreq  950</span></span><br><span class="line"><span class="comment">        #define kKuBandLowIFMaxFreq  1950</span></span><br><span class="line"><span class="comment">        #define kKuBandHightMinFreq  1100</span></span><br><span class="line"><span class="comment">        #define kKuBandHightMaxFreq  2150</span></span><br><span class="line"><span class="comment">        #define kKuBandLowScanRange  (kKuBandLowIFMaxFreq-kKuBandLowIFMinFreq)</span></span><br><span class="line"><span class="comment">        #define kKuBandHighScanRange  (kKuBandHightMaxFreq-kKuBandHightMinFreq)</span></span><br><span class="line"><span class="comment">        #define kKuBandFullScanRange  (kKuBandHightMaxFreq - kKuBandLowIFMinFreq)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(satInfo.bandType==SATELLITE_BAND_C)</span><br><span class="line">        {</span><br><span class="line">            ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanRange</span>(kCBandScanRange); <span class="comment">// 1750 - 950 //这里有点不懂</span></span><br><span class="line">            ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanStartFreq</span>(kCBandMinFreq); <span class="comment">// 950</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(satInfo.bandType==SATELLITE_BAND_KU)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(m_curLoHz == loLow*kFreqUnit)</span><br><span class="line">            {</span><br><span class="line">                ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanRange</span>(kKuBandLowScanRange); <span class="comment">// 1950 - 950</span></span><br><span class="line">                ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanStartFreq</span>(kKuBandLowIFMinFreq); <span class="comment">// 950</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanRange</span>(kKuBandHighScanRange); <span class="comment">// 2150 - 1100</span></span><br><span class="line">                ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanStartFreq</span>(kKuBandHightMinFreq); <span class="comment">// 1100</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanRange</span>(kKuBandFullScanRange); <span class="comment">// 2150 - 950</span></span><br><span class="line">            ((CDtvFreqDetector*) m_pFreqScanDetector)-&gt;<span class="built_in">SetBlindScanStartFreq</span>(kKuBandLowIFMinFreq); <span class="comment">// 950</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 省略代码段</span></span><br><span class="line">        m_pFreqScanDetector-&gt;<span class="built_in">Mf_BlindScan</span>(m_satelliteIndex,m_curLoHz, m_curPolarization);</span><br><span class="line">        m_scanState = CH_SCAN_STATE_SCANNING;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(m_curFreq!=<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanFrequency</span>(m_curFreq, m_curBandwidth, m_curChNum,m_curModulation,m_curSymbolRate,CH_SCAN_MODE_MANUAL==m_scanMode ? m_serviceID : <span class="number">0</span>,(CH_SCAN_MODE_UPDATE==m_scanMode||CH_SCAN_MODE_NETWORK_UPDATE==m_scanMode||CH_SCAN_MODE_ASU==m_scanMode)?<span class="literal">false</span>:<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    m_scanState = CH_SCAN_STATE_SCANNING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后把xWorkerThread状态机设置为<strong>CH_SCAN_STATE_SCANNING</strong>（该状态会建立一个另一个状态机RunStateProc）之前，把RunStateProc状态机初始设置为<em><strong>FREQ_SCAN_STATE_BEGIN_FREQ</strong></em>（Mf_ScanFrequency函数行为）或<em><strong>FREQ_SCAN_STATE_BEGIN_BLIND_SCAN</strong></em>（Mf_BlindScan函数行为）（DVB-S盲扫）。</p>
<h3 id="CH-SCAN-STATE-SCANNING"><a href="#CH-SCAN-STATE-SCANNING" class="headerlink" title="CH_SCAN_STATE_SCANNING"></a>CH_SCAN_STATE_SCANNING</h3><p>RunStateProc的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::RunStateProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (m_scanState)</span><br><span class="line">	{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_BEGIN_BLIND_SCAN:</span><br><span class="line">		<span class="built_in">xStageBeginBlindScan</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_BLIND_COLLECT_TP:</span><br><span class="line">		<span class="built_in">xStageBlindCollectTP</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_BLIND_SCAN_TP:</span><br><span class="line">		<span class="built_in">xStageBlindScanTP</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_BEGIN_FREQ:</span><br><span class="line">		<span class="built_in">xStageBeginFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_CHECK_FRONTEND:</span><br><span class="line">		<span class="built_in">xStageCheckFrontend</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_CHECK_SI:</span><br><span class="line">		<span class="built_in">xStageCheckSi</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FREQ_SCAN_STATE_END_FREQ:</span><br><span class="line">		<span class="built_in">xStageEndFreq</span>();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_bCancelScan == <span class="literal">true</span>)</span><br><span class="line">	{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">		<span class="keyword">if</span>(m_curLoHz!=<span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> tunerId = <span class="number">-1</span>;</span><br><span class="line">			tuner-&gt;<span class="built_in">getTunerId</span>(tunerId);</span><br><span class="line">			m_curBlindFreq=<span class="number">0</span>;</span><br><span class="line">			m_curLoHz=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">TunerControlBlindScanEnd</span>(tunerId);</span><br><span class="line">		}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		m_scanState = FREQ_SCAN_STATE_IDLE;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>xWorkerThread状态机<strong>CH_SCAN_STATE_BEGIN_FREQ</strong>阶段，已经初始化了RunStateProc的状态。</p>
<h4 id="FREQ-SCAN-STATE-BEGIN-FREQ"><a href="#FREQ-SCAN-STATE-BEGIN-FREQ" class="headerlink" title="FREQ_SCAN_STATE_BEGIN_FREQ"></a>FREQ_SCAN_STATE_BEGIN_FREQ</h4><p>对于每个频点，率先运行<em><strong>FREQ_SCAN_STATE_BEGIN_FREQ</strong></em>，xStageBeginFreq()这里主要干的事情：</p>
<ol>
<li><p>stop SI</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetMode</span>(SI_MGR_MODE_INACTIVE);</span><br><span class="line">m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ResetTp</span>();</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>把Tuner相关参数下给Demod，让Demod设置好Tuner，然后去check Tuner lock status</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = tuner-&gt;<span class="built_in">tune</span>(m_curFreq, m_curBandwidth, m_feType, m_modulation, RT_INVERSION_AUTO, <span class="literal">true</span>, m_symbolrate, &amp;satInfo);</span><br><span class="line"><span class="comment">// 省略代码段</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">{</span><br><span class="line">    ret = tuner-&gt;<span class="built_in">isLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"signal LOCKED !!!!!!!!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">"signal UNLOCKD!!!!!!!!!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//SetTuner fail or GetLock fail</span></span><br><span class="line">{</span><br><span class="line">    ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">"get lock Status FAIL!!!!! ERROR\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret)</span><br><span class="line">{</span><br><span class="line">    m_curPlpIndex = <span class="number">0</span>;</span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_CHECK_FRONTEND;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// Lock fail case</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(m_bDelNoSignalMux)</span><br><span class="line">    {</span><br><span class="line">        m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">RemoveCh</span>(m_curFreq, m_bDelManualScanService);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetSignalInfo</span>(<span class="number">0</span>, <span class="number">0</span>, m_curFreq);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这一阶段算是完了。</p>
<p>关注一下这个tune函数（以下用到的代码主要以DVB-T扫台为例，当然也有制式共用的）：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* DriverBasedDtvApp/TunerMgr.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TunerMgr::tune</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 frequency,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 bandwidth,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_FRONTEND_TYPE feType,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_MODULATION modulation,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_SPECTRAL_INVERSION inversion,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> isScanMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 symbolRate,</span></span></span><br><span class="line"><span class="params"><span class="function">    SatelliteInfo *pSatelliteInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	mFreq = frequency;</span><br><span class="line">	mBandwidth = bandwidth;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">FrontendLib_SetTuner</span>(frequency, bandwidth, mTunerId, feType, modulation, inversion, isScanMode, symbolRate, pSatelliteInfo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* DriverBasedDtvApp/FrontendLib.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FrontendLib_SetTuner</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 frequency,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 bandwidth,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT8 tunerId,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_FRONTEND_TYPE feType,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_MODULATION modulation,</span></span></span><br><span class="line"><span class="params"><span class="function">    RT_SPECTRAL_INVERSION inversion,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> isScanMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 symbolRate,</span></span></span><br><span class="line"><span class="params"><span class="function">    SatelliteInfo* pSatelliteInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> tuner_ctrl_status;</span><br><span class="line">	TV_SIG_INFO signalInfo;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> buf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (frequency == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;signalInfo,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(signalInfo));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		re-adjust feType!?</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (feType == RT_FRONTEND_DVB_TERRESTRIAL || feType == RT_FRONTEND_DVB_T2)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FRONTENDLIB_GET_DVB_T2_PLP_INDEX</span>(frequency) &gt;= <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			feType = RT_FRONTEND_DVB_T2;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			feType = RT_FRONTEND_DVB_TERRESTRIAL;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_PROFILE</span></span><br><span class="line"><span class="built_in">RtProfile_TimeBegin</span>(RT_PROFILE_1);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	TV_SYSTEM tvSystem = <span class="built_in">xFrontendLib_GetTunerSystem</span>(feType, bandwidth);</span><br><span class="line">	<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] frequency=%d bandwidth=%d tvSystem=%d\n"</span>, __LINE__, frequency,bandwidth,tvSystem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (feType == RT_FRONTEND_DVB_TERRESTRIAL)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBT_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		signalInfo.dvbt2_ofdm.scan_mode = isScanMode;</span><br><span class="line">		signalInfo.mod=TV_MODULATION_OFDM;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FRONTENDLIB_IS_HIERARCHY_MODE</span>(frequency) != <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			signalInfo.ofdm.hierarchy=HIERARCHY_MODE_LOW;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			signalInfo.ofdm.hierarchy=HIERARCHY_MODE_HIGH;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isScanMode == <span class="literal">true</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(tvSystem == TV_SYS_DVBT_6M)</span><br><span class="line">				tvSystem = TV_SYS_AUTOSCAN_6M;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(tvSystem==TV_SYS_DVBT_7M)</span><br><span class="line">				tvSystem = TV_SYS_AUTOSCAN_7M;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				tvSystem = TV_SYS_AUTOSCAN_8M;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId,buf,tvSystem,&amp;signalInfo,isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_DVB_T2)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBT2_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		signalInfo.dvbt2_ofdm.scan_mode = isScanMode;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> plpId = <span class="built_in">FRONTENDLIB_GET_DVB_T2_PLP_INDEX</span>(frequency);</span><br><span class="line">		<span class="keyword">if</span> (plpId &gt;= <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			signalInfo.dvbt2_ofdm.plp_select = plpId;</span><br><span class="line">			<span class="keyword">if</span>(isScanMode == <span class="literal">true</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span>(tvSystem == TV_SYS_DVBT2_1D7M)</span><br><span class="line">					tvSystem = TV_SYS_DVBT2_1D7M_PLP;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(tvSystem == TV_SYS_DVBT2_6M)</span><br><span class="line">					tvSystem = TV_SYS_DVBT2_6M_PLP;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(tvSystem == TV_SYS_DVBT2_7M)</span><br><span class="line">					tvSystem = TV_SYS_DVBT2_7M_PLP;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tvSystem = TV_SYS_DVBT2_8M_PLP;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(isScanMode == <span class="literal">true</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span>(tvSystem==TV_SYS_DVBT2_6M)</span><br><span class="line">					tvSystem = TV_SYS_AUTOSCAN_6M;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(tvSystem==TV_SYS_DVBT2_7M)</span><br><span class="line">					tvSystem = TV_SYS_AUTOSCAN_7M;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					tvSystem = TV_SYS_AUTOSCAN_8M;</span><br><span class="line">			}</span><br><span class="line">			signalInfo.dvbt2_ofdm.plp_select=<span class="number">-1</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		buf=<span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId,buf,tvSystem,&amp;signalInfo,isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_DVB_CABLE)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBC_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">short</span> qam_const = QAM_CONST_64;</span><br><span class="line">		</span><br><span class="line">		signalInfo.dvbc_qam.scan_mode = isScanMode;</span><br><span class="line">		signalInfo.dvbc_qam.alpha = QAM_ALPHA_15;</span><br><span class="line"></span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (modulation)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM4   : qam_const = QAM_CONST_4;   signalInfo.dvbc_qam.alpha = QAM_ALPHA_13; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM16  : qam_const = QAM_CONST_16;  signalInfo.dvbc_qam.alpha = QAM_ALPHA_13; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM32  : qam_const = QAM_CONST_32;  signalInfo.dvbc_qam.alpha = QAM_ALPHA_13; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM64  : qam_const = QAM_CONST_64;  signalInfo.dvbc_qam.alpha = QAM_ALPHA_15; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM128 : qam_const = QAM_CONST_128; signalInfo.dvbc_qam.alpha = QAM_ALPHA_15; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM256 : qam_const = QAM_CONST_256; signalInfo.dvbc_qam.alpha = QAM_ALPHA_15; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM512 : qam_const = QAM_CONST_512; signalInfo.dvbc_qam.alpha = QAM_ALPHA_15; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RT_MOD_QAM1024: qam_const = QAM_CONST_1024;signalInfo.dvbc_qam.alpha = QAM_ALPHA_15; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line"></span><br><span class="line">		signalInfo.mod = TV_MODULATION_DVBC_QAM;</span><br><span class="line">		signalInfo.dvbc_qam.constellation = qam_const;</span><br><span class="line">		signalInfo.dvbc_qam.symbol_rate = <span class="number">6875000</span>;</span><br><span class="line"></span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_ABS_S)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBS_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	        <span class="comment">//assert(symbolRate);</span></span><br><span class="line">	        <span class="keyword">if</span>(symbolRate == <span class="number">0</span>)</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"[FrontendLib_SetTuner]:ABS_S:SymbolRate=%d,tuner can't lock!\n"</span>,symbolRate);</span><br><span class="line"></span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line"></span><br><span class="line">		signalInfo.abss.mod = TV_MODULATION_ABSS;</span><br><span class="line">		signalInfo.abss.symbol_rate  = symbolRate ;</span><br><span class="line">		signalInfo.abss.spectrum_inv = inversion == RT_INVERSION_OFF ? <span class="number">0</span> : <span class="number">1</span> ;</span><br><span class="line">		signalInfo.abss.scan_mode = isScanMode;</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(feType == RT_FRONTEND_DVB_SATELLITE)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FRONTENDLIB_IS_DVB_S2_MODE</span>(frequency))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBS2_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			tvSystem = TV_SYS_DVBS2;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDVBS_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			tvSystem = TV_SYS_DVBS;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		signalInfo.dvbs.symbol_rate=<span class="built_in">FRONTENDLIB_GET_SYMBOLRATE</span>(symbolRate);</span><br><span class="line">		signalInfo.dvbs.scan_mode = isScanMode;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">FRONTENDLIB_GET_DVB_S_MODULATION</span>(symbolRate) &gt; <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			signalInfo.dvbs.zapping_mode = <span class="number">1</span>;</span><br><span class="line">			signalInfo.dvbs.modulation = <span class="built_in">FRONTENDLIB_GET_DVB_S_MODULATION</span>(symbolRate)<span class="number">-1</span>;</span><br><span class="line">			signalInfo.dvbs.code_rate = <span class="built_in">FRONTENDLIB_GET_DVB_S_CODERATE</span>(symbolRate);</span><br><span class="line">			signalInfo.dvbs.pilot_onoff = <span class="built_in">FRONTENDLIB_GET_DVB_S_PILOT</span>(symbolRate);</span><br><span class="line">			signalInfo.dvbs.spec_invert = <span class="built_in">FRONTENDLIB_GET_DVB_S_SPEC_INVERT</span>(symbolRate);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> bLong_Cable = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">bool</span> bIsSingleCable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pSatelliteInfo == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] satellite info is not available\n"</span>, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		ENUM_ANTENNA_SYSTEM vAntenna_system = pSatelliteInfo-&gt;antennaConfig.antenna_system;</span><br><span class="line">		bLong_Cable = (<span class="keyword">bool</span>)pSatelliteInfo-&gt;antennaConfig.longcable;</span><br><span class="line">		bIsSingleCable = (vAntenna_system == ANTENNA_SINGLE_CABLE) || (pSatelliteInfo-&gt;unicableConfig.UB_State);</span><br><span class="line">		<span class="keyword">int</span> scrChannel = pSatelliteInfo-&gt;unicableConfig.UB_Index;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(vAntenna_system == ANTENNA__MAX)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] antenna system is not available\n"</span>, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(bIsSingleCable)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">// ALOGD("  --&gt; UniCable case");</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> lock = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">TunerControlGetLockStatus</span>(tunerId, &amp;lock) == TUNER_CTRL_OK &amp;&amp; lock)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">5</span>] = {<span class="number">0xE0</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(((scrChannel<span class="number">-1</span>) &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">5</span>), <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">				<span class="built_in">TunerControlSetLnbConfig</span>(tunerId, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bLong_Cable);</span><br><span class="line">				<span class="built_in">TunerControlSetDiseqcContinue22kOnOff</span>(tunerId, <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">TunerSetUniCableDiseqcControl</span>(tunerId, <span class="number">5</span>, data, bLong_Cable);<span class="comment">//send ODU_PowerOFF</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">TunerControlGetLockStatus</span>(tunerId, &amp;lock) == TUNER_CTRL_OK &amp;&amp; lock)</span><br><span class="line">					<span class="built_in">TunerSetUniCableDiseqcControl</span>(tunerId, <span class="number">5</span>, data, bLong_Cable);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Setup LNB and get IF value</span></span><br><span class="line">		<span class="keyword">uint32_t</span> IF = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">FrontendLib_SetDiSEqCAndLnb</span>(tunerId, frequency, IF, signalInfo, <span class="literal">false</span>, pSatelliteInfo);</span><br><span class="line">		<span class="keyword">if</span>(( IF &gt;= dvb_s_tuner_freq_start * <span class="number">100000</span> &amp;&amp; IF &lt;= dvb_s_tuner_freq_end * <span class="number">100000</span>) || IF == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, IF * <span class="number">10</span>, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] IF = %d, tuner_ctrl_status = %d\n"</span>, __LINE__, IF, tuner_ctrl_status);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] IF = %d\n"</span>, __LINE__, IF);</span><br><span class="line">			<span class="built_in">FrontendLib_SetDiSEqCAndLnb</span>(tunerId, frequency, IF, signalInfo, <span class="literal">true</span>, pSatelliteInfo);</span><br><span class="line">			tuner_ctrl_status=TUNER_CTRL_FAIL;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[FrontendLib_SetTuner %d] tuner_ctrl_status = %d\n"</span>, __LINE__, tuner_ctrl_status);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_DMBTH)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">FrontendLib_getDTMB_IsSupported</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line">		signalInfo.mod = TV_MODULATION_DTMB_OFDM;</span><br><span class="line">		signalInfo.dtmb_ofdm.mod = TV_MODULATION_DTMB_OFDM;</span><br><span class="line">		signalInfo.dtmb_ofdm.scan_mode = isScanMode;</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_ATSC)</span><br><span class="line">	{</span><br><span class="line">		signalInfo.mod = TV_MODULATION_VSB;</span><br><span class="line">		signalInfo.vsb.scan_mode = isScanMode;</span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (feType == RT_FRONTEND_OPCABLE)</span><br><span class="line">	{</span><br><span class="line">		signalInfo.mod = TV_MODULATION_QAM;</span><br><span class="line">		signalInfo.qam.scan_mode = isScanMode;</span><br><span class="line">		buf = <span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line">		tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, &amp;signalInfo, isScanMode);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		buf=<span class="built_in">FRONTENDLIB_GET_FREQUENCY</span>(frequency);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isScanMode)</span><br><span class="line">			tuner_ctrl_status = <span class="built_in">TunerControlSetFrontend</span>(tunerId, buf, tvSystem);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			tuner_ctrl_status = <span class="built_in">TunerControlSetFrontendEx</span>(tunerId, buf, tvSystem, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tuner_ctrl_status != TUNER_CTRL_OK)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* rhal_tvfe/src/api/src/DTVTunerControl.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TunerControlSetFrontendEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">char</span>           id,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           frequency,</span></span></span><br><span class="line"><span class="params"><span class="function">	TV_SYSTEM               sys,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TV_SIG_INFO*      pSigInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">char</span>           WaitSignalLock</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Frontend* pFE = <span class="built_in">GetTunerHandle</span>(id);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_time;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pFE != <span class="literal">NULL</span>) {</span><br><span class="line">		<span class="built_in">SET_THREAD_MUTE</span>();</span><br><span class="line">		cur_time = <span class="built_in">pli_getMilliseconds</span>();</span><br><span class="line"></span><br><span class="line">		ret = pFE-&gt;<span class="built_in">SetFrontendEx</span>(frequency, sys, pSigInfo, (WaitSignalLock) ? DTV_FE_FLAG_WAIT_SIGNAL_LOCK : <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">TunerControlSavingLog</span>(<span class="string">"FE%d,OP,SET_FE,%lu,%d,%d,%lu"</span>, id, frequency, sys, ret, <span class="built_in">tv_osal_time</span>() - cur_time);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">CLR_THREAD_MUTE</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">TunerControlErrorHandler</span>(id, ret);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TUNER_CTRL_ENODEV;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* rhal_tvfe/src/frontend/src/frontend.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Frontend::SetFrontendEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           freq,</span></span></span><br><span class="line"><span class="params"><span class="function">	TV_SYSTEM               sys,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TV_SIG_INFO *      pSigInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           Flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SetDemod</span>(freq, sys, pSigInfo, Flags);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* rhal_tvfe/src/frontend/src/frontend.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*=======================================================</span></span><br><span class="line"><span class="comment"> * Func : SetDemod</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Desc : Set Demod</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parm : freq      : current frequency</span></span><br><span class="line"><span class="comment"> *        sys       : Target TV System</span></span><br><span class="line"><span class="comment"> *        pSigInfo  : Signal info that previous known to help</span></span><br><span class="line"><span class="comment"> *                    accelerate acquiring signals.</span></span><br><span class="line"><span class="comment"> *        Flags     : control flag for set frontend</span></span><br><span class="line"><span class="comment"> *                       0: acuire signal but no wait lock</span></span><br><span class="line"><span class="comment"> *                       1: acuire signal wait signal lock</span></span><br><span class="line"><span class="comment"> *                       0xff: no acquire signal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Retn : TUNER_CTRL_OK / TUNER_CTRL_FAIL</span></span><br><span class="line"><span class="comment"> *=======================================================*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Frontend::SetDemod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           freq,</span></span></span><br><span class="line"><span class="params"><span class="function">	TV_SYSTEM               sys,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> TV_SIG_INFO *      pSigInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span>           Flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> ret = TUNER_CTRL_OK;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_op_mode == TV_OP_MODE_TP_ONLY)</span><br><span class="line">		<span class="keyword">return</span> TUNER_CTRL_OK;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_op_mode == TV_OP_MODE_STANDBY) {</span><br><span class="line">		ret = TUNER_CTRL_FAIL;</span><br><span class="line">		<span class="keyword">goto</span> end_proc;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DTVFE_INFO</span>(<span class="string">"SetDemod : freq=%lu, tv_sys=%s(%d)\n"</span>, freq, <span class="built_in">tv_sys_name</span>(sys), sys);</span><br><span class="line"></span><br><span class="line">set_demod:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if ((m_tv_sys != sys) || (pSigInfo != NULL)) {</span></span><br><span class="line">	ret = m_pDemod-&gt;<span class="built_in">SetTVSysEx</span>(sys, pSigInfo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret != TUNER_CTRL_OK)</span><br><span class="line">		<span class="keyword">goto</span> end_proc;</span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line">	<span class="keyword">if</span> (Flags &lt; <span class="number">2</span>)</span><br><span class="line">		ret = m_pDemod-&gt;<span class="built_in">AcquireSignal</span>((Flags &amp; DTV_FE_FLAG_WAIT_SIGNAL_LOCK) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">end_proc:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If Just No Signal, We Keep The TV Sys Setting, We can save 200ms to SetTVSysEx()</span></span><br><span class="line">	<span class="keyword">if</span> ((ret == TUNER_CTRL_OK) || (ret == TUNER_CTRL_NO_SIGNAL) || (Flags &gt;= <span class="number">2</span>))</span><br><span class="line">		_UpdateFEParam(sys, freq);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		_UpdateFEParam(TV_SYS_UNKNOWN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* rhal_tvfe/src/demod/src/demod_realtek_dtv.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">REALTEK_DTV::AcquireSignal</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> WaitSignalLock)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	RTK_DEMOD_SET_ACQ_SIG set_acq_sig_data;</span><br><span class="line">	set_acq_sig_data.WaitSignalLock = WaitSignalLock;</span><br><span class="line">	set_acq_sig_data.return_value = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RHAL_DEMOD_ACQUIRESIGNAL</span>(&amp;set_acq_sig_data);</span><br><span class="line">	<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> set_acq_sig_data.return_value;</span><br><span class="line">	<span class="comment">//return TUNER_CTRL_OK;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* hal_src/hal/src/demod/rhal_demod_adtv.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RHAL_DEMOD_ACQUIRESIGNAL</span> <span class="params">(RTK_DEMOD_SET_ACQ_SIG* pset_acq_sig_data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">ioctl</span>(hDevHandle, IOCTL_RTK_DEMOD_ACQUIRESIGNAL, pset_acq_sig_data);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到这就要跑到驱动了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* drivers/rtk_kdriver/demod/DemodMgr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">rtk_demod_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd)</span><br><span class="line">    {</span><br><span class="line">            <span class="comment">// 省略代码段</span></span><br><span class="line">            <span class="keyword">case</span> IOCTL_RTK_DEMOD_ACQUIRESIGNAL:</span><br><span class="line">            	<span class="keyword">if</span> (copy_from_user((<span class="keyword">void</span> *)&amp;pDemod_globe-&gt;set_acq_sig_data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)arg, <span class="keyword">sizeof</span>(RTK_DEMOD_SET_ACQ_SIG)))</span><br><span class="line">                {</span><br><span class="line">                    ret = <span class="number">0</span>;</span><br><span class="line">                    DEMOD_MGR_WARNING(<span class="string">"RTKDEMOD[%d]: ioctl IOCTL_RTK_DEMOD_ACQUIRESIGNAL failed !!!!!!!!!!!!!!!\n"</span>, __LINE__);</span><br><span class="line">                }</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    pDemod_globe-&gt;set_acq_sig_data.return_value = pDemod_globe-&gt;m_pDemod-&gt;AcquireSignal(pDemod_globe-&gt;m_pDemod, pDemod_globe-&gt;set_acq_sig_data.WaitSignalLock);</span><br><span class="line">                    <span class="keyword">if</span> (copy_to_user((<span class="keyword">void</span> __user *)arg, &amp;pDemod_globe-&gt;set_acq_sig_data, <span class="keyword">sizeof</span>(RTK_DEMOD_SET_ACQ_SIG)))</span><br><span class="line">                        ret = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ret = -EFAULT;</span><br><span class="line">                }</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 省略代码段</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* drivers/rtk_kdriver/demod/demod_rtk_a_dvbtx.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">REALTEK_A_DVBTX_AcquireSignal</span><span class="params">(DEMOD* pDemodKernel, <span class="keyword">unsigned</span> <span class="keyword">char</span> WaitSignalLock)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RTK_KDRV_DEMOD_SCAN_THREAD_ENABLE</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cur_time;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	REALTEK_A_DVBTX* pRealtekADVBTX;</span><br><span class="line">	DVBTX_DEMOD_MODULE* pDemod;</span><br><span class="line">	pRealtekADVBTX = (REALTEK_A_DVBTX*)(pDemodKernel-&gt;private_data);</span><br><span class="line">	pDemod = ((REALTEK_A_DVBTX_DRIVER_DATA*) pRealtekADVBTX-&gt;m_private)-&gt;pDemod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RTK_KDRV_DEMOD_SCAN_THREAD_ENABLE</span></span><br><span class="line">	cur_time = tv_osal_time();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((tv_osal_time() - cur_time) &lt;= <span class="number">15</span>) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pRealtekADVBTX-&gt;m_acquire_sig_en == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> TUNER_CTRL_OK;</span><br><span class="line"></span><br><span class="line">		tv_osal_msleep(<span class="number">5</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TUNER_CTRL_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	REALTEK_A_DVBTX_AcquireSignalThread(pDemodKernel);</span><br><span class="line">	pRealtekADVBTX-&gt;m_autotune_stime = tv_osal_time() + AUTODETECT_SIG_UPDATE_INTERVAL_MS;</span><br><span class="line">	pRealtekADVBTX-&gt;m_autotune_TsTime = tv_osal_time() + AUTOTUNE_UPDATE_TS_CLK_INTERVAL_MS;</span><br><span class="line">	pRealtekADVBTX-&gt;m_dvbt2_PLPcheck_stime = tv_osal_time() + AUTOTUNE_T2PLP_CHECK_INTERVAL_MS;</span><br><span class="line">	<span class="keyword">return</span> TUNER_CTRL_OK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，细节好多，只能省略了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* drivers/rtk_kdriver/demod/demod_rtk_a_dvbtx.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">REALTEK_A_DVBTX_AcquireSignalThread</span><span class="params">(DEMOD* pDemodKernel)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    pDemod-&gt;IsSignalLocked(pDemod, &amp;FecLockFlag)</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再下来，几乎是最底层的部分了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* drivers/rtk_kdriver/demod/demodcore/dvbtx_demod_rtk_a.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">realtek_a_dvbtx_IsSignalLocked</span><span class="params">(DVBTX_DEMOD_MODULE *pDemod, <span class="keyword">int</span> *pAnswer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	RTK_A_DVBTX_STATUS status = RTK_A_DVBTX_SUCCESSFUL;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> u8BlockFEC = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>  u8DVBTxMode = <span class="number">0</span>, u8TPSDone = <span class="number">0</span>, u8DvbtFecLock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> u8Read_data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, cnt= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	*pAnswer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (realtek_a_dvbtx_GetDVBTxMode(pDemod, &amp;u8DVBTxMode) != FUNCTION_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> FUNCTION_ERROR;</span><br><span class="line">    <span class="comment">//DVBT mode</span></span><br><span class="line">	<span class="keyword">if</span> (u8DVBTxMode == RTK_A_DVBTX_DVBT_MODE) {</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++){                                          <span class="comment">//check 5 time locked</span></span><br><span class="line">		status |= RTK_A_DVBTX_Read(pDemod, <span class="number">0x28</span>, <span class="number">0x2c</span>, &amp;u8TPSDone);</span><br><span class="line">		status |= RTK_A_DVBTX_Read(pDemod, <span class="number">0x95</span>, <span class="number">0x37</span>, &amp;u8DvbtFecLock);</span><br><span class="line">            </span><br><span class="line">		<span class="keyword">if</span> ((u8DvbtFecLock &amp; <span class="number">0x01</span>) &amp;&amp; (u8TPSDone &amp; <span class="number">0x01</span>)) { <span class="comment">/*TPS done and FEC lock, DVB-T locked*/</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &gt;= <span class="number">5</span>){</span><br><span class="line">			*pAnswer = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> (status == RTK_A_DVBTX_SUCCESSFUL) ? FUNCTION_SUCCESS : FUNCTION_ERROR;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">            tv_osal_msleep(<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        status |= RTK_A_DVBTX_Read(pDemod, <span class="number">0x17</span>, <span class="number">0xD9</span>, &amp;u8Read_data); <span class="comment">//Check FEC RST bit OFF</span></span><br><span class="line">		<span class="keyword">if</span> (((u8Read_data &amp; <span class="number">0x08</span>) != <span class="number">0x08</span>) &amp;&amp; (u8TPSDone &amp; <span class="number">0x01</span>)) { <span class="comment">/*TPS done and FEC Reset Off , DVB-T locked*/</span></span><br><span class="line">			    *pAnswer = <span class="number">1</span>;</span><br><span class="line">			    <span class="keyword">return</span> (status == RTK_A_DVBTX_SUCCESSFUL) ? FUNCTION_SUCCESS : FUNCTION_ERROR;</span><br><span class="line">		    }      </span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DVBT2 mode </span></span><br><span class="line">	<span class="keyword">if</span> (u8DVBTxMode == RTK_A_DVBTX_DVBT2_MODE) {</span><br><span class="line">		status |= RTK_A_DVBTX_Read(pDemod, <span class="number">0x17</span>, <span class="number">0xEC</span>, &amp;u8BlockFEC);</span><br><span class="line">		<span class="keyword">if</span> (u8BlockFEC &amp; <span class="number">0x01</span>) {  <span class="comment">//DVB-T2 FEC locked</span></span><br><span class="line">			*pAnswer = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> (status == RTK_A_DVBTX_SUCCESSFUL) ? FUNCTION_SUCCESS : FUNCTION_ERROR;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是在干啥？应该就是I2C读取Tuner状态吧？看看：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* drivers/rtk_kdriver/demod/demodcore/dvbtx_demod_rtk_a_base.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">Function:    RTK_A_DVBSX_RbusRead</span></span><br><span class="line"><span class="comment">Parameters:  u8BaseAddr Chip Base Address,eg.0x88; u8OffsetAddr:Chip Sub Address;</span></span><br><span class="line"><span class="comment">u8RegValue:The Pointer Which Return The Data Read Form Chip.</span></span><br><span class="line"><span class="comment">Return:      Read  Status:RTK_DEMOD_SUCCESSFUL is Normal and other is abnormal.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Description:</span></span><br><span class="line"><span class="comment">This function used to read  data form chip register</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="function">RTK_A_DVBSX_STATUS   <span class="title">RTK_A_DVBSX_Read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DVBSX_DEMOD_MODULE *pDemod,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span> u8BaseAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span> u8OffsetAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *u8RegValue</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	RTK_A_DVBSX_STATUS ui8Status = RTK_DEMOD_SUCCESSFUL;</span><br><span class="line"></span><br><span class="line">	ui8Status |= RTK_A_DVBSX_I2CRead(pDemod, u8BaseAddr, u8OffsetAddr, u8RegValue);</span><br><span class="line">	<span class="comment">//ui8Status |= rbus_demod_read(u8BaseAddr, u8OffsetAddr, u8RegValue);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ui8Status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>大致就是这样，完了。</p>
</li>
</ol>
<h4 id="FREQ-SCAN-STATE-CHECK-FRONTEND"><a href="#FREQ-SCAN-STATE-CHECK-FRONTEND" class="headerlink" title="FREQ_SCAN_STATE_CHECK_FRONTEND"></a>FREQ_SCAN_STATE_CHECK_FRONTEND</h4><p>如果锁到信号，状态就更新为<em><strong>FREQ_SCAN_STATE_CHECK_FRONTEND</strong></em>了，这个阶段，xStageCheckFrontend()的工作：</p>
<ol>
<li><p>Update modulation(DVB-S,DVB-C,DVB-T), bandwidth, and symbol rate</p>
</li>
<li><p>Notify SI to start scanning</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanStart</span>(m_curFreq, m_modulation, m_curBandwidth, symbolrate,  m_curPhyChNum, tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>(), m_serviceID);</span><br><span class="line"></span><br><span class="line">m_scanState = FREQ_SCAN_STATE_CHECK_SI;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="FREQ-SCAN-STATE-CHECK-SI"><a href="#FREQ-SCAN-STATE-CHECK-SI" class="headerlink" title="FREQ_SCAN_STATE_CHECK_SI"></a>FREQ_SCAN_STATE_CHECK_SI</h4><p>frontend设置好后，把状态更新为<em><strong>FREQ_SCAN_STATE_CHECK_SI</strong></em>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage of check SI</span></span><br><span class="line"><span class="comment"> * step 1: retry until SI scanning is done</span></span><br><span class="line"><span class="comment"> * step 2: handle T and T2 case if it needs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckSi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line">    </span><br><span class="line">RETRY:</span><br><span class="line">    <span class="keyword">if</span> (m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanIsDone</span>(&amp;m_bIsGetService) == <span class="literal">false</span>)</span><br><span class="line">    {</span><br><span class="line">        m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetSignalInfo</span>(tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>());</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">        <span class="keyword">if</span>(m_curLoHz != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!m_bCancelScan)</span><br><span class="line">                <span class="keyword">goto</span> RETRY;</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Terrestrial case :</span></span><br><span class="line">    <span class="comment">// We should check if we need to check current frequency again with different parameters</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">HasHandleCurFreqAgainInDvbT</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fill modulation to each channel to prevent error when playing channel</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetModulation</span>(m_curFreq, m_modulation);</span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">    <span class="keyword">if</span>(m_curLoHz != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">UpdateChInfo</span>();</span><br><span class="line">        <span class="built_in">SendEvent</span>(RT_SCAN_EVENT_FREQ_DONE, m_curFreq);</span><br><span class="line">        m_scanState = FREQ_SCAN_STATE_BLIND_SCAN_TP;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="FREQ-SCAN-STATE-END-FREQ"><a href="#FREQ-SCAN-STATE-END-FREQ" class="headerlink" title="FREQ_SCAN_STATE_END_FREQ"></a>FREQ_SCAN_STATE_END_FREQ</h4><p>等SI搞掂之后，状态变更为<em><strong>FREQ_SCAN_STATE_END_FREQ</strong></em>，这个频点就算是扫完了：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageEndFreq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	m_curPlpIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset tuner to force doing "set tuner" when playing channel after scan-ch.</span></span><br><span class="line">	DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line">	tuner-&gt;<span class="built_in">reset</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>至此，对于一个频点的扫台，RunStateProc状态机算是完成了使命。但是DVB-S盲扫略有不同，它的初始状态不是<em><strong>FREQ_SCAN_STATE_BEGIN_FREQ</strong></em>，而是<em><strong>FREQ_SCAN_STATE_BEGIN_BLIND_SCAN</strong></em>。</p>
<h4 id="FREQ-SCAN-STATE-BEGIN-BLIND-SCAN"><a href="#FREQ-SCAN-STATE-BEGIN-BLIND-SCAN" class="headerlink" title="FREQ_SCAN_STATE_BEGIN_BLIND_SCAN"></a>FREQ_SCAN_STATE_BEGIN_BLIND_SCAN</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageBeginBlindScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="comment">//Blind Scan switch to LNB_POWER_ON temporarily, let curBlindFreq to decide the H/V settings.</span></span><br><span class="line">    m_satInfo.antennaConfig.power = LNB_POWER_ON;</span><br><span class="line">    </span><br><span class="line">    tuner-&gt;<span class="built_in">tune</span>(m_curBlindFreq, <span class="number">0</span>, m_feType, RT_MOD_DVB_S2, RT_INVERSION_AUTO, <span class="literal">false</span>, <span class="number">0</span>, &amp;m_satInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_satInfo.antennaConfig.type == LNB_TYPE_C)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">FrontendLib_BlindScan_Init</span>(tunerId,CBAND_MIN_FREQ,CBAND_MAX_FREQ); <span class="comment">// 950 1750 // 这里有点不懂</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(m_curLoHz == kKuBandLnbOscLow)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">FrontendLib_BlindScan_Init</span>(tunerId,kKuBandLowIFMinFreq,kKuBandLowIFMaxFreq); <span class="comment">// 950 1950</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">FrontendLib_BlindScan_Init</span>(tunerId,kKuBandHightMinFreq,kKuBandHightMaxFreq); <span class="comment">// 1100 2150</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_BLIND_COLLECT_TP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="FREQ-SCAN-STATE-BLIND-COLLECT-TP"><a href="#FREQ-SCAN-STATE-BLIND-COLLECT-TP" class="headerlink" title="FREQ_SCAN_STATE_BLIND_COLLECT_TP"></a>FREQ_SCAN_STATE_BLIND_COLLECT_TP</h4><p><em><strong>FREQ_SCAN_STATE_BLIND_COLLECT_TP</strong></em>阶段，全频段步进收集中频，很多操作都是跟以上分析的tune函数差不多流程，一步一步控制到Tuner，就不一一列举分析了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageBlindCollectTP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(bBlindScanEnd!=<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">TunerControlBlindScanEnd</span>(tunerId);</span><br><span class="line">        m_blindIndex=<span class="number">-1</span>;</span><br><span class="line">        m_scanState = FREQ_SCAN_STATE_BLIND_SCAN_TP;</span><br><span class="line">        <span class="built_in">PickTPFromFreqTable</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="FREQ-SCAN-STATE-BLIND-SCAN-TP"><a href="#FREQ-SCAN-STATE-BLIND-SCAN-TP" class="headerlink" title="FREQ_SCAN_STATE_BLIND_SCAN_TP"></a>FREQ_SCAN_STATE_BLIND_SCAN_TP</h4><p><em><strong>FREQ_SCAN_STATE_BLIND_SCAN_TP</strong></em>阶段，中频+TP list 扫台。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageBlindScanTP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="built_in">FrontendLib_BlindScan_AcquireSignal</span>(tunerId,&amp;FreqMhz,&amp;SymbolRateKhz,&amp;bBlindScanLock);</span><br><span class="line">    <span class="keyword">if</span>(bBlindScanLock)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 省略代码段</span></span><br><span class="line">        m_scanState = FREQ_SCAN_STATE_CHECK_FRONTEND;</span><br><span class="line">        <span class="comment">// 省略代码段</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(bBlindScanEnd)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 省略代码段</span></span><br><span class="line">        m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来的流程就跟正常扫台一样了，直到RunStateProc状态机跑完。</p>
<h3 id="CH-SCAN-STATE-END-FREQ"><a href="#CH-SCAN-STATE-END-FREQ" class="headerlink" title="CH_SCAN_STATE_END_FREQ"></a>CH_SCAN_STATE_END_FREQ</h3><p>当前频点扫完了，判断是扫下一个频点还是直接退出扫台：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xStageEndFreq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="CH-SCAN-STATE-EXIT"><a href="#CH-SCAN-STATE-EXIT" class="headerlink" title="CH_SCAN_STATE_EXIT"></a>CH_SCAN_STATE_EXIT</h3><p>退出扫台：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xStageExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanDeInit</span>();</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>m_runThread标志位被置为false，xWorkerThread状态机结束，ScanThread线程销毁。</p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>dvb</tag>
        <tag>2851</tag>
        <tag>demod</tag>
        <tag>tuner</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础入门</title>
    <url>/2021/07/17/cpp-1/</url>
    <content><![CDATA[<p>基础入门  </p>
<span id="more"></span>

<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1 C++初识"></a>1 C++初识</h2><h3 id="1-1-第一个C-程序"><a href="#1-1-第一个C-程序" class="headerlink" title="1.1  第一个C++程序"></a>1.1  第一个C++程序</h3><p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="1-1-1-创建项目"><a href="#1-1-1-创建项目" class="headerlink" title="1.1.1 创建项目"></a>1.1.1 创建项目</h4><p>​    Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="assets/1541383178746.png" alt="1541383178746"></p>
<p><img src="assets/1541384366413.png" alt="1541384366413"></p>
<h4 id="1-1-2-创建文件"><a href="#1-1-2-创建文件" class="headerlink" title="1.1.2 创建文件"></a>1.1.2 创建文件</h4><p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="assets/1541383817248.png" alt="1541383817248"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="assets/1541384140042.png" alt="1541384140042"></p>
<h4 id="1-1-3-编写代码"><a href="#1-1-3-编写代码" class="headerlink" title="1.1.3 编写代码"></a>1.1.3 编写代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="1-1-4-运行程序"><a href="#1-1-4-运行程序" class="headerlink" title="1.1.4 运行程序"></a>1.1.4 运行程序</h4><p><img src="assets/1541384818688.png" alt="1541384818688"></p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol>
<li><strong>单行注释</strong>：<code>// 描述信息</code> <ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li>
</ul>
</li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul>
<li>通常放在一段代码的上方，==对该段代码做整体说明==</li>
</ul>
</li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4  常量"></a>1.4  常量</h3><p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol>
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul>
<li>==通常在文件上方定义==，表示一个常量</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul>
<li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"一周里总共有 "</span> &lt;&lt; day &lt;&lt; <span class="string">" 天"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"一年里总共有 "</span> &lt;&lt; month &lt;&lt; <span class="string">" 个月份"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>










<h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h3><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr>
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr>
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody></table>
<h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"short 类型所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"int 类型所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"long 类型所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"long long 类型所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<blockquote>
<p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= long long==</p>
</blockquote>
<h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p><strong>作用</strong>：用于==表示小数==</p>
<p>浮点型变量分为两种：</p>
<ol>
<li>单精度float </li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"float  sizeof = "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"double sizeof = "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="keyword">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">"f2 = "</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"f3 = "</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = 'a';</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用==1个字节==。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = "abcde"; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = 'abcde'; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ASCII码表格：</p>
<table>
<thead>
<tr>
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p>
<p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>*<em>\\*</em></td>
<td><strong>代表一个反斜线字符”"</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>'</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>"</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">"\\"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"\tHello"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"\n"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol>
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = "字符串值"</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol>
<li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = "字符串值"</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">"hello world"</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
</li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p>
</blockquote>
<h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p>
<p>bool类型只有两个值：</p>
<ul>
<li>true  — 真（本质是1）</li>
<li>false — 假（本质是0）</li>
</ul>
<p><strong>bool类型占==1个字节==大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"size of bool = "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>















<h3 id="2-8-数据的输入"><a href="#2-8-数据的输入" class="headerlink" title="2.8 数据的输入"></a>2.8 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入整型变量："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入浮点型变量："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入字符型变量："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入字符串型变量："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入布尔型变量："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr>
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr>
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody></table>
<h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr>
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr>
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr>
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr>
<td>–</td>
<td>前置递减</td>
<td>a=2; b=–a;</td>
<td>a=1; b=1;</td>
</tr>
<tr>
<td>–</td>
<td>后置递减</td>
<td>a=2; b=a–;</td>
<td>a=1; b=2;</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="keyword">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr>
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr>
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr>
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr>
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== </p>
</blockquote>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody></table>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>逻辑==或==运算符总结： ==同假为假，其余为真==</p>
</blockquote>
<h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p>
</li>
<li><p>多行格式if语句</p>
</li>
<li><p>多条件的if语句</p>
<p>​</p>
</li>
</ul>
<ol>
<li><p>单行格式if语句：<code>if(条件){ 条件满足执行的语句 }</code></p>
<p><img src="assets/clip_image002.png" alt="img"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入一个分数："</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"您输入的分数为： "</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了一本大学！！！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
</li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol start="2">
<li>多行格式if语句：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code></li>
</ol>
<p><img src="assets/clip_image002-1541662519170.png" alt="img"></p>
<p>​</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我未考上一本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<ol start="3">
<li>多条件的if语句：<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></li>
</ol>
<p><img src="assets/clip_image002-1541662566808.png" alt="img"></p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>​</p>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; <span class="string">"我考上了北大"</span> &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; <span class="string">"我考上了清华"</span> &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; <span class="string">"我考上了人大"</span> &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img src="assets/%E4%B8%89%E5%8F%AA%E5%B0%8F%E7%8C%AA.jpg" alt="三只小猪"></p>
<h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span>(表达式)</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>







<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"请给电影打分"</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (score)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"经典"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"非常好"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"一般"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"烂片"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> while(循环条件){ 循环语句 }</code></p>
<p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p>
<p><img src="assets/clip_image002-1541668640382.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>==猜数字==</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img src="assets/%E7%8C%9C%E6%95%B0%E5%AD%97.jpg" alt="猜数字"></p>
<h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件</p>
<p><img src="assets/clip_image002-1541671163478.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	} <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do…while语句，求出所有3位数中的水仙花数</p>
<h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<p><strong>详解：</strong></p>
<p><img src="assets/1541673704101.png" alt="1541673704101"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p><img src="assets/timg.gif" alt="timg"></p>
<h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="assets/1541676003486.png" alt="1541676003486"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img src="assets/0006018857256120_b.jpg" alt="0006018857256120_b"></p>
<h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"请选择您挑战副本的难度："</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"1、普通"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"2、中等"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"3、困难"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (num)</span><br><span class="line">	{</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"您选择的是普通难度"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"您选择的是中等难度"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">"您选择的是困难难度"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			cout &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>















<h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"1"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"2"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"3"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"4"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"5"</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p>
<p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p>
<p><img src="assets/1541748375356.png" alt="1541748375356"></p>
<h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组定义方式"><a href="#5-2-1-一维数组定义方式" class="headerlink" title="5.2.1 一维数组定义方式"></a>5.2.1 一维数组定义方式</h4><p>一维数组定义的三种方式：</p>
<ol>
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};</code></li>
<li><code>数据类型  数组名[ ] = { 值1，值2 ...};</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="keyword">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};</span></span><br><span class="line">	<span class="comment">//如果{}内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="keyword">int</span> score2[<span class="number">10</span>] = { <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> };</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  {值1，值2 ，值3 ...};</span></span><br><span class="line">	<span class="keyword">int</span> score3[] = { <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> };</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="5-2-2-一维数组数组名"><a href="#5-2-2-一维数组数组名" class="headerlink" title="5.2.2 一维数组数组名"></a>5.2.2 一维数组数组名</h4><p>一维数组名称的<strong>用途</strong>：</p>
<ol>
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> };</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"整个数组所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"每个元素所占内存空间为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"数组的元素个数为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"数组首地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"数组中第一个元素地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"数组中第二个元素地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="assets/1541905327273.png" alt="1541905327273"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">9</span>] = { <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> };</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img src="assets/1541905559138.png" alt="1541905559138"></p>
<h4 id="5-3-1-二维数组定义方式"><a href="#5-3-1-二维数组定义方式" class="headerlink" title="5.3.1 二维数组定义方式"></a>5.3.1 二维数组定义方式</h4><p>二维数组定义的四种方式：</p>
<ol>
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
<li><code> 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };</span></span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	{</span><br><span class="line">		{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},</span><br><span class="line">		{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };</span></span><br><span class="line">	<span class="keyword">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> }; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };</span></span><br><span class="line">	<span class="keyword">int</span> arr4[][<span class="number">3</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="5-3-2-二维数组数组名"><a href="#5-3-2-二维数组数组名" class="headerlink" title="5.3.2 二维数组数组名"></a>5.3.2 二维数组数组名</h4><ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	{</span><br><span class="line">		{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},</span><br><span class="line">		{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组大小： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组一行大小： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组元素大小： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组行数： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组列数： "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组首地址："</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组第一行地址："</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组第二行地址："</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组第一个元素地址："</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"二维数组第二个元素地址："</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a><strong>5.3.3 二维数组应用案例</strong></h4><p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody></table>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	{</span><br><span class="line">		{<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>},</span><br><span class="line">		{<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>},</span><br><span class="line">		{<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>},</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = { <span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span> };</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">"同学总成绩为： "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型 </p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句 </p>
<p>5、return 表达式</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code> 函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，==如果形参发生，并不会影响实参==</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"交换前："</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换后："</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"num1 = "</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"num2 = "</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"mian中的 a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"mian中的 b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a><strong>6.5 函数的常见样式</strong></h3><p>常见的函数样式有4种</p>
<ol>
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"this is test01"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"this is test02"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"this is test03 "</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test04</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"this is test04 "</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li> 函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol>
<li>创建后缀名为.h的头文件  </li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"swap.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>













<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p>
</li>
<li><p>可以利用指针变量保存地址</p>
<p>​</p>
</li>
</ul>
<h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"*p = "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>















<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> };</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"第一个元素： "</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>] = { <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> };</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>
<h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">}stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span> <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">"张三"</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu2</span> =</span> { <span class="string">"李四"</span>,<span class="number">19</span>,<span class="number">60</span> };</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">"王五"</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p>
</blockquote>
<h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">arr</span>[3]=</span></span><br><span class="line">	{</span><br><span class="line">		{<span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">80</span> },</span><br><span class="line">		{<span class="string">"李四"</span>,<span class="number">19</span>,<span class="number">60</span> },</span><br><span class="line">		{<span class="string">"王五"</span>,<span class="number">20</span>,<span class="number">70</span> }</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> { <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span>, };</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> * <span class="title">p</span> =</span> &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span> <span class="comment">//子结构体 学生</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">t1</span>;</span></span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">"老王"</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">"张三"</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"教师 职工编号： "</span> &lt;&lt; t1.id &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; t1.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">"辅导学员 姓名： "</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">" 考试分数： "</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"子函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"子函数中 姓名："</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	student stu = { <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span>};</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">"主函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">"主函数中 姓名："</span> &lt;&lt; stu.name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="8-7-结构体中-const使用场景"><a href="#8-7-结构体中-const使用场景" class="headerlink" title="8.7 结构体中 const使用场景"></a>8.7 结构体中 const使用场景</h3><p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	student stu = { <span class="string">"张三"</span>,<span class="number">18</span>,<span class="number">100</span> };</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><h4 id="8-8-1-案例1"><a href="#8-8-1-案例1" class="headerlink" title="8.8.1 案例1"></a>8.8.1 案例1</h4><p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string tName = <span class="string">"教师"</span>;</span><br><span class="line">	string sName = <span class="string">"学生"</span>;</span><br><span class="line">	string nameSeed = <span class="string">"ABCDE"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		{</span><br><span class="line">			cout &lt;&lt; <span class="string">"\t姓名："</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">" 分数："</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(tArray) / <span class="built_in"><span class="keyword">sizeof</span></span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="string">"刘备"</span>,<span class="number">23</span>,<span class="string">"男"</span>},</span><br><span class="line">{<span class="string">"关羽"</span>,<span class="number">22</span>,<span class="string">"男"</span>},</span><br><span class="line">{<span class="string">"张飞"</span>,<span class="number">20</span>,<span class="string">"男"</span>},</span><br><span class="line">{<span class="string">"赵云"</span>,<span class="number">21</span>,<span class="string">"男"</span>},</span><br><span class="line">{<span class="string">"貂蝉"</span>,<span class="number">19</span>,<span class="string">"女"</span>},</span><br></pre></td></tr></tbody></table></figure>









<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hero</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			{</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">" 性别： "</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hero</span> <span class="title">arr</span>[5] =</span></span><br><span class="line">	{</span><br><span class="line">		{<span class="string">"刘备"</span>,<span class="number">23</span>,<span class="string">"男"</span>},</span><br><span class="line">		{<span class="string">"关羽"</span>,<span class="number">22</span>,<span class="string">"男"</span>},</span><br><span class="line">		{<span class="string">"张飞"</span>,<span class="number">20</span>,<span class="string">"男"</span>},</span><br><span class="line">		{<span class="string">"赵云"</span>,<span class="number">21</span>,<span class="string">"男"</span>},</span><br><span class="line">		{<span class="string">"貂蝉"</span>,<span class="number">19</span>,<span class="string">"女"</span>},</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>作者：<a href="https://www.bilibili.com/video/BV1et411b73Z">黑马程序员</a>  </p>
<iframe src="//player.bilibili.com/player.html?aid=41559729&amp;bvid=BV1et411b73Z&amp;cid=72978340&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell</title>
    <url>/2021/02/24/linux-shell/</url>
    <content><![CDATA[<p><span class="github-emoji"><span>💲</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4b2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  </p>
<span id="more"></span>


<h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><ul>
<li><p>session  </p>
<p>  当我们登录系统后，bash程序启动，并且会读取一系列称为启动文件的配置脚本，这些文件定义了默认的可供所有用户共享的shell环境。然后是读取更多位于我们自己家目录中的启动文件，这些启动文件定义了用户个人的shell环境。确切的启动顺序依赖于要运行的shell会话类型。有两种shell会话类型：一个是登录shell会话，另一个是非登录shell会话。    </p>
<p>  登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/profile</td>
<td align="left">应用于所有用户的全局配置脚本</td>
</tr>
<tr>
<td align="left">~/.bash_profile</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
<tr>
<td align="left">~/.bash_login</td>
<td align="left">如果文件 ~/.bash_profile 没有找到，bash会尝试读取这个脚本</td>
</tr>
<tr>
<td align="left">~/.profile</td>
<td align="left">如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash会试图读取这个文件。这是基于Debian发行版的默认配置，比方说Ubuntu</td>
</tr>
</tbody></table>
<p>  非登录shell会话的启动文件：  </p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/etc/bash.bashrc</td>
<td align="left">应用于所有用户的全局配置文件</td>
</tr>
<tr>
<td align="left">~/.bashrc</td>
<td align="left">用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置</td>
</tr>
</tbody></table>
<p>  在普通用户看来，文件 ~/.bashrc 可能是最重要的启动文件，因为它几乎总是被读取。非登录 shell 默认 会读取它，并且大多数登录 shell 的启动文件会以能读取 ~/.bashrc 文件的方式来书写。  </p>
</li>
<li><p>启动选项  </p>
<p>  为了方便debug，有时在启动Bash的时候，可以加上启动参数。<br>  <code>-n</code> - 不运行脚本，只检查是否有语法错误<br>  <code>-v</code> - 输出每一行语句运行结果前，会先输出该行语句<br>  <code>-x</code> - 每一个命令处理之前，先输出该命令，再执行该命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ bash -n scriptname  </span><br><span class="line">$ bash -v scriptname  </span><br><span class="line">$ bash -x scriptname  </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量分类  </p>
<p>  环境变量：<code>env</code>或<code>printenv</code>命令，可以显示所有环境变量；<code>set</code>命令可显示所有变量（包括环境变量和自定义变量），以及所有的Bash函数。<br>  自定义变量：局部变量、全局变量。<br>  变量命名规则：  </p>
<ul>
<li>变量名可由字母数字字符（字母和数字）和下划线字符组成  </li>
<li>变量名的第一个字符必须是一个字母或一个下划线  </li>
<li>变量名中不允许出现空格和标点符号  </li>
</ul>
</li>
<li><p>读取变量  </p>
<p>  读取变量的时候，直接在变量名前加上<code>$</code>就可以了。读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如 $a 也可以写成 ${a} 。这种写法可以用于变量名与其他字符连用的情况。<br>  如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。  </p>
</li>
<li><p>删除变量  </p>
<p>  <code>unset</code>命令用来删除一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> NAME  </span><br></pre></td></tr></tbody></table></figure>
<p>  这个命令不是很有用。因为不存在的Bash变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。<br>  所以，删除一个变量，也可以将这个变量设成空字符串:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=<span class="string">''</span>  </span><br><span class="line">$ foo=  </span><br></pre></td></tr></tbody></table></figure>
<p>  上面两种写法，都是删除了变量foo。  </p>
</li>
<li><p>输出变量：<code>export</code>命令  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NAME=value</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令执行后，当前shell及随后新建的子shell，都可以读取变量<code>$NAME</code>。子shell如果修改继承的变量，不会影响父shell。  </p>
</li>
<li><p>特殊变量（包含位置参数）  </p>
<ul>
<li><code>$?</code> - 上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果是非零，上一个命令执行失败  </li>
<li><code>$$</code> - 当前shell的进程ID  </li>
<li><code>$_</code> - 上一个命令的最后一个参数  </li>
<li><code>$!</code> - 最近一个后台执行的异步命令的进程ID  </li>
<li><code>$0</code> - 当前shell的名称，脚本文件名  </li>
<li><code>$1</code>到<code>$9</code> - 对应脚本的第一个参数到第九个参数。通过参数展开方式可以访问的参数个数多于9个。只要指定一个大于9的数字，用花括号括起来就可以，例如 ${10}、${55}、${211} 等  </li>
<li><code>$-</code> - 当前shell的启动参数  </li>
<li><code>$#</code> - 参数的总和  </li>
<li><code>$@</code> - 全部的参数。当它被用双引号引起来的时候， 它把每一个位置参数展开成一个由双引号引起来的分开的字符串  </li>
<li><code>$*</code> - 全部的参数。当它被用双引号引起来的时候，展开成一个由双引号引起来的字符串，包含了所有的位置参数，每个位置参数由shell变量<code>$IFS</code>值的第一个字符分隔开，默认为空格，但是可以自定义  </li>
</ul>
</li>
</ul>
<ul>
<li><p>变量的默认值  </p>
<ul>
<li><code>${varname:-word}</code>：如果变量varname存在且不为空，则返回它的值，否则返回word。它的目的是返回一个默认值，比如${count:-0}表示变量count不存在时返回0。  </li>
<li><code>${varname:=word}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word。它的目的是设置变量的默认值，比如${count:=0}表示变量count不存在时返回0，且将count设为0。  </li>
<li> <code>${varname:+word}</code>：上面语法的含义是，如果变量名存在且不为空，则返回word，否则返回空值。它的目的是测试变量是否存在，比如${count:+1}表示变量count存在时返回1（表示true），否则返回空值。  </li>
<li> <code>${varname:?message}</code>：上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行。如果省略了message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如${count:?”undefined!”}表示变量count未定义时就中断执行，抛出错误，返回给定的报错信息undefined!。  </li>
</ul>
<p>  上面四种语法如果用在脚本中，变量名的部分可以用数字1到9，表示脚本的参数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">filename=<span class="variable">${1:?"filename missing."}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  上面代码出现在脚本中，1表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。  </p>
</li>
<li><p>其他  </p>
<ul>
<li><code>declare</code> - 声明一些特殊类型的变量，为变量设置一些限制。  </li>
<li><code>readonly</code> - 等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。  </li>
<li><code>let</code> - 声明变量时，可以直接执行算术表达式：    <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> foo=1+2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>Bash 函数定义的语法有两种。    <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() {</span><br><span class="line"><span class="comment"># codes</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果函数与脚本、别名同名，优先级：别名&gt;函数&gt;脚本。  </li>
<li>参数变量：与脚本的参数变量是一致的。  </li>
<li>调用时，就直接写函数名，参数跟在函数名后面。  </li>
<li>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。  </li>
<li>函数里面可以用<code>local</code>命令声明局部变量。  </li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>创建数组  </p>
<p>  逐个赋值：ARRAY[INDEX]=value<br>  一次性赋值：ARRAY=(value1 value2 … valueN)  </p>
<p>  定义数组时，可以使用通配符：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mp3s=( *.mp3 )</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，将当前目录的所有MP3文件，放进一个数组。  </p>
<p>  还可以通过指定下标，把值赋给数组中的特定元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)  </span><br></pre></td></tr></tbody></table></figure>
<p>  先用<code>declare -a</code>命令声明一个数组，也是可以的：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -a ARRAYNAME</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>read -a</code>命令则是将用户的命令行输入，读入一个数组：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -a dice</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令将用户的命令行输入，读入数组dice。  </p>
</li>
<li><p>读取数组  </p>
<p>  读取单个元素：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${array[i]}</span>   <span class="comment"># i 是索引</span></span><br></pre></td></tr></tbody></table></figure>
<p>  读取所有成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>是数组的特殊索引，表示返回数组的所有成员。  </p>
<p>  遍历数组:  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">${names[@]}</span>"</span>; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  <code>@</code>和<code>*</code>放不放在双引号之中，是有差别的。  </p>
<p>  拷贝一个数组的最方便方法，就是写成下面这样：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]}</span>"</span> )</span><br></pre></td></tr></tbody></table></figure>
<p>  这种写法也可以用来为新数组添加成员：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hobbies=( <span class="string">"<span class="variable">${activities[@]" diving )</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>默认位置  </p>
<p>  如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用0号位置。  </p>
</li>
<li><p>数组的长度  </p>
<p>  要想知道数组的长度（即一共包含多少成员），可以使用下面两种语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">${#array[*]}</span></span><br><span class="line"><span class="variable">${#array[@]}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>提取数组序号  </p>
<p>  <code>${!array[@]}</code>或<code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。  </p>
</li>
<li><p>提取数组成员  </p>
<p>  <code>${array[@]:position:length}</code>的语法可以提取数组成员。<br>  如果省略长度参数length，则返回从指定位置开始的所有成员。  </p>
</li>
<li><p>追加数组成员  </p>
<p>  数组末尾追加成员，可以使用<code>+=</code>赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">$ foo+=(d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>删除数组  </p>
<p>  删除一个数组成员，使用<code>unset</code>命令：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b c d e f</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">unset</span> foo[2]</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo[@]}</span></span><br><span class="line">a b d e f</span><br></pre></td></tr></tbody></table></figure>
<p>  将某个成员设为空值，可以从返回值中“隐藏”这个成员。<br>  直接将数组变量赋值为空字符串，相当于“隐藏”数组的第一个成员。<br>  <code>unset ArrayName</code>可以清空整个数组。  </p>
</li>
<li><p>关联数组  </p>
<p>  关联数组使用字符串而不是整数作为数组索引。<br>  <code>declare -A</code>可以声明关联数组。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -A colors</span><br><span class="line">$ colors[<span class="string">"red"</span>]=<span class="string">"#ff0000"</span></span><br><span class="line">$ colors[<span class="string">"green"</span>]=<span class="string">"#00ff00"</span></span><br><span class="line">$ colors[<span class="string">"blue"</span>]=<span class="string">"#0000ff"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有<code>-A</code>选项的<code>declare</code>命令声明创建。  </p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串的长度  </p>
<p>  获取字符串长度的语法如下：<code>${#varname}</code>。  </p>
</li>
<li><p>子字符串  </p>
<p>  字符串提取子串的语法如下：<code>${varname:offset:length}</code>。<br>  这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hello=<span class="string">'abcdefg'</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${hello:2:3}</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果省略length，则从位置offset开始，一直返回到字符串的结尾。<br>  如果offset为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格，以防止与<code>${variable:-word}</code>的变量的设置默认值语法混淆。此时还可以指定length，length可以是正值，也可以是负值（负值不能超过offset的长度）。  </p>
</li>
<li><p>切割和替换  </p>
<ul>
<li><p>字符串头部的模式匹配  </p>
<p>  <code>${variable#pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable##pattern}</code> - 如果 pattern 匹配变量 variable 的开头，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ myPath=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath#/*/}</span></span><br><span class="line">cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${myPath##/*/}</span></span><br><span class="line">long.file.name</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/#pattern/string}</code> - 将头部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/#JPG/jpg}</span></span><br><span class="line">jpg.JPG</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符串尾部的模式匹配  </p>
<p>  <code>${variable%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最短匹配（非贪婪匹配）的部分，返回剩余部分<br>  <code>${variable%%pattern}</code> - 如果 pattern 匹配变量 variable 的结尾，删除最长匹配（贪婪匹配）的部分，返回剩余部分  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%.*}</span></span><br><span class="line">/home/cam/book/long.file</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path%%.*}</span></span><br><span class="line">/home/cam/book/long</span><br></pre></td></tr></tbody></table></figure>

<p>  <code>${variable/%pattern/string}</code> - 将尾部匹配的部分，替换成其他内容  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=JPG.JPG</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${foo/%JPG/jpg}</span></span><br><span class="line">JPG.jpg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>任意位置的模式匹配  </p>
<p>  <code>${variable/pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配<br>  <code>${variable//pattern/string}</code> - 如果 pattern 匹配变量 variable 的一部分，最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/foo/bar}</span></span><br><span class="line">/home/cam/bar/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path//foo/bar}</span></span><br><span class="line">/home/cam/bar/bar.name</span><br></pre></td></tr></tbody></table></figure>

<p>  如果省略了string部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${path/.*/}</span></span><br><span class="line">/home/cam/foo/foo</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>改变大小写  </p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">${parameter,,}</td>
<td align="left">把 parameter 的值全部展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter,}</td>
<td align="left">仅仅把 parameter 的第一个字符展开成小写字母</td>
</tr>
<tr>
<td align="left">${parameter^^}</td>
<td align="left">把 parameter 的值全部转换成大写字母</td>
</tr>
<tr>
<td align="left">${parameter^}</td>
<td align="left">仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><ul>
<li><p>算术表达式  </p>
<p>  <code>((...))</code>语法可以进行整数的算术运算：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ((foo = 5 + 5))</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
<p>  如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。<br>  <code>$((...))</code>的圆括号中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。<br>  如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名，如果不存在同名变量，Bash 就会将其作为空值，而<code>$((...))</code>会将空值当做0。  </p>
<p>  逗号<code>，</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((foo = <span class="number">1</span> + <span class="number">2</span>, <span class="number">3</span> * <span class="number">4</span>))</span><br><span class="line">12</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>数值的进制  </p>
<p>  指定不同的数基  </p>
<table>
<thead>
<tr>
<th align="left">表示法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">number</td>
<td align="left">默认情况下，没有任何表示法的数字被看做是十进制数（以10为底）</td>
</tr>
<tr>
<td align="left">0number</td>
<td align="left">在算术表达式中，以零开头的数字被认为是八进制数</td>
</tr>
<tr>
<td align="left">0xnumber</td>
<td align="left">十六进制表示法</td>
</tr>
<tr>
<td align="left">base#number</td>
<td align="left">base进制的数</td>
</tr>
</tbody></table>
<p>  其他进制转换为10进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">0</span>xff))  </span><br><span class="line">255  </span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2#11111111</span>))  </span><br><span class="line">255</span><br><span class="line">$ <span class="built_in">echo</span> $((<span class="number">8#11</span>))</span><br><span class="line">9</span><br><span class="line">$ <span class="built_in">printf</span> %d 0xFF</span><br><span class="line">$ ((num=8<span class="comment">#123))</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">${num}</span></span><br><span class="line">83</span><br></pre></td></tr></tbody></table></figure>
<p>  10进制转换为其他进制：</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=16;65536"</span> | bc <span class="comment"># 利用bc计算器。echo "obase=进制;值" | bc</span></span><br><span class="line">10000</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"obase=8;65536"</span> | bc</span><br><span class="line">200000</span><br><span class="line">$ <span class="built_in">printf</span> %x 15</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ul>
<li><p>位运算  </p>
</li>
<li><p>逻辑运算  </p>
</li>
<li><p>赋值运算  </p>
</li>
<li><p>求值运算  </p>
</li>
<li><p><code>expr</code>命令  </p>
<p>  <code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ expr 3 + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令支持变量替换：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ foo=3</span><br><span class="line">$ expr <span class="variable">$foo</span> + 2</span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>expr</code>命令也不支持非整数参数。  </p>
</li>
<li><p><code>let</code>命令  </p>
<p>  <code>let</code>命令用于将算术运算的结果，赋予一个变量：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> x=2+3</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">5</span><br></pre></td></tr></tbody></table></figure>
<p>  注意，x=2+3这个式子里面不能有空格，如果包含空格，需要使用引号。  </p>
<p>  <code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">let</span> <span class="string">"v1 = 1"</span> <span class="string">"v2 = v1++"</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$v1</span>,<span class="variable">$v2</span></span><br><span class="line">2,1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p><code>if</code>结构  </p>
<ul>
<li><p>语法：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands</span><br><span class="line">[<span class="keyword">elif</span> commands; <span class="keyword">then</span></span><br><span class="line">	commands...]</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">	commands]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>test</code>命令  </p>
<p>  <code>if</code>结构的判断条件，一般使用<code>test</code>命令，有三种形式：  </p>
<ol>
<li><code>test expression</code>  </li>
<li><code>[ expression ]</code>  </li>
<li><code>[[ expression ]]</code>  </li>
</ol>
<p>  上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。  </p>
</li>
<li><p>判断表达式  </p>
<ol>
<li><p>文件判断</p>
<p>文件系统相关测试：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回TRUE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-f $var</td>
<td align="left">给定的变量包含正常的文件路径或文件名</td>
</tr>
<tr>
<td align="left">-x $var</td>
<td align="left">给定的变量包含的文件可执行</td>
</tr>
<tr>
<td align="left">-d $var</td>
<td align="left">给定的变量包含的是目录</td>
</tr>
<tr>
<td align="left">-e $var</td>
<td align="left">给定的变量包含的文件存在</td>
</tr>
<tr>
<td align="left">-c $var</td>
<td align="left">给定的变量包含的是一个字符设备文件的路径</td>
</tr>
<tr>
<td align="left">-b $var</td>
<td align="left">给定的变量包含的是一个块设备文件的路径</td>
</tr>
<tr>
<td align="left">-w $var</td>
<td align="left">给定的变量包含的文件可写</td>
</tr>
<tr>
<td align="left">-r $var</td>
<td align="left">给定的变量包含的文件可读</td>
</tr>
<tr>
<td align="left">-L $var</td>
<td align="left">给定的变量包含的是一个符号链接</td>
</tr>
</tbody></table>
</li>
<li><p>字符串判断</p>
<p>字符串表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果下列条件为真则返回True</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string</td>
<td align="left">string不为null</td>
</tr>
<tr>
<td align="left">-n string</td>
<td align="left">字符串string的长度大于零</td>
</tr>
<tr>
<td align="left">-z string</td>
<td align="left">字符串string的长度为零</td>
</tr>
<tr>
<td align="left">string1 = string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 == string2</td>
<td align="left">string1和string2相同。单或双等号都可以，不过双等号更受欢迎</td>
</tr>
<tr>
<td align="left">string1 != string2</td>
<td align="left">string1和string2不相同</td>
</tr>
<tr>
<td align="left">string1 &gt; string2</td>
<td align="left">string1排列在string2之后</td>
</tr>
<tr>
<td align="left">string1 &lt; string2</td>
<td align="left">string1排列在string2之前</td>
</tr>
</tbody></table>
</li>
<li><p>整数判断</p>
<p>整形表达式：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">如果为真…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">integer1 -eq integer2</td>
<td align="left">integer1等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ne integer2</td>
<td align="left">integer1不等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -le integer2</td>
<td align="left">integer1小于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -lt integer2</td>
<td align="left">integer1小于integer2</td>
</tr>
<tr>
<td align="left">integer1 -ge integer2</td>
<td align="left">integer1大于或等于integer2</td>
</tr>
<tr>
<td align="left">integer1 -gt integer2</td>
<td align="left">integer1大于integer2</td>
</tr>
</tbody></table>
</li>
<li><p>综合表达式</p>
<p>逻辑操作符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">测试</th>
<th align="left">[[]] and (())</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AND</td>
<td align="left">-a</td>
<td align="left">&amp;&amp;</td>
</tr>
<tr>
<td align="left">OR</td>
<td align="left">-o</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">NOT</td>
<td align="left">!</td>
<td align="left">!</td>
</tr>
</tbody></table>
</li>
<li><p>正则判断</p>
<p><code>[[ string =~ regex ]]</code>  </p>
<p>上面的语法中，<code>regex</code>是一个正则表达式，<code>=~</code>是正则比较运算符。  </p>
<p>举个例子：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">INT=-5</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$INT</span>"</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is an integer."</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INT is not an integer."</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>算术判断</p>
<p>Bash还提供了<code>((...))</code>作为算术条件，进行算术运算的判断。</p>
<p>注意，算术判断不需要使用<code>test</code>命令，而是直接使用<code>((...))</code>结构。这个结构的返回值，决定了判断的真伪。</p>
<p>算术条件<code>((...))</code>也可以用于变量赋值：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="keyword">if</span> (( foo = 5 ));<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"foo is <span class="variable">$foo</span>"</span>; <span class="keyword">fi</span></span><br><span class="line">foo is 5</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，(( foo = 5 ))完成了两件事情。首先把5赋值给变量foo，然后根据返回值5，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是0，则判断为假。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>case</code>结构  </p>
<p>  语法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  pattern )</span><br><span class="line">	commands ;;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></tbody></table></figure>

<p>  <code>case</code>的匹配模式可以使用各种通配符，下面是一些例子：  </p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a)</td>
<td align="left">若单词为”a”，则匹配</td>
</tr>
<tr>
<td align="left">a|b)</td>
<td align="left">若单词为”a”或”b”，则匹配</td>
</tr>
<tr>
<td align="left">[[:alpha:]])</td>
<td align="left">若单词是一个字母字符，则匹配</td>
</tr>
<tr>
<td align="left">???)</td>
<td align="left">若单词只有3个字符，则匹配</td>
</tr>
<tr>
<td align="left">*.txt)</td>
<td align="left">若单词以”.txt”字符结尾，则匹配</td>
</tr>
<tr>
<td align="left">*)</td>
<td align="left">匹配任意单词。把这个模式作为case命令的最后一个模式，是一个很好的做法，可以捕获到任意一个与先前模式不匹配的数值；也就是说，捕获到任何可能的无效值</td>
</tr>
</tbody></table>
<p>  执行多个动作：<br>  Bash 4.0之后允许匹配多个条件，这时可以用<code>;;&amp;</code>终止每个条件块。<br>  条件语句结尾添加了<code>;;&amp;</code>以后，在匹配一个条件之后，并没有退出<code>case</code>结构，而是继续判断下一个条件。  </p>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li><p><code>while</code>循环  </p>
<p>  <code>while</code>循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>until</code>循环  </p>
<p>  <code>until</code>循环与<code>while</code>循环恰好相反，只要不符合判断条件（判断条件失败），就不断循环执行指定的语句。一旦符合判断条件，就退出循环。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">until condition; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  一般来说，<code>until</code>用得比较少，完全可以统一都是用<code>while</code>。  </p>
</li>
<li><p><code>for...in</code>循环  </p>
<p>  <code>for...in</code>循环用于遍历列表的每一项。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list; <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>for</code>循环  </p>
<p>  <code>for</code>循环还支持 C 语言的循环语法。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )); <span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号<code>$</code>。  </p>
</li>
<li><p><code>break</code>, <code>continue</code>  </p>
</li>
<li><p><code>select</code>结构  </p>
<p>  <code>select</code>结构主要用来生成简单的菜单。它的语法与<code>for...in</code>循环基本一致。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">select name</span><br><span class="line">[<span class="keyword">in</span> list]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="终端打印"><a href="#终端打印" class="headerlink" title="终端打印"></a>终端打印</h2><p><code>echo</code>是用于终端打印的基本命令。  </p>
<p>另一个可用于终端打印的命令是<code>printf</code>:  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4.2f\n"</span> 2 James 90.9989</span><br></pre></td></tr></tbody></table></figure>

<p>彩色输出：<br><img src="https://i.loli.net/2020/06/08/DEpRWVLrby8qOxI.png" alt="shell颜色语法.png"><br><img src="https://i.loli.net/2020/06/08/Yu5AzgHGvN7VdpS.png" alt="shell涉及的颜色.png"><br>每种颜色都有对应的颜色码。比如：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37。<br>要打印彩色文本，可输入如下命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;31m This is red text \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>\e[1;31m</code>将颜色设为红色，<code>\e[0m</code>将颜色重新置回。  </p>
<p>要设置彩色背景，经常使用的颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"\e[1;42m Green Background \e[0m"</span></span><br></pre></td></tr></tbody></table></figure>


<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><ul>
<li><p>重定向  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls -l /bin/usr 2&gt; ls-error.txt <span class="comment">#重定向标准错误</span></span><br><span class="line">$ ls -l /bin/usr &amp;&gt; ls-output.txt <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 <span class="comment">#重定向标准输出和错误到同一个文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; temp.txt <span class="comment">#把echo命令的输出写入文件前，temp.txt中的内容首先会被清空</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt;&gt; temp.txt <span class="comment">#这种方法会将文本追加到目标文件中</span></span><br><span class="line">$ &gt; ls-output.txt <span class="comment">#如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>cat</code> </p>
<p>  <code>cat</code>命令读取一个或多个文件，然后复制它们到标准输出。<br>  如果<code>cat</code>没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，它正在等待我们输入数据。下一步，输入<code>Ctrl-d</code>来告诉<code>cat</code>，在标准输入中，它已经到达文件末尾<code>EOF</code>。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat movie.mpeg.0* &gt; movie.mpeg</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>管道线  </p>
<p>  使用管道操作符<code>|</code>，一个命令的标准输出可以通过管道送至另一个命令的标准输入。  </p>
</li>
</ul>
<ul>
<li><p>过滤器  </p>
<p>  管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后输出它。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /bin /usr/bin | sort | uniq | less</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | wc -l</span><br><span class="line">$ ls /bin /usr/bin | sort | uniq | grep zip</span><br><span class="line">$ <span class="built_in">echo</span> `who | awk <span class="string">'{print $1}'</span> | sort | uniq` | sed <span class="string">'s/ /, /g'</span> &gt; file.txt</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>head</code>/<code>tail</code> - 打印文件开头部分/结尾部分  </p>
<p>  默认打印10行，通过<code>-n</code>参数指定打印的行数。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /usr/bin | tail -n 5</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>tail</code>有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时被写入。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tail -f /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></tbody></table></figure>
<p>  通过<code>-f</code>参数，<code>tail</code>命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入<code>Ctrl+c</code>。  </p>
</li>
<li><p><code>tee</code> - 从<code>stdin</code>读取数据，并同时输出到<code>stdout</code>和文件<br>  为了和我们的管道隐喻保持一致，Linux提供了一个叫做<code>tee</code>的命令，这个命令制造了一个”tee”，安装到我们的管道上，<code>tee</code>程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含<code>tee</code>命令，在<code>grep</code>过滤管道线的内容之前，来捕捉整个目录列表到文件ls.txt。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls /usr/bin | tee ls.txt | grep zip</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h2><ul>
<li><p>引号  </p>
<ul>
<li><p><strong>单引号</strong>：  </p>
<p>无视所有特殊字符，原样输出，所有字符在它眼里都是普通字符，比如星号<code>*</code>、美元符号<code>$</code>、反斜杠<code>\</code>等；单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p>
</li>
<li><p><strong>双引号</strong>: </p>
<p>无视文件通配符，但<code>$</code>、<code>\</code>和<code>`</code>会起作用。</p>
<p>双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通符号。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"*"</span></span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure>

<p>上面例子中，通配符<code>*</code>是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。</p>
<p>但是三个特殊字符除外：美元符号<code>$</code>、反引号<code>`</code>和反斜杠<code>\</code>。这三个字符在双引号之中，依然有特殊含义，会被Bash自动扩展。</p>
<p>双引号还有一个作用，就是保存原始命令的输出格式：</p>
<p>单行输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">二月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</span><br></pre></td></tr></tbody></table></figure>

<p>原始格式输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"<span class="subst">$(cal)</span>"</span></span><br><span class="line">	二月 2021         </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">	1  2  3  4  5  6  </span><br><span class="line">7  8  9 10 11 12 13  </span><br><span class="line">14 15 16 17 18 19 20  </span><br><span class="line">21 22 23 24 25 26 27  </span><br><span class="line">28                    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>转义  </p>
<p>  某些字符在Bash里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$data</span></span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，输出$date不会有任何结果，因为<code>$</code>是一个特殊字符。<br>  如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做”转义”(escape)。  </p>
<p>  反斜杠除了用于转义，还可以表示一些不可打印的字符：<br>  <code>\a</code> - 响铃<br>  <code>\b</code> - 退格<br>  <code>\n</code> - 换行<br>  <code>\r</code> - 回车<br>  <code>\t</code> - 制表符<br>  如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a\tb</span><br><span class="line">atb</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"a\tb"</span></span><br><span class="line">a	b</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，命令行直接输出不可打印字符<code>\t</code>，Bash不能正确解析。必须把它们放在引号之中，然后使用<code>echo</code>命令的<code>-e</code>参数。  </p>
<p>  换行符是一个特殊字符，表示命令的结束，Bash收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash会将其当做空格处理，从而可以将一行命令写成多行。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mv \</span><br><span class="line">/path/to/foo \</span><br><span class="line">/path/to/bar</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mv /path/to/foo /path/to/bar</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>Bash的模式扩展：<br>    shell接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元，然后，shell会扩展词元里面的特殊字符，扩展完后才会调用相应的命令。  </p>
<ul>
<li><p>波浪线扩展  </p>
<p>  自动扩展成当前用户的主目录。  </p>
</li>
<li><p><code>?</code>字符扩展  </p>
<p>  代表文件路径里面的任意单个字符，不包括空字符。  </p>
</li>
<li><p><code>*</code>字符扩展  </p>
<p>  代表文件路径里面的任意数量的任意字符，包括零个字符。  </p>
</li>
<li><p>方括号扩展  </p>
<p>  1、匹配括号之中的任意一个字符。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。<br>  2、方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如[a-c]等同于[abc]，[0-9]匹配[0123456789]。  </p>
<p>  举例：  </p>
<pre><code>  [a-z]：所有小写字母；  
  [a-zA-Z]：所有小写字母与大写字母；  
  [a-zA-Z0-9]：所有小写字母、大写字母与数字；  
  [abc]*：所有以a、b、c字符之一开头的文件名；  
  program.[co]：文件program.c与文件program.o；  
  BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。  
</code></pre>
<p>  这种简写形式有一个否定形式<code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如[!a-zA-Z]表示匹配非英文字母的字符，[!1-3]表示排除1、2和3。  </p>
</li>
<li><p>大括号扩展  </p>
<p>  表示分别扩展成大括号<code>{...}</code>里面的所有值，各个值之间使用逗号分隔。比如{1,2,3}扩展成1 2 3。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> d{a,e,i,o,u}g</span><br><span class="line">dag deg dig dog dug</span><br></pre></td></tr></tbody></table></figure>
<p>  1、大括号内部的逗号前后不能有空格，否则，大括号扩展会失效。  </p>
<p>  2、逗号前面可以没有值，表示扩展的第一项为空。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cp a.log{,.bak}</span><br></pre></td></tr></tbody></table></figure>
<p>  等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cp a.log a.log.bak</span><br></pre></td></tr></tbody></table></figure>
<p>  3、大括号可以嵌套。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {j{p,pe}g,png}</span><br><span class="line">jpg jpeg png</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a{A{1,2},B{3,4}}b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></tbody></table></figure>
<p>  4、大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/{cat,b*}</span><br><span class="line">/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...</span><br></pre></td></tr></tbody></table></figure>
<p>  基本等同于  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/cat;<span class="built_in">echo</span> /bin/b*</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，会先进行大括号扩展，然后进行<code>*</code>扩展，等同于执行两条<code>echo</code>命令。  </p>
<p>  由于大括号扩展<code>{...}</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。  </p>
<p>  不存在 a.txt 和 b.txt 时：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [ab].txt</span><br><span class="line">[ab].txt</span><br><span class="line">$ <span class="built_in">echo</span> {a,b}.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></tbody></table></figure>

<p>  5、大括号扩展有一个简写形式<code>{start..end}</code>，表示扩展成一个连续序列。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}</span><br><span class="line">a b c</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式支持逆序：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {c..a}</span><br><span class="line">c b a</span><br></pre></td></tr></tbody></table></figure>
<p>  这种简写形式可以嵌套使用，形成复杂的扩展：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .{mp{3,4},m4{a,b,p,v}}</span><br><span class="line">.mp3 .mp4 .m4a .m4b .m4p .m4v</span><br></pre></td></tr></tbody></table></figure>

<p>  6、大括号扩展的常见用途：<br>  新建一系列目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir {2007..2009}-{01..12}</span><br></pre></td></tr></tbody></table></figure>
<p>  用于for循环：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..4}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  如果整数前面有前导0，扩展输出的每一项都有前导0：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {01..5}</span><br><span class="line">01 02 03 04 05</span><br><span class="line">$ <span class="built_in">echo</span> {001..5}</span><br><span class="line">001 002 003 004 005</span><br></pre></td></tr></tbody></table></figure>

<p>  7、这种简写形式还可以使用第二个双点号<code>(start..end..step)</code>，用来指定扩展的步长：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {0..8..2}</span><br><span class="line">0 2 4 6 8</span><br></pre></td></tr></tbody></table></figure>
<p>  多个简写形式连用，会有循环处理的效果：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> {a..c}{1..3}</span><br><span class="line">a1 a2 a3 b1 b2 b3 c1 c2 c3</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>变量扩展  </p>
<p>  Bash将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值。变量名除了放在美元符号后面，也可以放在<code>${}</code>里面。<br>  <code>${!string*}</code>或<code>${!string@}</code>返回所有匹配给定字符串string的变量名。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">${!S*}</span></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></tbody></table></figure>
<p>  上面例子中，${!S*}扩展成所有以S开头的变量名。  </p>
</li>
<li><p>子命令扩展  </p>
<p>  <code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(date)</span><br><span class="line">Tue Jan 12 10:56:55 CST 2021</span><br><span class="line">$ file $(ls /usr/bin/* | grep zip)</span><br></pre></td></tr></tbody></table></figure>
<p>  还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `date`</span><br><span class="line">Tue Jan 12 10:58:51 CST 2021</span><br></pre></td></tr></tbody></table></figure>
<p>  <code>$(...)</code>可以嵌套，比如：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$(ls $(<span class="built_in">pwd</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>  利用子shell生成一个独立的进程：<br>  子shell本身就是独立的进程。可以使用<code>()</code>操作符来定义一个子shell：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>;</span><br><span class="line">(<span class="built_in">cd</span> /bin; ls);</span><br><span class="line"><span class="built_in">pwd</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>  当命令在子shell中执行时，不会对当前shell有任何影响；所有的改变仅限于子shell内。例如，当用cd命令改变子shell的当前目录时，这种变化不会反映到主shell环境中。  </p>
</li>
<li><p>算术扩展  </p>
<p>  <code>$((...))</code>可以扩展成整数运算的结果。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>字符类  </p>
<p>  比如：<code>[[:digit:]]</code>匹配任意数字 0-9。  </p>
<p>  使用注意点：<br>  1、通配符是先解释，再执行。<br>  2、文件名扩展在不匹配时，会原样输出。<br>  3、只适用于单层路径。所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code>或<code>*</code>这样的通配符，不能匹配路径分隔符<code>/</code>。  </p>
<pre><code>  如果要匹配子目录里面的文件，可以写成下面这样：  
</code></pre>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ls */*.txt</span><br></pre></td></tr></tbody></table></figure>
<p>  4、文件名可以使用通配符。这时引用文件名，需要把文件名放在单引号里面。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ touch <span class="string">'fo*'</span></span><br><span class="line">$ ls</span><br><span class="line">fo*</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>量词语法  </p>
<p>  量词语法用来控制模式匹配的次数。它只有在Bash的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob on</span><br></pre></td></tr></tbody></table></figure>
<p>  量词语法有下面几个：<br>  <code>?(pattern-list)</code> - 匹配零个或一个模式<br>  <code>*(pattern-list)</code> - 匹配零个或多个模式<br>  <code>+(pattern-list)</code> - 匹配一个或多个模式<br>  <code>@(pattern-list)</code> - 只匹配一个模式<br>  <code>!(pattern-list)</code> - 匹配零个或一个以上的模式，但不匹配单独一个的模式  </p>
<p>  <code>shopt</code>命令可以调整Bash的行为。它有好几个参数跟通配符扩展有关。<br>  <code>shopt</code>命令的使用方法如下：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>shell本身不支持正则表达式，使用正则表达式的是shell命令和工具。<br>正则表达式基本上是一种“表达式”， 只要工具程序支持这种表达式，那么该工具程序就可以用来作为正则表达式的字串处理之用。 例如 <code>vi</code>, <code>egrep</code>, <code>awk</code> , <code>sed</code>, <code>perl</code>, <code>less</code> 等等工具，因为她们有支持正则表达式， 所以，这些工具就可以使用正则表达式的特殊字符来进行字串的处理。但例如 <code>find</code>, <code>cp</code>, <code>ls</code>, <code>rm</code> 等系统命令一般并未支持正则表达式， 所以就只能使用 Bash 自己本身的通配符而已。</p>
<p>正则表达式元字符由以下字符组成：<br><code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>{ }</code> <code>-</code> <code>?</code> <code>*</code> <code>+</code> <code>( )</code> <code>|</code> <code>\</code>  </p>
<p>其他所有字符都被认为是原义字符。在个别情况下，反斜杠会被用来创建元序列，元字符也可以被转义为原义字符，而不是解释为元字符。<br>注意：正如我们所见到的，当 shell 执行展开的时候，许多正则表达式元字符，也是对 shell 有特殊 含义的字符。当我们在命令行中传递包含元字符的正则表达式的时候，把元字符用引号引起来至关重要，这样可以阻止 shell 试图展开它们。  </p>
<ol>
<li><p>任何字符  </p>
<p> 圆点字符，用来匹配任意字符。如果我们在正则表达式中包含它，它将会匹配在此位置的任意一个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'.zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>锚点  </p>
<p> 在正则表达式中，插入符号和美元符号被看作是锚点。这意味着正则表达式只有在文本行的开头或末尾被找到时，才算发生一次匹配。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'^zip'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br><span class="line">zipcloak  </span><br><span class="line">zipgrep  </span><br><span class="line">zipinfo  </span><br><span class="line">zipnote  </span><br><span class="line">zipspli  </span><br><span class="line">$ grep -h <span class="string">'zip$'</span> dirlist*.txt  </span><br><span class="line">gunzip  </span><br><span class="line">gzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">unzip  </span><br><span class="line">zip  </span><br><span class="line">$ grep -h <span class="string">'^zip$'</span> dirlist*.txt  </span><br><span class="line">zip  </span><br></pre></td></tr></tbody></table></figure>

<p> 注意正则表达式<code>'ˆ$'</code>（行首和行尾之间没有字符）会匹配空行。  </p>
</li>
<li><p>中括号表达式和字符类  </p>
<p> 通过使用中括号表达式，能够从一个指定的字符集合（包含在不加中括号的情况下会被解释为元字符的字符）中匹配单个字符。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'[bg]zip'</span> dirlist*.txt  </span><br><span class="line">bzip2  </span><br><span class="line">bzip2recover  </span><br><span class="line">gzip  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后会失去了它们的特殊含义。 然而，在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。第一个元字符 是插入字符<code>^</code>，其被用来表示否定；第二个是连字符字符<code>-</code>，其被用来表示一个字符范围。  </p>
</li>
<li><p>否定  </p>
<p> 如果在中括号表示式中的第一个字符是一个插入字符<code>^</code>，则剩余的字符被看作是不会在给定的字符位置出现的字符集合。举个例子：  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -h <span class="string">'[^bg]zip'</span> dirlist*.txt  </span><br><span class="line">bunzip2  </span><br><span class="line">gunzip  </span><br><span class="line">funzip  </span><br><span class="line">gpg-zip  </span><br><span class="line">preunzip  </span><br><span class="line">prezip  </span><br><span class="line">prezip-bin  </span><br><span class="line">unzip  </span><br><span class="line">unzipsfx  </span><br></pre></td></tr></tbody></table></figure>

<p> 一个否定的字符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员。<br> 插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。  </p>
</li>
<li><p>传统的字符区域  </p>
</li>
<li><p>POSIX字符集  </p>
<p> POSIX 把正则表达式的实现分成了两类： 基本正则表达式（BRE）和扩展的正则表达式（ERE）。  </p>
<p> BRE 和 ERE 之间有什么区别呢？这是关于元字符的问题。BRE 可以辨别以下元字符：  </p>
<p> <code>^</code> <code>$</code> <code>.</code> <code>[ ]</code> <code>*</code>  </p>
<p> 其它的所有字符被认为是文本字符。ERE 添加了以下元字符（以及与其相关的功能）:  </p>
<p> <code>( )</code> <code>{ }</code> <code>?</code> <code>+</code> <code>|</code>  </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ grep -Eh <span class="string">'^(bz|gz|zip)'</span> dirlist*.txt  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>限定符  </p>
<p> 扩展的正则表达式支持几种方法，来指定一个元素被匹配的次数。  </p>
<ul>
<li><code>?</code> - 匹配零个或一个元素  </li>
<li><code>*</code> - 匹配零个或多个元素  </li>
<li><code>+</code> - 匹配一个或多个元素  </li>
<li><code>{}</code> - 匹配特定个数的元素  </li>
</ul>
<p> <code>{}</code>元字符都被用来表达要求匹配的最小和最大数目。它们可以通过四种方法来指定：  </p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">意思</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">匹配前面的元素，如果它确切地出现了 n 次</td>
</tr>
<tr>
<td align="left">n,m</td>
<td align="left">匹配前面的元素，如果它至少出现了n次，但是不多于m次</td>
</tr>
<tr>
<td align="left">n,</td>
<td align="left">匹配前面的元素，如果它出现了n次或多于n次</td>
</tr>
<tr>
<td align="left">,m</td>
<td align="left">匹配前面的元素，如果它出现的次数不多于m次</td>
</tr>
</tbody></table>
</li>
</ol>
<p>正则表达式的基本组成部分：  </p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">行起始标记</td>
<td align="left">^tux匹配以tux起始的行</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">行尾标记</td>
<td align="left">tux$匹配以tux结尾的行</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意一个字符</td>
<td align="left">Hack.匹配Hackl和Hacki，但是不匹配Hackl2和Hackil，它只能匹配单个字符</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">匹配包含在[字符]之中的任意一个字符</td>
<td align="left">coo[kl]匹配cook或cool</td>
</tr>
<tr>
<td align="left">[^]</td>
<td align="left">匹配除[^字符]之外的任意一个字符</td>
<td align="left">9[^01]匹配92、93，但是不匹配91或90</td>
</tr>
<tr>
<td align="left">[-]</td>
<td align="left">匹配[]中指定范围内的任意一个字符</td>
<td align="left">[1-5]匹配从1~5的任意一个数字</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配之前的项1次或0次</td>
<td align="left">colou?r匹配color或colour，但是不能匹配colouur</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配之前的项1次或多次</td>
<td align="left">Rollno-9+匹配Rollno-99、Rollno-9，但是不能匹配Rollno-</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配之前的项0次或多次</td>
<td align="left">co*l匹配cl、col、coool等</td>
</tr>
<tr>
<td align="left">()</td>
<td align="left">创建一个用于匹配的子串</td>
<td align="left">ma(tri)?x匹配max或matrix</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">匹配之前的项n次</td>
<td align="left">[0-9]{3}匹配任意一个三位数，[0-9]{3}可以扩展为[0-9][0-9][0-9]</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">之前的项至少需要匹配n次</td>
<td align="left">[0-9]{2,}匹配任意一个两位或更多位的数字</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">指定之前的项所必须匹配的最小次数和最大次数</td>
<td align="left">[0-9]{2,5}匹配从两位数到五位数之前的任意一个数字</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">交替一一匹配|两边的任意一项</td>
<td align="left">Oct(1st|2nd)匹配Oct 1st或Oct 2nd</td>
</tr>
</tbody></table>
<h2 id="sed入门"><a href="#sed入门" class="headerlink" title="sed入门"></a>sed入门</h2><p>名字 <code>sed</code> 是 stream editor（流编辑器）的简称。  </p>
<p><code>sed</code>地址表示法：  </p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">n</td>
<td align="left">行号，n是一个正整数</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">最后一行</td>
</tr>
<tr>
<td align="left">/regexp/</td>
<td align="left">所有匹配一个POSIX基本正则表达式的文本行。注意正则表达式通过斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc来指定表达式，这里c就是一个备用字符</td>
</tr>
<tr>
<td align="left">addr1,addr2</td>
<td align="left">从addr1到addr2范围内的文本行，包含地址addr2在内。地址可能是上述任意单独的地址形式</td>
</tr>
<tr>
<td align="left">first~step</td>
<td align="left">匹配由数字first代表的文本行，然后随后的每个在step间隔处的文本行。例如1<del>2是指每个位于偶数行号的文本行，5</del>5则指第五行和之后每五行位置的文本行</td>
</tr>
<tr>
<td align="left">addr1,+n</td>
<td align="left">匹配地址addr1和随后的n个文本行</td>
</tr>
<tr>
<td align="left">addr!</td>
<td align="left">匹配所有的文本行，除了addr之外，addr可能是上述任意的地址形式</td>
</tr>
</tbody></table>
<p><code>sed</code>基本编辑命令：  </p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">输出当前的行号。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">在当前行之后追加文本。</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">删除当前行。</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">在当前行之前插入文本。</td>
</tr>
<tr>
<td align="left">p</td>
<td align="left">打印当前行。默认情况下，sed程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定-n选项，这个默认的行为能够被忽略。</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">退出sed，不再处理更多的文本行。如果不指定-n选项，输出当前行。</td>
</tr>
<tr>
<td align="left">Q</td>
<td align="left">退出sed，不再处理更多的文本行。</td>
</tr>
<tr>
<td align="left">s/regexp/replacement/</td>
<td align="left">只要找到一个regexp匹配项，就替换replacement的内容。replacement可能包括特殊字符&amp;，其等价于由regexp匹配的文本。另外，replacement可能包括序列\1到\9，其是regexp中相对应的子表达式的内容。在replacement末尾的斜杠之后，可以指定一个可选的标志，来修改s命令的行为。</td>
</tr>
<tr>
<td align="left">y/set1/set2</td>
<td align="left">执行字符转写操作，通过把set1中的字符转变为相对应的set2中的字符。注意不同于tr程序，sed要求两个字符集合具有相同的长度。（y命令不支持字符区域（例如，[a-z]），也不支持POSIX字符集。）</td>
</tr>
</tbody></table>
<p><strong>逆参照</strong>：如果序列<code>\n</code>出现在<code>replacement</code>中，这里<code>n</code>是指从1到9的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来。  </p>
<p><code>s</code>命令的另一个功能是使用<strong>可选标志</strong>，其跟随替代字符串。一个最重要的可选标志是<code>g</code>标志，其指示sed对某个文本行全范围地执行查找和替换操作，不仅仅是对第一个实例，这是默认行为。这里有个例子：  </p>
<p>例子：  </p>
<ul>
<li><p>替换  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/text/replace/g'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p><code>-i</code>可以将替换结果应用于原文件。<br><code>/g</code>意味着<code>sed</code>会替换每一处匹配。  </p>
</li>
<li><p>移除空白行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed <span class="string">'/^$/d'</span> file</span><br></pre></td></tr></tbody></table></figure>
<p>空白行可以用正则表达式<code>^$</code>进行匹配。<br><code>/pattern/d</code>会移除匹配样式的行。  </p>
</li>
<li><p>已匹配字符串标记&amp;<br>在<code>sed</code>中，用<code>&amp;</code>标记匹配样式的字符串，就能够在替换字符串时使用已匹配的内容。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is an example | sed <span class="string">'s/\w\+/[&amp;]/g'</span>  </span><br><span class="line">[this] [is] [an] [example]  </span><br></pre></td></tr></tbody></table></figure>
<p>正则表达式<code>\w\+</code>匹配每一个单词，然后我们用<code>[&amp;]</code>替换它。<code>&amp;</code>对应于之前所匹配到的单词。  </p>
</li>
<li><p>子串匹配标记\1<br><code>&amp;</code>代表匹配给定样式的字符串。但我们也可以匹配给定样式的其中一部分。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">'s/digit \([0-9]\)/\1'</span>  </span><br><span class="line">this is 7 <span class="keyword">in</span> a number  </span><br></pre></td></tr></tbody></table></figure>
<p>这条命令将digit 7替换为7。样式中匹配到的子串是7。<code>\(pattern\)</code>用于匹配子串。模式被包括在使用斜线转义过的<code>()</code>中。对于匹配到的第一个子串，其对应的标记是<code>\1</code>，匹配到的第二个子串是<code>\2</code>，往后依次类推。<br>下面的示例中包含了多个匹配：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> seven EIGHT | sed <span class="string">'s/\([a-z]\+\) \([A-Z]\+\)/\2 \1'</span></span><br><span class="line">EIGHT seven</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>组合多个表达式<br>利用管道组合多个<code>sed</code>命令可以用下面的方式代替：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sed <span class="string">'expression; expression'</span> <span class="comment"># sed 'expression' | sed 'expression'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>引用<br><code>sed</code>表达式通常用单引号来引用。不过也可以使用双引号。双引号会通过对表达式求值来对其进行扩展。当我们想在sed表达式中使用一些变量字符串时，双引号就有用武之地了。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ text=hello</span><br><span class="line">$ <span class="built_in">echo</span> hello world | sed <span class="string">"s/<span class="variable">$text</span>/HELLO/"</span></span><br><span class="line">HELLO world</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>其他例子：替换文本或文件中的字符串<br>用另一个指定的数字替换文件中所有的3位数字：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat sed_data.txt</span><br><span class="line">11 abc 111 this 9 file contains 111 11 88 numbers 0000</span><br><span class="line">$</span><br><span class="line">$ cat sed_data.txt | sed <span class="string">'s/\b[0-9]\{3\}\b/NUMBER/g'</span></span><br><span class="line">11 abc NUMBER this 9 file contains NUMBER 11 88 numbers 0000</span><br></pre></td></tr></tbody></table></figure>
<p>上面的单行命令只替换3位数字。\b[0-9]{3}\b是一个用于匹配3位数字的正则表达式。[0-9]表示从0到9的数字范围。{3}用来匹配3次之前的数字。{3}中的<code>\</code>用于赋予<code>{</code>和<code>}</code>特殊的含义。<code>\b</code>是单词边界标记。  </p>
</li>
</ul>
<h2 id="awk入门"><a href="#awk入门" class="headerlink" title="awk入门"></a>awk入门</h2><p><code>awk</code>脚本的结构基本如下所示：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN{ commands } pattern{ commands } END{ commands }'</span> file  </span><br></pre></td></tr></tbody></table></figure>
<p>一个<code>awk</code>脚本通常由3部分组成：<code>BEGIN</code>语句块、<code>END</code>语句块和能够使用模式匹配的通用语句块。这3个部分是可选的，它们中任何一个部分都可以不出现在脚本中。脚本通常会被包含在单引号或双引号中。  </p>
<p><code>awk</code>命令的工作方式如下所示：<br>执行<code>BEGIN{ commands }</code>语句块中的语句。<br>从文件或<code>stdin</code>中读取一行，然后执行<code>pattern{ commands }</code>。重复这个过程，直到文件全部被读取完毕。<br>当读至输入流(input steam)末尾时，执行<code>END{ commands }</code>语句块。  </p>
<p><code>BEGIN</code>语句块在<code>awk</code>开始从输入流中读取行之前被执行。这是一个可选的语句块，诸如变量的初始化、打印输出表格的表头等语句通常都可以写入<code>BEGIN</code>语句块中。<br><code>END</code>语句块和<code>BEGIN</code>语句块类似。<code>END</code>语句块在<code>awk</code>从输入流中读取完所有的行之后即被执行。像打印所有行的分析结果这类汇总信息，都是在<code>END</code>语句块中实现的常见任务（例如，在比较过所有的行之后，打印出最大数）。它也是一个可选的语句块。<br>最需要的部分就是<code>pattern</code>语句块中的通用命令。这个语句块同样是可选的。如果不提供该语句块，则默认执行<code>{ print }</code>，即打印每一个读取到的行。<code>awk</code>对于读取的每一行，都会执行这个语句块。  </p>
<p>这就像一个用来读取行的<code>while</code>循环，在循环体中提供了相应的语句。<br>每读取一行时，它就会检查该行和提供的样式是否匹配。样式本身可以是正则表达式、条件以及行匹配范围等。如果当前行匹配该样式，则执行<code>{}</code>中的语句。<br>样式是可选的。如果没有提供样式，那么它就会默认所有的行都是匹配的，并执行<code>{}</code>中的语句。  </p>
<p>关于<code>print</code>：<br>当<code>print</code>的参数是以逗号进行分割时，参数打印时则以空格作为定界符；<br>在<code>awk</code>的<code>print</code>语句中，双引号是被当作拼接操作符使用的。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ var1="v1"; var2="v2"; var3="v3"; \</span></span><br><span class="line"><span class="string">print var1"-"var2"-"var3; }'</span>  </span><br><span class="line">v1-v2-v3  </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>特殊变量<br>以下是可用于<code>awk</code>的一些特殊变量：  </p>
<ul>
<li><code>NR</code> - 表示记录数量，在执行过程中对应于当前行号  </li>
<li><code>NF</code> - 表示字段数量，在执行过程中对应于当前行的字段数  </li>
<li><code>$0</code> - 这个变量包含执行过程中当前行的文本内容  </li>
<li><code>$1</code> - 这个变量包含第一个字段的文本内容  </li>
<li><code>$2</code> - 这个变量包含第二个字段的文本内容<br>例如：  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"line1 f2 f3\nline2 f4 f5\nline3 f6 f7"</span> | \</span><br><span class="line">awk <span class="string">'{print "Line no:"NR", No of fields:"NF", $0="$0", $1="$1", $2="$2", $3="$3""}'</span></span><br><span class="line">Line no:1, No of fields:3, <span class="variable">$0</span>=line1 f2 f3, <span class="variable">$1</span>=line1, <span class="variable">$2</span>=f2, <span class="variable">$3</span>=f3</span><br><span class="line">Line no:2, No of fields:3, <span class="variable">$0</span>=line2 f4 f5, <span class="variable">$1</span>=line2, <span class="variable">$2</span>=f4, <span class="variable">$3</span>=f5</span><br><span class="line">Line no:3, No of fields:3, <span class="variable">$0</span>=line3 f6 f7, <span class="variable">$1</span>=line3, <span class="variable">$2</span>=f6, <span class="variable">$3</span>=f7</span><br></pre></td></tr></tbody></table></figure>
可以用<code>print $NF</code>打印一行中最后一个字段，用<code>$(NF-1)</code>打印倒数第二个字段，其他字段依次类推即可。<br><code>awk</code>的<code>printf()</code>函数的语法和C语言中的同名函数一样。可以用这个函数来代替<code>print</code>。  </li>
</ul>
</li>
<li><p>将外部变量值传递给<code>awk</code><br>借助选项<code>-v</code>，可以将外部值（并非来自<code>stdin</code>）传递给<code>awk</code>：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ VAR=10000</span><br><span class="line">$ <span class="built_in">echo</span> | awk -v VARIABLE=<span class="variable">$VAR</span> <span class="string">'{ print VARIABLE }'</span></span><br><span class="line">10000</span><br></pre></td></tr></tbody></table></figure>
<p>还有另一种灵活的方法可以将多个外部变量传递给<code>awk</code>，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ var1=<span class="string">"Variable1"</span>; var2=<span class="string">"Variable2"</span></span><br><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ print v1,v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></span><br><span class="line">Variable1 Variable2</span><br></pre></td></tr></tbody></table></figure>
<p>当输入来自于文件而非标准输入时，使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'{ print v1 v2 }'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的方法中，变量之间用空格分隔，以键-值对的形式（v1=$var1 v2=$var2）作为<code>awk</code>的命令行参数紧随在<code>BEGIN</code>、<code>{}</code>和<code>END</code>语句块之后。  </p>
</li>
<li><p>用<code>getline</code>读取行  </p>
</li>
<li><p>用样式对<code>awk</code>处理的行进行过滤<br>可以为需要处理的行指定一些条件，例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'NR &lt; 5'</span>      <span class="comment"># 行号小于5的行</span></span><br><span class="line">$ awk <span class="string">'NR==1,NR==4'</span> <span class="comment"># 行号在1到4之间的行</span></span><br><span class="line">$ awk <span class="string">'/linux/'</span>     <span class="comment"># 包含样式linux的行（可以用正则表达式来指定样式）</span></span><br><span class="line">$ awk <span class="string">'!/linux/'</span>    <span class="comment"># 不包含样式linux的行</span></span><br></pre></td></tr></tbody></table></figure>
<p>要打印处于start_pattern与end_pattern之间的文本，使用下面的语法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'/start_pattern/, /end_pattern/'</span> filename</span><br></pre></td></tr></tbody></table></figure>
<p>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat section.txt</span><br><span class="line">line with pattern1</span><br><span class="line">line with pattern2</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br><span class="line">line with pattern5</span><br><span class="line">$</span><br><span class="line">$ awk <span class="string">'/pa.*3/, /end/'</span> section.txt</span><br><span class="line">line with pattern3</span><br><span class="line">line end with pattern4</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>设定字段定界符<br>默认的字段定界符是空格。我们也可以用 <code>-F "delimiter"</code> 明确指定一个定界符。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk -F: <span class="string">'{ print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure>
<p>或者  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN { FS=":" } { print $1,$2,$3,$NF }'</span> /etc/passwd</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>从<code>awk</code>中读取命令输出<br>在下面的代码中，<code>echo</code>会生成一个空白行。变量cmdout包含命令grep root /etc/passwd的输出，然后打印包含root的行；<br>将command的输出读入变量output的语法如下：<br>“command” | getline output ;<br>例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> | awk <span class="string">'{ "grep root /etc/passwd" | getline cmdout ; print cmdout }'</span>  </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></tbody></table></figure>
<p>通过使用<code>getline</code>，能够将外部shell命令的输出读入变量cmdout。</p>
</li>
</ul>
<p>遇到的问题：</p>
<ol>
<li><a href="https://blog.csdn.net/rj042/article/details/72860177"><code>awk</code>中不能使用<code>shell</code>定义的变量，使用<code>-v</code>选项</a></li>
<li><a href="https://stackoverflow.com/questions/34236675/kill-command-doesnt-work-in-awk"><code>kill</code>在<code>awk</code>中无所有</a></li>
</ol>
<h2 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h2><p><code>!n</code> - 执行历史文件里面行号为n的命令<br><code>!string</code> - 执行最近一个以指定字符串string开头的命令<br><code>!?string</code> - 执行最近一条包含字符串string的命令<br><code>Alt + .</code> - 插入上一个命令的最后一个词<br><code>Ctrl + k</code> - 剪切光标位置到行尾的文本<br><code>Ctrl + u</code> - 剪切光标位置到行首的文本<br><code>Ctrl + y</code> - 在光标位置粘贴文本<br><code>Ctrl + r</code> - 反向增量搜索。从当前命令行开始，向上增量搜索。意思是在字符输入的同时，bash会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入<code>Ctrl-r</code>来启动增量搜索，接着输入你要寻找的字。当你找到它以后，你可以敲入<code>Enter</code>来执行命令，或者输入<code>Ctrl-j</code>，从历史列表中复制这一行到当前命令行。再次输入<code>Ctrl-r</code>，来找到下一个匹配项（历史列表中向上移动）。输入<code>Ctrl-g</code>或者<code>Ctrl-c</code>，退出搜索。  </p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul>
<li><p>移动光标  </p>
<p>  <code>0</code> - (零按键) 移动到当前行的行首<br>  <code>^</code> - 移动到当前行的第一个非空字符<br>  <code>$</code> - 移动到当前行的末尾  </p>
</li>
<li><p>基本编辑  </p>
<p>  <code>u</code> - 撤销<br>  <code>Ctrl + r</code> - 反撤销  </p>
</li>
<li><p>打开一行  </p>
<p>  <code>o</code> - 当前行的下方打开一行<br>  <code>O</code> - 当前行的上方打开一行  </p>
</li>
<li><p>删除文本  </p>
<p>  <code>d$</code> - 从光标位置开始到当前行的行尾<br>  <code>d0</code> - 从光标位置开始到当前行的行首<br>  <code>d^</code> - 从光标位置开始到文本行的第一个非空字符<br>  <code>dG</code> - 从当前行到文件的末尾  </p>
</li>
<li><p>复制文本  </p>
<p>  <code>y$</code> - 从当前光标位置到当前行的末尾<br>  <code>y0</code> - 从当前光标位置到行首<br>  <code>y^</code> - 从当前光标位置到文本行的第一个非空字符<br>  <code>yG</code> - 从当前行到文件末尾  </p>
</li>
<li><p>连接行  </p>
<p>  <code>J</code>  </p>
</li>
</ul>
<ul>
<li><p>编辑多个文件  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ vim file1 file2 file3 ...</span><br></pre></td></tr></tbody></table></figure>
<p>  文件之间的切换：  </p>
<p>  从这个文件切换到下一个文件<code>:n</code>；<br>  回到先前的文件<code>:N</code>。  </p>
<p>  查看正在编辑的文件列表，使用<code>:buffers</code>命令。  </p>
<p>  要切换到另一个缓冲区（文件），输入<code>:buffer</code>, 紧跟着你想要编辑的缓冲器编号。  </p>
<p>  跨文件复制粘贴：正常复制粘贴。  </p>
</li>
</ul>
<h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><ul>
<li><p>内建功能  </p>
<p>  <code>set -x</code> - 在执行时显示参数和命令<br>  <code>set +x</code> - 禁止调试<br>  <code>set -v</code> - 当命令进行读取时显示输入<br>  <code>set +v</code> - 禁止打印输入  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：debug.sh</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..6}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">set</span> x</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Script executed"</span></span><br></pre></td></tr></tbody></table></figure>
<p>  在上面的脚本中，仅在<code>-x</code>和<code>+x</code>所限制的区域，echo $i的调试信息才会被打印出来。  </p>
<p>  有一些环境变量常用于调试：<br>  <code>LINENO</code> - 返回它在脚本里面的行号<br>  <code>FUNCNAME</code> - 返回一个数组，内容是当前的函数调用堆栈。该数组的0号成员是当前调用的函数，1号成员是调用当前函数的函数，以此类推<br>  <code>BASH_SOURCE</code> - 返回一个数组，内容是当前的脚本调用堆栈。该数组的0号成员是当前执行的脚本，1号成员是调用当前脚本的脚本，以此类推，跟变量<code>FUNCNAME</code>是一一对应关系<br>  <code>BASH_LINENO</code> - 返回一个数组，内容是每一轮调用对应的行号  </p>
<p>  <code>${BASH_LINENO[$i]}</code>跟<code>${FUNCNAME[$i]}</code>是一一对应关系，表示<code>${FUNCNAME[$i]}</code>在调用它的脚本文件<code>${BASH_SOURCE[$i+1]}</code>里面的行号</p>
</li>
<li><p>自定义格式  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">DEBUG</span></span>()</span><br><span class="line">{</span><br><span class="line">[ <span class="string">"<span class="variable">$_DEBUG</span>"</span> == <span class="string">"on"</span> ] &amp;&amp; <span class="variable">$@</span> || :</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> {1..10}</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">DEBUG <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>
<p>  可以将调试功能置为”on”来运行上面的脚本：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ _DEBUG=on ./script.sh  </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>shebang  </p>
<p>  把<code>shebang</code>从<code>#!/bin/bash</code>改成<code>#!/bin/bash -xv</code>，这样一来，不用任何其他选项就可以启用调试功能了。 </p>
</li>
</ul>
<ul>
<li><p>注释  </p>
<p>  单行注释：<code>#</code><br>  多行注释：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">&lt;&lt;<span class="string">'!'</span></span><br><span class="line">commands</span><br><span class="line">...</span><br><span class="line">!</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">ps -aux</span><br></pre></td></tr></tbody></table></figure>

<p>用 <code>top</code> 命令动态查看进程。  </p>
<p>中断一个进程<code>Ctrl+c</code>。  </p>
<p>把一个进程放置到后台 (执行)：在程序命令之后，加上<code>&amp;</code>字符：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 <code>jobs</code> 命令，可以看到输出列表：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br></pre></td></tr></tbody></table></figure>

<p>进程返回到前台：<br>一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 <code>Ctrl-c</code> 来中断它。为了让一个进程返回前台 (foreground)，这样使用 <code>fg</code> 命令：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]+ Running xlogo &amp;</span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">xlogo</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>fg</code> 命令，可以恢复程序到前台运行，或者用 <code>bg</code> 命令把程序移到后台。  </p>
<p>停止一个进程<code>Ctrl+z</code>：输入 <code>Ctrl-z</code>，可以停止一个前台进程。  </p>
<p>通过 <code>kill</code> 命令给进程发送信号。<br>通过 <code>killall</code> 命令给多个进程发送信号。  </p>
<h3 id="目录堆栈"><a href="#目录堆栈" class="headerlink" title="目录堆栈"></a>目录堆栈</h3><ul>
<li><p><code>cd -</code>  </p>
</li>
<li><p><code>pushd</code>, <code>popd</code>  </p>
<p>  希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。<br>  <code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">pushd</span> dirname</span><br></pre></td></tr></tbody></table></figure>
<p>  上面命令会进入目录dirname，并将该目录放入堆栈。<br>  <code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。  </p>
<ul>
<li><p><code>-n</code><br>  表示仅操作堆栈，不改变目录。  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">popd</span> -n</span><br></pre></td></tr></tbody></table></figure>
<p>  上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。  </p>
</li>
<li><p>整数参数  </p>
</li>
<li><p>目录参数  </p>
</li>
</ul>
</li>
<li><p><code>dirs</code>  </p>
<p>  <code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。  </p>
<p>  参数：  </p>
<pre><code>  `-c`：清空目录栈。  
  `-l`：用户主目录不显示波浪号前缀，而打印完整的目录。  
  `-p`：每行一个条目打印目录栈，默认是打印在一行。  
  `-v`：每行一个条目，每个条目之前显示位置编号（从0开始）。  
</code></pre>
</li>
</ul>
<h3 id="校验和核实"><a href="#校验和核实" class="headerlink" title="校验和核实"></a>校验和核实</h3><ul>
<li><p><code>md5sum</code>  </p>
<p>  将输出的校验和重定向到一个文件，然后用这个MD5文件核实数据的完整性：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ md5sum filename &gt; file_num.md5</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ md5sum -c file_sum.md5</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>sha1sum</code>  </p>
<p>  用法与md5sum类似：  </p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sha1sum filename &gt; file_num.sha1</span><br></pre></td></tr></tbody></table></figure>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sha1sum -c file_sum.sha1</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h3><p><code>-t</code>参数 - 设置超时秒数<br><code>-p</code>参数 - 指定用户输入的提示信息<br><code>-a</code>参数 - 把用户的输入赋值给一个数组，从零号位置开始<br><code>-n</code>参数 - 指定只读取若干个字符作为变量值，而不是整行读取<br><code>-e</code>参数 - 允许用户输入的时候，使用ReadLine库提供的快捷键，比如自动补全<br>其他参数 - 其他参数功能  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"Enter one or more values &gt; "</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"REPLY = '<span class="variable">$REPLY</span>'"</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">read</span> -p <span class="string">"What do you want? </span></span><br><span class="line"><span class="string">    1) AAA</span></span><br><span class="line"><span class="string">    2) BBB</span></span><br><span class="line"><span class="string">    3) CCC</span></span><br><span class="line"><span class="string">    Type your choice: "</span> MyChoice</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MyChoice</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="生成任意大小的文件"><a href="#生成任意大小的文件" class="headerlink" title="生成任意大小的文件"></a>生成任意大小的文件</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</span><br></pre></td></tr></tbody></table></figure>
<p>该命令会创建一个1MB大小的文件junk.data。<br><code>if</code>代表输入文件(Input File)，<code>of</code>代表输出文件(Output File)，<code>bs</code>代表以字节为单位的块大小(Block Size)，<code>count</code>代表需要被复制的块数。  </p>
<h3 id="压缩归档文件"><a href="#压缩归档文件" class="headerlink" title="压缩归档文件"></a>压缩归档文件</h3><p>选项<code>-a</code>指定从文件扩展名自动判断压缩格式。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar -cavf archive.tar.gz [FILES]</span><br><span class="line">$ tar -cavf archive.tar.bz2 [FILES]</span><br><span class="line">$ tar -cavf archive.tar.lzma [FILES]</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ tar -xvf archive.tar.gz</span><br><span class="line">$ tar -xvf archive.tar.bz2</span><br><span class="line">$ tar -xvf archive.tar.lzma</span><br></pre></td></tr></tbody></table></figure>

<h3 id="mktemp命令"><a href="#mktemp命令" class="headerlink" title="mktemp命令"></a>mktemp命令</h3><p><code>mktemp</code>命令就是为安全创建临时文件而存在的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。  </p>
<p>Bash脚本使用<code>mktemp</code>命令的用法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了确保临时文件创建成功，<code>mktemp</code>命令后面最好使用OR运算符<code>||</code>，保证创建失败时退出脚本。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了保证脚本退出时临时文件被删除，可以使用<code>trap</code>命令指定退出时的清除操作。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br><span class="line"></span><br><span class="line">TMPFILE=$(mktemp) || <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Our temp file is <span class="variable">$TMPFILE</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>mktemp</code>命令的参数：<br><code>-d</code>参数可以创建一个临时目录。<br><code>-p</code>参数可以指定临时文件所在的目录。默认是使用$TMPDIR环境变量指定的目录，如果这个变量没设置，那么使用/tmp目录。<br><code>-t</code>参数可以指定临时文件的文件名模板。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ mktemp -t mytemp.XXXXXXX -p <span class="built_in">test</span>/</span><br></pre></td></tr></tbody></table></figure>


<h3 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h3><p><code>trap</code>命令用来在Bash脚本中响应系统信号。<br><code>trap</code>的命令格式如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> [动作] [信号1] [信号2] ...</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，”动作”是一个Bash命令，”信号”常用的有以下几个。<br>HUP：编号1，脚本与所在的终端脱离联系。<br>INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。<br>QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。<br>KILL：编号9，该信号用于杀死进程。<br>TERM：编号15，这是kill命令发出的默认信号。<br>EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。  </p>
<p><code>trap</code>命令响应EXIT信号的写法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">trap</span> <span class="string">'rm -f "$TMPFILE"'</span> EXIT</span><br></pre></td></tr></tbody></table></figure>
<p>上面命令中，脚本遇到EXIT信号时，就会执行rm -f “$TMPFILE”。  </p>
<p>trap命令的常见使用场景，就是在Bash脚本中指定退出时执行的清理命令。<br>注意，trap命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。  </p>
<p>如果trap需要触发多条命令，可以封装一个Bash函数。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> egress {</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">	command3</span><br><span class="line">}</span><br><span class="line"><span class="built_in">trap</span> egress EXIT</span><br></pre></td></tr></tbody></table></figure>


<h3 id="set命令-shopt命令"><a href="#set命令-shopt命令" class="headerlink" title="set命令,shopt命令"></a>set命令,shopt命令</h3><p><strong>set -u</strong> - 遇到不存在的变量就会报错，并停止执行<br><strong>set -x</strong> - 在运行结果之前，先输出执行的那一行命令<br>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。  </p>
<p>Bash的错误处理<br>如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。这种行为很不利于脚本安全和除错。<br>实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> || <span class="built_in">exit</span> 1</span><br></pre></td></tr></tbody></table></figure>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。<br>写法一：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> || { <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; }</span><br></pre></td></tr></tbody></table></figure>
<p>写法二：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>
<p>写法三：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"command failed"</span>; <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br></pre></td></tr></tbody></table></figure>

<p><strong>set -e</strong><br>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。<br><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。  </p>
<p>还有一种方法是使用command || true，使得该命令即使执行失败，脚本也不会终止执行  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">foo || <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> bar</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中，true使得这一行语句总是会执行成功，后面的echo bar会执行。  </p>
<p><strong>set -o pipefail</strong><br><code>set -e</code>有一个例外情况，就是不适用于管道命令。<br>所谓管道命令，就是多个子命令通过管道运算符<code>|</code>组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。<br><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。  </p>
<p><strong>set -E</strong><br>一旦设置了<code>-e</code>参数，会导致函数内的错误不会被<code>trap</code>命令捕获。<br><code>-E</code>参数可以纠正这个行为，使得函数也能继承<code>trap</code>命令。  </p>
<p><strong>其他参数</strong>  </p>
<p><code>set</code>命令总结：<br>上面重点介绍的<code>set</code>命令的几个参数，一般都放在一起使用：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -Eeuxo pipefail</span><br></pre></td></tr></tbody></table></figure>
<p>建议放在所有Bash脚本的头部。  </p>
<p><code>shopt</code>命令<br><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。<br><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。<br><code>shopt</code>命令的使用方法如下：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s [optionname] <span class="comment">#打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname] <span class="comment">#关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname] <span class="comment">#查询某个参数关闭还是打开</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>我们可以用管道将一个命令的<code>stdout</code>(标准输出)重定向到另一个命令的<code>stdin</code>(标准输入)。例如：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cat foo.txt | grep <span class="string">"test"</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是，有些命令只能以命令行参数的形式，而无法通过<code>stdin</code>接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据。  </p>
<p><code>xargs</code>能够处理<code>stdin</code>并将其转换为特定命令的命令行参数；<code>xargs</code>也可以将单行或多行文本输入转换成其他格式，例如单行变多行或是多行变单行。  </p>
<p><code>-d</code>: 为输入指定一个定制的定界符。<br><code>-n</code>: 指定每行最大的参数数量。<br><code>-I</code>: 指定一个替换字符串，对于每一个参数，命令都会被执行一次。  </p>
<p>例子1：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X  </span><br><span class="line">split split split split  </span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"splitXsplitXsplitXsplit"</span> | xargs -d X -n 2  </span><br><span class="line">split split  </span><br><span class="line">split split  </span><br><span class="line">$</span><br></pre></td></tr></tbody></table></figure>

<p>例子2：<br>有一个cecho.sh脚本：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#文件名：cecho.sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*<span class="string">'#'</span></span><br></pre></td></tr></tbody></table></figure>

<p>有一个args.txt文件：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat args.txt  </span><br><span class="line">arg1  </span><br><span class="line">arg2  </span><br><span class="line">arg3  </span><br></pre></td></tr></tbody></table></figure>

<p>试试如下用法：  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l  </span><br><span class="line">-p arg1 -l <span class="comment">#  </span></span><br><span class="line">-p arg2 -l <span class="comment">#  </span></span><br><span class="line">-p arg3 -l <span class="comment">#  </span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>less</code> - 浏览文件内容<br><code>which</code> - 查找可执行文件的绝对路径<br><code>whereis</code> - 查找命令、二进制文件、man文件、源代码文件<br><code>wc</code> - 打印行数、字数和字节数<br><code>diff/patch</code>    </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ diff -Naur old_file new_file &gt; diff_file  </span><br><span class="line">$ patch &lt; diff_file  </span><br></pre></td></tr></tbody></table></figure>

<p><code>history</code> - 显示历史列表内容<br><code>df</code> - 显示磁盘分区上可以使用的磁盘空间<br><code>du</code> - 显示每个文件和目录的磁盘使用空间 </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ du -sh <span class="comment">#查看当前目录总计容量</span></span><br><span class="line">232G	.</span><br></pre></td></tr></tbody></table></figure>

<p><code>free</code> - 显示内存<br><code>file</code> - 识别文件类型<br><code>sort</code> - 排序文本行<br><code>uniq</code> - 报道或省略重复行<br><code>cut</code> - 从每行中删除文本区域<br><code>paste</code> - 合并文件文本行<br><code>join</code> - 基于某个共享字段来联合两个文件的文本行<br><code>comm</code> - 逐行比较两个有序的文件<br><code>tr</code> - 翻译或删除字符<br><code>grep</code> - 打印匹配行<br><code>ln file link</code> - 创建硬链接<br><code>ln -s item link</code> - 创建链接符号，item可以是一个文件或是一个目录<br>    当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中， <code>ls</code>命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。<br>    当建立符号链接时，你既可以使用绝对路径名，也可用相对路径名。<br>    不同目录，创建链接符号需要绝对地址，否则也是坏链接，会提示找不到文件。<br><code>rsync</code> - 备份/同步<br><code>time</code> - 计算命令执行时间<br><code>find</code> - 在一个目录层次结构中搜索文件<br><code>touch</code> - 更改文件时间<br><code>stat</code> - 显示文件或文件系统状态<br><code>alias</code> - 别名  </p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> install=<span class="string">'sudo apt-get install'</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>date</code> - 获取、设置日期<br><code>sleep</code> - 延时  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><a href="https://bbs.csdn.net/topics/394186543">[Linux资讯] Cshell 怎样实现变量名包含变量名？</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://man.linuxde.net/">Linux命令大全</a>  </li>
<li><a href="https://www.linuxcool.com/pronunciation">中国程序员最容易读错的单词汇总（带正确发音示范）</a>  </li>
<li><a href="https://blog.csdn.net/ljlfather/article/details/105106875">Bash Shell 中的 算术运算符、逻辑与或非(&amp; | ！)运算符、整数关系运算符、字符串关系运算符、文件或目录测试运算符</a></li>
</ol>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>script</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>C++核心编程</title>
    <url>/2021/07/17/cpp-2/</url>
    <content><![CDATA[<p>核心编程  </p>
<span id="more"></span>

<p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​    在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​    <strong>代码区：</strong></p>
<p>​        存放 CPU 执行的机器指令</p>
<p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​    <strong>全局区：</strong></p>
<p>​        全局变量和静态变量存放在此.</p>
<p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​        ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"局部变量a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"局部变量b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"全局变量g_a地址为： "</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"全局变量g_b地址为： "</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"静态变量s_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"静态变量s_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">"hello world"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"字符串常量地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">"hello world1"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"全局常量c_g_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"全局常量c_g_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"局部常量c_l_a地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"局部常量c_l_b地址为： "</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>打印结果：</p>
<p><img src="assets/1545017602518.png" alt="1545017602518"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p>​    <strong>栈区：</strong></p>
<p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<p>​    <strong>堆区：</strong></p>
<p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​        在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>​    C++中利用==new==操作符在堆区开辟数据</p>
<p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>
<p>​    语法：<code> new 数据类型</code></p>
<p>​    利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>











<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="string">" b:"</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref2 = "</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>​    </p>
<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>{</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"ref:"</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>{</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）{}</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"this is func"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func 的调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (int a) 的调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (double a)的调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (int a ,double b) 的调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (double a ,int b)的调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "func (double a ,int b)的调用！" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (int &amp;a) 调用 "</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func (const int &amp;a) 调用 "</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func2(int a, int b = 10) 调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func2(int a) 调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​    在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名{   访问权限： 属性  / 行为  };</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="keyword">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"圆的周长为： "</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>{</span><br><span class="line">		m_name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">		m_id = id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"name:"</span> &lt;&lt; m_name &lt;&lt; <span class="string">" ID:"</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="keyword">int</span> m_id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">"德玛西亚"</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_Name = <span class="string">"张三"</span>;</span><br><span class="line">		m_Car = <span class="string">"拖拉机"</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">"李四"</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = "奔驰";  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>{</span><br><span class="line">		m_Name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) {</span><br><span class="line">			cout &lt;&lt; <span class="string">"你个老妖精!"</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		m_Age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>{</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">"张三"</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"年龄： "</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">"苍井"</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "情人： " &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img src="assets/1545533548532.png" alt="1545533548532"></p>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img src="assets/1545533829184.png" alt="1545533829184"></p>
<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名(){}</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名(){}</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person的构造函数调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person的析构函数调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​    按参数分为： 有参构造和无参构造</p>
<p>​    按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法</p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"无参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a) {</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) {</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"无参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>{}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"无参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a) {</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) {</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p2的年龄为： "</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"无参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age ,<span class="keyword">int</span> height) {</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">"有参构造函数!"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"拷贝构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() {</span><br><span class="line">		cout &lt;&lt; <span class="string">"析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_age;</span><br><span class="line">	<span class="keyword">int</span>* m_height;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p1的年龄： "</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">" 身高： "</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p2的年龄： "</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">" 身高： "</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) {</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) {}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"mB:"</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"mC:"</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    A a；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	{</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Phone构造"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Phone析构"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person构造"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person析构"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">" 使用"</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">" 牌手机! "</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"张三"</span> , <span class="string">"苹果X"</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>











<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li> 所有对象共享同一份数据</li>
<li> 在编译阶段分配内存</li>
<li> 类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li> 所有对象共享同一个函数</li>
<li> 静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"p1.m_A = "</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"p1.m_A = "</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"p2.m_A = "</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"m_A = "</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "m_B = " &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"func调用"</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"func2调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="keyword">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>{</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li> 当形参和成员变量同名时，可用this指针来区分</li>
<li> 在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"p1.age = "</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">"p2.age = "</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"我是Person类!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>








<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问： "</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问： "</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">{</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">"卧室"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">{</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"好基友正在访问"</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "好基友正在访问" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {};</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p) {</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) {</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p2, <span class="keyword">int</span> val)  </span><br><span class="line">{</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">" mB:"</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">" mB:"</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p){</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) {</span><br><span class="line">	out &lt;&lt; <span class="string">"a:"</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">" b:"</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> {</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() {</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() {</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) {</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) {</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="keyword">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p1的年龄为："</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p2的年龄为："</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"p3的年龄为："</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">"孙悟空"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">"孙悟空"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a和b相等"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a和b不相等"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a和b不相等"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a和b相等"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">"hello world"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"ret = "</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">"MyAdd()(100,100) = "</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>









<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="assets/1544861202252.png" alt="1544861202252"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"首页、公开课、登录、注册...（公共头部）"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"帮助中心、交流合作、站内地图...(公共底部)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Java,Python,C++...(公共分类列表)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"JAVA学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"首页、公开课、登录、注册...（公共头部）"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"帮助中心、交流合作、站内地图...(公共底部)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Java,Python,C++...(公共分类列表)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Python学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"首页、公开课、登录、注册...（公共头部）"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"帮助中心、交流合作、站内地图...(公共底部)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Java,Python,C++...(公共分类列表)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"C++学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Java下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Python下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"C++下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"首页、公开课、登录、注册...（公共头部）"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"帮助中心、交流合作、站内地图...(公共底部)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Java,Python,C++...(公共分类列表)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"JAVA学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Python学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"C++学科视频"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Java下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"Python下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"C++下载视频页面如下： "</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="assets/clip_image002.png" alt="img"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>









<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_D;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"sizeof Son = "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<p>利用工具查看：</p>
<p><img src="assets/1545881904150.png" alt="1545881904150"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<p><img src="assets/1545882158050.png" alt="1545882158050"></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Son构造函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Son析构函数!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	{</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base - func()调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base - func(int a)调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	{</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Son - func()调用"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"Son下的m_A = "</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Base下的m_A = "</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base - static void func()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Base - static void func(int a)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Son - static void func()"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"通过对象访问： "</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Son  下 m_A = "</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Base 下 m_A = "</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"通过类名访问： "</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Son  下 m_A = "</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"Base 下 m_A = "</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"通过对象访问： "</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"通过类名访问： "</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	{</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	{</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_A;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	{</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_C;</span><br><span class="line">	<span class="keyword">int</span> m_D;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">"sizeof Son = "</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​    两个派生类继承同一个基类</p>
<p>​    又有某个类同时继承者两个派生类</p>
<p>​    这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<p><img src="assets/clip_image002.jpg" alt="IMG_256"></p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"st.Sheep::m_Age = "</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"st.Tuo::m_Age = "</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"st.m_Age = "</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"动物在说话"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"小猫在说话"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"小狗在说话"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">"+"</span>) {</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">"-"</span>) {</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">"*"</span>) {</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Num1;</span><br><span class="line">	<span class="keyword">int</span> m_Num2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">" + "</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">"+"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">"-"</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">" * "</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">"*"</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_Num1;</span><br><span class="line">	<span class="keyword">int</span> m_Num2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">" + "</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">" - "</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">" * "</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"func调用"</span> &lt;&lt; endl;</span><br><span class="line">	};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>















<h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="assets/1545985945198.png" alt="1545985945198"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span> <span class="keyword">public</span> AbstractDrinking {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"煮农夫山泉!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"冲泡咖啡!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"将咖啡倒入杯中!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"加入牛奶!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> AbstractDrinking {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"煮自来水!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"冲泡茶叶!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"将茶水倒入杯中!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"加入枸杞!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>{</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



















<h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名(){}</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名(){}</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Animal 构造函数调用！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; "Animal虚析构函数调用！" &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">{</span><br><span class="line">	cout &lt;&lt; <span class="string">"Animal 纯虚析构函数调用！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Cat构造函数调用！"</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">"小猫在说话!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Cat析构函数调用!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">"Tom"</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​    3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoCard</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	{</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	{</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Intel的CPU开始计算了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Intel的显卡开始显示了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntelMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Intel的内存条开始存储了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoCPU</span> :</span><span class="keyword">public</span> CPU</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Lenovo的CPU开始计算了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoVideoCard</span> :</span><span class="keyword">public</span> VideoCard</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Lenovo的显卡开始显示了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoMemory</span> :</span><span class="keyword">public</span> Memory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Lenovo的内存条开始存储了！"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"第一台电脑开始工作："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"-----------------------"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"第二台电脑开始工作："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"-----------------------"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"第三台电脑开始工作："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>













<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
<p>​</p>
</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">"姓名：张三"</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">"性别：男"</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">"年龄：18"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>  #include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = { 0 };</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = { 0 };</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件 </li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">"person.txt"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open("person.txt", ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = {<span class="string">"张三"</span>  , <span class="number">18</span>};</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">"person.txt"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"文件打开失败"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
<p>作者：<a href="https://www.bilibili.com/video/BV1et411b73Z">黑马程序员</a>  </p>
<iframe src="//player.bilibili.com/player.html?aid=41559729&amp;bvid=BV1et411b73Z&amp;cid=72978340&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>扫台2</title>
    <url>/2021/10/20/scan-si/</url>
    <content><![CDATA[<p>理解不深，尽量记录扫台流程关于si的部分，免得以后又重新看。</p>
<span id="more"></span>

<p>结合上篇<a href="https://ylab324.github.io/2021/09/16/scan/">《扫台》</a>，直接从ScanThread线程xWorkerThread状态机看起。</p>
<h2 id="si-agent-threadfuntion"><a href="#si-agent-threadfuntion" class="headerlink" title="si_agent_threadfuntion"></a>si_agent_threadfuntion</h2><h3 id="SI-AGENT-STATUS-STOPPED"><a href="#SI-AGENT-STATUS-STOPPED" class="headerlink" title="SI_AGENT_STATUS_STOPPED"></a>SI_AGENT_STATUS_STOPPED</h3><h4 id="xWorkerThread-CH-SCAN-STATE-INIT"><a href="#xWorkerThread-CH-SCAN-STATE-INIT" class="headerlink" title="xWorkerThread CH_SCAN_STATE_INIT"></a>xWorkerThread CH_SCAN_STATE_INIT</h4><p>关注CH_SCAN_STATE_INIT这个case，跑了xStageInit()这个函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/TableScanner.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTableScanner::xStageInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_pFreqScanDetector-&gt;<span class="built_in">Mf_ScanInit</span>(scanMode, param, m_bDelNosignalMux,scanModeEx);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_scanState = CH_SCAN_STATE_BEGIN_FREQ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::Mf_ScanInit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CH_SCAN_MODE scanMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32 param,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">bool</span> bDelNoSignalMux,</span></span></span><br><span class="line"><span class="params"><span class="function">    CH_SCAN_MODE_EX modeEx</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    pDtvFlow-&gt;<span class="built_in">PrepareAutoScanFlow</span>();</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanInit</span>(<span class="built_in">getSiScanType</span>(scanMode), param, typeEx);</span><br><span class="line">    <span class="comment">// 省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* DriverBasedDtvApp/DriverBasedDtvApp.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DriverBasedDtvApp::PrepareAutoScanFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">"[%s %s %d]\n"</span>,__FILE__, __func__, __LINE__);</span><br><span class="line">	<span class="comment">//Q: need to stop VDEC and ADEC if they are present?</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">OpenSdec</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见扫台前有个OpenSdec的动作，Sdec是System Decoder的意思（类似的还有用Vdec和Adec分别表示Video Decoder、Audio Decoder）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* DriverBasedDtvApp/DriverBasedDtvApp.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DriverBasedDtvApp::OpenSdec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(m_sdec &lt; SDEC_CH_MAX)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">RHAL_SDEC_AcquireChannel</span>(<span class="string">"DTV_LIVE"</span>, SDEC_CH_PVR_ONLY);</span><br><span class="line">	<span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"[%s %d] fail to acquire SDEC\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	m_sdec = (SDEC_CHANNEL_T)index;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d]  m_sdec = %d\n"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">	m_sdecSrc = (m_sdec == SDEC_CH_A) ? HAL_AUDIO_RESOURCE_SDEC0 : HAL_AUDIO_RESOURCE_SDEC1;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">RHAL_SDEC_InitChannel</span>(m_sdec) != API_OK)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"[%s %d] ERROR : RHAL_SDEC_InitChannel fails. m_sdec = %d"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">RHAL_SDEC_SetBufferOwner</span>(m_sdec, SDEC_KERNEL_DRIVER) != API_OK)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"[%s %d] ERROR : RHAL_SDEC_Run fails. m_sdec = %d"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] Set RHAL_SDEC_EnableTimeStampPadding. m_sdec = %d"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">RHAL_SDEC_EnableTimeStampPadding</span>(m_sdec, <span class="literal">true</span>) != API_OK)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"[%s %d] ERROR : RHAL_SDEC_EnableTimeStampPadding fails. m_sdec = %d"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">RHAL_SDEC_Run</span>(m_sdec) != API_OK)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"[%s %d] ERROR : RHAL_SDEC_Run fails. m_sdec = %d"</span>, __func__, __LINE__, m_sdec);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">SetSdecInputConfig</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_pSiInterface == <span class="number">0</span>)</span><br><span class="line">		m_pSiInterface = <span class="keyword">new</span> <span class="built_in">CSiInterface</span>(<span class="keyword">this</span>, m_tvsystem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(m_pSiInterface)</span><br><span class="line">	{</span><br><span class="line">		m_pSiInterface-&gt;<span class="built_in">InitSiEngine</span>(m_sdec, m_siHandle);</span><br><span class="line">		<span class="comment">// ConnectAudio to decide audio preiview on</span></span><br><span class="line">		<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] Set audio preview on first, AudioPreviewOn: %d\n"</span>, __func__, __LINE__, m_status.bIsAudioPreviewOn);</span><br><span class="line">		m_pSiInterface-&gt;<span class="built_in">SetAudioPreviewMode</span>(m_status.bIsAudioPreviewOn);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后InitSiEngine，Engine是用来干嘛的？理解不足，名字就像做一些si管理统筹工作的，然后siEngineOut、m_siEngineIn做一些状态更新，发消息等的信息输入输出：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* DriverBasedDtvApp/CSiInterface.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSiInterface::InitSiEngine</span><span class="params">(SDEC_CHANNEL_T sdec, <span class="keyword">unsigned</span> <span class="keyword">int</span> siHandle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SI_ENGINE_OUT siEngineOut;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	siEngineOut.InsertFilterList   = insertFilterList;</span><br><span class="line">	siEngineOut.RemoveFilterList   = removeFilterList;</span><br><span class="line">	siEngineOut.RemoveAllFilters   = removeAllFilters;</span><br><span class="line">	siEngineOut.SetActiveComponent = setActiveComponent;</span><br><span class="line">	siEngineOut.PostEvent		  = postEvent;</span><br><span class="line">	siEngineOut.SetSiState		 = setSiState;</span><br><span class="line">	siEngineOut.CheckScramble	   = checkScramble;</span><br><span class="line">	siEngineOut.ResetPosition	  = resetPosition;</span><br><span class="line">	siEngineOut.FeedbackPrivateInfo = feedbackPrivateInfo;</span><br><span class="line">	siEngineOut.GetPIDByFilterType  = getPIDByFilterType;<span class="comment">//#ifdef ENABLE_MHEG5</span></span><br><span class="line">	m_siHandle = siHandle;</span><br><span class="line">	m_sdec = sdec;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m_siEngineIn, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(m_siEngineIn));</span><br><span class="line">	<span class="keyword">if</span> (m_tvSystem== RT_TV_SYSTEM_ATSC){</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ATSC_T</span></span><br><span class="line">		ret = <span class="built_in">AttachSiAtscEngine</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="keyword">this</span>, &amp;siEngineOut, m_siHandle, &amp;m_siEngineIn);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (m_tvSystem==RT_TV_SYSTEM_DVB){</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DVB_T</span></span><br><span class="line">		ret = <span class="built_in">AttachSiEngine</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="keyword">this</span>, &amp;siEngineOut, m_siHandle, &amp;m_siEngineIn);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"%s_%d: unknown tvsystem, fail to InitSiEngine\n"</span>, __func__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		m_siEngineIn.<span class="built_in">SetSdecCh</span>(siHandle, (<span class="keyword">int</span>)m_sdec);</span><br><span class="line">		m_bSiEngineAttached = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">RemoveAllFilters</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">ALOGE</span>(<span class="string">"%s_%d: unknown tvsystem, fail to InitSiEngine\n"</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m_bSiEngineAttached;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/tpInterface/PVR/siEngine.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AttachSiEngine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   navHandle,    <span class="comment">/* IN:  handle of the nav outside */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SI_ENGINE_OUT* pSiEngineOut, <span class="comment">/* IN:  outgoing interface for SI engine */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   siHandle,     <span class="comment">/* IN:  handle of the SI engine */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SI_ENGINE_IN*  pSiEngineIn   <span class="comment">/* OUT: incoming interface for SI engine */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">void</span> *tp1, *tp2;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pSiEngineOut || !pSiEngineIn || !siHandle)</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    SI_Get_TP((SI*)siHandle, &amp;tp1);</span><br><span class="line"></span><br><span class="line">    SI_TPInterface_New(&amp;tp2, navHandle, (<span class="keyword">void</span>*)pSiEngineOut</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_USE_SDEC</span></span><br><span class="line">                       ,siHandle,SDEC_CH_MAX</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                      );</span><br><span class="line"></span><br><span class="line">    SI_Set_TP((SI*)siHandle, tp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tp1)</span><br><span class="line">    {</span><br><span class="line">        SI_TPInterface_Destroy(&amp;tp1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Functions for TS engine to call upon.</span></span><br><span class="line">    pSiEngineIn-&gt;StoreSiPacket	= SI_PVRInterface_StorePackets;</span><br><span class="line">    pSiEngineIn-&gt;StoreSiState	= SI_PVRInterface_StoreSiState;</span><br><span class="line">    pSiEngineIn-&gt;Flush			= SI_PVRInterface_Flush;</span><br><span class="line">    pSiEngineIn-&gt;GetBufferLength= SI_GetRingBufferLength;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_USE_SDEC</span></span><br><span class="line">    pSiEngineIn-&gt;SetSdecCh			= SetSdecCh;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> FEATURE_001</span></span><br><span class="line">    pSiEngineIn-&gt;GetPAT			= <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FEATURE_001	</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/api/SI_Api.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Set_TP</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI									*pSI,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>								*tp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_API_BEGIN();</span><br><span class="line">    SI_ASSERT(pSI);</span><br><span class="line"></span><br><span class="line">    pSI-&gt;tp = tp;</span><br><span class="line">    pSI-&gt;collector-&gt;tp = tp;</span><br><span class="line">    SI_Agent_New(&amp;pSI-&gt;agent, pSI, pSI-&gt;db, pSI-&gt;collector, pSI-&gt;tp);</span><br><span class="line"></span><br><span class="line">    SI_API_RETURN(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个SI_Agent_New还挺长，先记一点关键的，这个Agent的概念又该怎么理解呢？不懂：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/SI_Agent.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Agent_New</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_AGENT							**ppAgent,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI									*pSI,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_DATABASE							*pDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_COLLECTOR						*pCollector,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>								*pTPHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    agent-&gt;agentObjHandle = (<span class="keyword">void</span>*)SiAgtIF_CreateSiAgentObject(<span class="string">"UND"</span>, pSI, pDatabase, pTPHandle);</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    agent-&gt;status = SI_AGENT_STATUS_STOPPED;</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    SiAgtIF_RegisterCBF(agent-&gt;agentObjHandle, SI_Callback_ScanChannel, SI_AGENT_CBF_TYPE_SCAN_CHANNEL);</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    pthread_create(&amp;__agentThread, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)&amp;si_agent_threadfuntion, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里要分3部分看：</p>
<ul>
<li><p>SiAgtIF_CreateSiAgentObject</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentInterface.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">SIAGENT_OBJECT_P <span class="title">SiAgtIF_CreateSiAgentObject</span><span class="params">( <span class="keyword">char</span>* pAgentObjectName, SI_HANDLE si, SIDB_HANDLE handleSidb, DEMUXER_HANDLE handleDemuxer )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> SiAgent_CreateSiAgentObject( pAgentObjectName, si, handleSidb, handleDemuxer );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentObject.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">SIAGENT_OBJECT_P <span class="title">SiAgent_CreateSiAgentObject</span><span class="params">( <span class="keyword">char</span>* pAgentObjectName, SI_HANDLE si, SIDB_HANDLE handleSidb, DEMUXER_HANDLE handleDemuxer )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line"><span class="comment">//Private Method:</span></span><br><span class="line">    pSiAgentObj-&gt;ExecMainTaskSM = SiAgentObj_ExecMainTaskSM ;</span><br><span class="line">    pSiAgentObj-&gt;ExecSubTaskSM = SiAgentObj_ExecSubTaskSM ;</span><br><span class="line">    pSiAgentObj-&gt;CheckSubTaskInQueue = SiAgentObj_CheckSubTaskInQueue ;</span><br><span class="line">    pSiAgentObj-&gt;GetSubTaskFromQueue = SiAgentObj_GetSubTaskFromQueue ;</span><br><span class="line">    pSiAgentObj-&gt;CheckMainTaskInQueue = SiAgentObj_CheckMainTaskInQueue ;</span><br><span class="line">    pSiAgentObj-&gt;GetMainTaskFromQueue = SiAgentObj_GetMainTaskFromQueue ;</span><br><span class="line"><span class="comment">//Public Method:</span></span><br><span class="line">    pSiAgentObj-&gt;GetSidbHandle = SiAgentObj_GetSidbHandle ;</span><br><span class="line">    pSiAgentObj-&gt;GetObjectId = SiAgentObj_GetObjectId ;</span><br><span class="line">    pSiAgentObj-&gt;Run = SiAgentObj_Run ;</span><br><span class="line">    pSiAgentObj-&gt;CheckAllSmIdle = SiAgentObj_CheckAllSmIdle ;</span><br><span class="line">    pSiAgentObj-&gt;InsertMainTaskIntoQueue = SiAgentObj_InsertMainTaskIntoQueue ;</span><br><span class="line">    pSiAgentObj-&gt;StopAllTask = SiAgentObj_StopAllTask ;</span><br><span class="line">    pSiAgentObj-&gt;RegisterCBF = SiAgentObj_RegisterCBF ;</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里主要是设置SiAgentObject的一些方法，比如Run、ExecMainTaskSM等，后面会用到。</p>
</li>
<li><p>SI_Callback_ScanChannel</p>
<p>设置回调，后面会用到：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/api/SI_Api.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">SI_Callback_ScanChannel</span><span class="params">(SI *si, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_DATABASE_TS_NODE *ts = (SI_DATABASE_TS_NODE*)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//kjw note: SI_STATE_AUTOSCAN has thread issue. Beware it if someone modify the code in the future!</span></span><br><span class="line">    <span class="keyword">if</span>( SI_HAS_STATE(si-&gt;state, SI_STATE_AUTOSCAN)  ) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">//to update scanned ch count for AP</span></span><br><span class="line">        <span class="keyword">if</span>( ts != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">if</span>(!(SI_HAS_STATE(si-&gt;state, SI_STATE_UPDATE)&amp;&amp;ts-&gt;strength==(MANUAL_SCAN_STRENGTH-STRENGTH_DIFF_THRESHOLD)))<span class="comment">//keep manual scan service in high priority for update scan</span></span><br><span class="line">            {</span><br><span class="line">                ts-&gt;strength=si-&gt;strength;</span><br><span class="line">                ts-&gt;snr=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)(si-&gt;snr*<span class="number">100</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\033[1;31m %s=&gt;freq: %d, strength:%d ,snr:%d \033 [m\n"</span>,__FUNCTION__,ts-&gt;frequency,ts-&gt;strength,ts-&gt;snr);</span><br><span class="line">            SI_Channel_UpdateChList_Append(si-&gt;chMgr, si-&gt;db, ts,<span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_NEW_DVB</span></span><br><span class="line">            <span class="keyword">if</span>(IS_SUPPORT_TRD(si))</span><br><span class="line">            {</span><br><span class="line">                si_BuildTRD(si,ts);</span><br><span class="line">            }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {   <span class="comment">//manual scan(tuner or file playback scan)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ts != <span class="literal">NULL</span>) {</span><br><span class="line">            si_channel_updatePartialChList(si-&gt;chMgr, si-&gt;db, ts-&gt;frequency,FALSE,FALSE,FALSE,SI_TID_ALL);</span><br><span class="line">            ts-&gt;snr=ts-&gt;strength=MANUAL_SCAN_STRENGTH-STRENGTH_DIFF_THRESHOLD;<span class="comment">//best mux, manual scan is high priority</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {   <span class="comment">//no PAT or PMT</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//if(SI_IS_MONITOR_NETWORK_SDT(si))</span></span><br><span class="line">    <span class="keyword">if</span>(ts!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(SI_IS_ADD_CH_IN_NO_SDT(si))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> Tv=<span class="number">1</span>,Radio=<span class="number">1</span>,Data=<span class="number">1</span>;</span><br><span class="line">            SI_CHANNEL_EXT *_ch;</span><br><span class="line">            _ch = si-&gt;chMgr-&gt;chList;</span><br><span class="line">            <span class="keyword">while</span>(_ch)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(_ch-&gt;oriChannelNameLen == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>( get_ServiceType(si,_ch-&gt;serviceType)==SI_DVB_SERVICE_DTV)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="built_in">snprintf</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName,SI_CH_CHANNELNAME_MAXLEN<span class="number">-1</span>,<span class="string">"TV %d"</span>,Tv);</span><br><span class="line">                        _ch-&gt;super.channelNameLen=<span class="built_in">strlen</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName);</span><br><span class="line">                        Tv++;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( get_ServiceType(si,_ch-&gt;serviceType)==SI_DVB_SERVICE_RADIO)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="built_in">snprintf</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName,SI_CH_CHANNELNAME_MAXLEN<span class="number">-1</span>,<span class="string">"Radio %d"</span>,Radio);</span><br><span class="line">                        _ch-&gt;super.channelNameLen=<span class="built_in">strlen</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName);</span><br><span class="line">                        Radio++;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( get_ServiceType(si,_ch-&gt;serviceType)==SI_DVB_SERVICE_DATA)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="built_in">snprintf</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName,SI_CH_CHANNELNAME_MAXLEN<span class="number">-1</span>,<span class="string">"Data %d"</span>,Data);</span><br><span class="line">                        _ch-&gt;super.channelNameLen=<span class="built_in">strlen</span>((<span class="keyword">char</span>*)_ch-&gt;super.channelName);</span><br><span class="line">                        Data++;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                _ch = _ch-&gt;next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//省略代码动态</span></span><br><span class="line"></span><br><span class="line">    SiMessage_Store(&amp;si-&gt;mq, SI_MESSAGE_CH_INFO_READY,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0<span class="comment">//def FIX_DTV_LABS_HK_ISSUE_48</span></span></span><br><span class="line">                    pDupLcnList</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    arg == <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                   );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>si_agent_threadfuntion</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/SI_Agent.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">si_agent_threadfuntion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_AGENT_LIST_NODE *agentNode;</span><br><span class="line">    SI_AGENT *agent=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//int checkSize=0,sleepCount=0, countDown = 0;</span></span><br><span class="line">    <span class="comment">//not more than 100ms.</span></span><br><span class="line">    <span class="comment">//stream may be 4MB/s.</span></span><br><span class="line">    <span class="comment">//checkSize=64*188;//almost=&gt;(4*1024*1024)*3/10/10/10;</span></span><br><span class="line">    pthread_setname_np(pthread_self(), __FUNCTION__);</span><br><span class="line">    <span class="keyword">while</span>(!__stopAgentThread)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//sleepCount=0;</span></span><br><span class="line">        pthread_mutex_lock(&amp;__agentListMutex);</span><br><span class="line">        agentNode = __agentList;</span><br><span class="line">        <span class="keyword">while</span>(agentNode)</span><br><span class="line">        {</span><br><span class="line">            agent = agentNode-&gt;agent;</span><br><span class="line">            agentNode = agentNode-&gt;next;</span><br><span class="line">            SI_Agent_CollectSection(agent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Split SI_SLEEP(30) to 3 times to avoid overflowing while huge data comes</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            countDown = 3 ;</span></span><br><span class="line"><span class="comment">            while(countDown--)</span></span><br><span class="line"><span class="comment">            {</span></span><br><span class="line"><span class="comment">                if (agent &amp;&amp; !__stopAgentThread &amp;&amp; sleepCount&lt;3 &amp;&amp;</span></span><br><span class="line"><span class="comment">                        SI_PVRTP_GetRingBufferLength((unsigned int)agent-&gt;tp)&lt;checkSize) {</span></span><br><span class="line"><span class="comment">                    SI_SLEEP(10);</span></span><br><span class="line"><span class="comment">                    sleepCount++;</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;__agentListMutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sleep to context switch while SI_Agent_New blocked on mutex</span></span><br><span class="line">        <span class="comment">//if (sleepCount)</span></span><br><span class="line">        {</span><br><span class="line">            SI_SLEEP(<span class="number">10</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要看SI_Agent_CollectSection这个：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/SI_Agent.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">SI_Agent_CollectSection</span><span class="params">(SI_AGENT *agent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    BOOL stopped;</span><br><span class="line">    <span class="keyword">if</span> (agent==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;agent-&gt;mutexCollect);</span><br><span class="line">    <span class="keyword">if</span>(agent-&gt;waitingForReset == TRUE)</span><br><span class="line">    {</span><br><span class="line">        SI_Collector_Reset(agent-&gt;collector,TRUE,TRUE);</span><br><span class="line">        agent-&gt;waitingForReset=FALSE;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span>(agent-&gt;status == SI_AGENT_STATUS_TO_STOP)</span><br><span class="line">        {</span><br><span class="line">            stopped = FALSE;</span><br><span class="line">            <span class="keyword">while</span>(!stopped)</span><br><span class="line">            {</span><br><span class="line">                SiAgtIF_Run(agent-&gt;agentObjHandle);<span class="comment">//close all filter</span></span><br><span class="line">                SiAgtIF_CheckAllSmIdle(agent-&gt;agentObjHandle, &amp;stopped);</span><br><span class="line">            }</span><br><span class="line">            agent-&gt;status = SI_AGENT_STATUS_STOPPED;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(agent-&gt;status == SI_AGENT_STATUS_RUNNING)</span><br><span class="line">        {</span><br><span class="line">            SiAgtIF_Run(agent-&gt;agentObjHandle);</span><br><span class="line">            SI_Collector_CollectSection(agent-&gt;collector, agent-&gt;db, agent-&gt;tp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pthread_mutex_unlock(&amp;agent-&gt;mutexCollect);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>刚才SI_Agent_New的时候，已经把SI_AGENT_STATUS状态设定为SI_AGENT_STATUS_STOPPED，所以现在si_agent_threadfuntion这个线程里，基本是卡住了的。</p>
</li>
</ul>
<p>至此，CH_SCAN_STATE_INIT阶段结束了，紧跟着的CH_SCAN_STATE_BEGIN_FREQ阶段没有si相关的内容，可以跳过，接着来到CH_SCAN_STATE_SCANNING阶段。</p>
<h4 id="RunStateProc-FREQ-SCAN-STATE-CHECK-FRONTEND"><a href="#RunStateProc-FREQ-SCAN-STATE-CHECK-FRONTEND" class="headerlink" title="RunStateProc FREQ_SCAN_STATE_CHECK_FRONTEND"></a>RunStateProc FREQ_SCAN_STATE_CHECK_FRONTEND</h4><p>函数xStageCheckFrontend如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckFrontend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanStart</span>(m_curFreq, m_modulation, m_curBandwidth, symbolrate,  m_curPhyChNum, tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>(), m_serviceID);</span><br><span class="line">    </span><br><span class="line">    m_scanState = FREQ_SCAN_STATE_CHECK_SI;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Si/DvbSiMgr.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDvbSiMgr::ScanStart</span><span class="params">(UINT32 frequency, RT_MODULATION modulation, UINT32 bandwidth, UINT32 symbolrate, UINT32 phyChNum,UINT32 strength,<span class="keyword">float</span> snr, UINT16 serviceID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI* siHandle = (SI*)m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>()-&gt;<span class="built_in">GetSiHandle</span>();</span><br><span class="line">    SI_DVB_MODULATION siModulation;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(modulation)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM16:</span><br><span class="line">        siModulation=SI_DVB_16_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM32:</span><br><span class="line">        siModulation=SI_DVB_32_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM64:</span><br><span class="line">        siModulation=SI_DVB_64_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM128:</span><br><span class="line">        siModulation=SI_DVB_128_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> RT_MOD_QAM256:</span><br><span class="line">        siModulation=SI_DVB_256_QAM;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SI_SetState</span>(siHandle, SI_STATE_SCAN);</span><br><span class="line">    <span class="built_in">SI_ScanChannelEx</span>(siHandle, frequency, <span class="number">0</span>, bandwidth,siModulation,symbolrate, strength,snr,serviceID,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)phyChNum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/api/SI_Api.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_ScanChannelEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI									*pSI,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						frequency,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span>									offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						bandwidth,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span>						modulation,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 						symbolrate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						strength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">float</span>							snr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">short</span> serviceID,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span> phyChNum</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//force agent to start.</span></span><br><span class="line">    <span class="built_in">SI_Start</span>(pSI);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call si agent</span></span><br><span class="line">    <span class="built_in">SI_Agent_ScanChannel</span>(pSI-&gt;agent, frequency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug...</span></span><br><span class="line">    <span class="built_in">SI_DB_PRINT_ALL_TSNODE</span>(pSI-&gt;db);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SI_API_RETURN</span>(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中，SI_Start方法会把SI_AGENT_STATUS状态更新为SI_AGENT_STATUS_RUNNING，SI_Agent_ScanChannel方法则设置FilterTaskPool：</p>
<ul>
<li><p>SI_Start（pSI）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/api/SI_Api.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Start</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI									*pSI</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_API_BEGIN();</span><br><span class="line">    SI_ASSERT(pSI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start si agent thread</span></span><br><span class="line">    SI_Agent_Start(pSI-&gt;agent);</span><br><span class="line"></span><br><span class="line">    SI_API_RETURN(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/SI_Agent.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Agent_Start</span><span class="params">(SI_AGENT *pAgent)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_AGENT_BEGIN();</span><br><span class="line">    SI_ASSERT(pAgent);</span><br><span class="line"></span><br><span class="line">    SIAG_IF_LOCK(pAgent);</span><br><span class="line"></span><br><span class="line">    pAgent-&gt;status = SI_AGENT_STATUS_RUNNING;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SI_DEBUG_AGENT_LIFE</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">pthread_t</span>  self;</span><br><span class="line">        self = pthread_self();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"siA call st from %p addr:%p\n"</span>, (<span class="keyword">void</span>*)self, pAgent);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_SI_DEBUG_AGENT_LIFE</span></span></span><br><span class="line"></span><br><span class="line">    SIAG_IF_UNLOCK(pAgent);</span><br><span class="line"></span><br><span class="line">    SI_AGENT_RETURN(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>SI_Agent_ScanChannel(pSI-&gt;agent, frequency)</p>
<p>这里也设置了一遍SI_AGENT_STATUS_RUNNING</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/SI_Agent.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Agent_ScanChannel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_AGENT							*pAgent,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						frequency</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(frequency == SI_API_SCANFILE_FREQUENCY)</span><br><span class="line">    {</span><br><span class="line">        SiAgtIF_ScanProgram((SIAGENT_OBJECT_P)pAgent-&gt;agentObjHandle, ts);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        SiAgtIF_ScanChannel((SIAGENT_OBJECT_P)pAgent-&gt;agentObjHandle, ts);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pAgent-&gt;status = SI_AGENT_STATUS_RUNNING;</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentInterface.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SiAgtIF_ScanChannel</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, TABLE_TREE_TS_LAYER_P tsNode )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MAIN_TASK_P pMainTask ;</span><br><span class="line">    pMainTask = SiAgent_SM_GenMainTask_ScanCh(tsNode);</span><br><span class="line">    INSERT_MAIN_TASK_INTO_QUEUE( pSiAgentObj, pMainTask ) ;</span><br><span class="line">    <span class="keyword">return</span> TRUE ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上可以看到，通过SiAgent_SM_GenMainTask_ScanCh设置pMainTask，然后将其放入Queue中，SIAGENT_THREAD_SLEEP这个1毫秒不知道是干嘛的：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">#define SIAGENT_THREAD_SLEEP_TIME <span class="number">1</span></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">SIAGENT_THREAD_SLEEP(<span class="params">ms</span>)</span> {\</span><br><span class="line">         <span class="keyword">struct</span> timespec delay ;\</span><br><span class="line">         delay.tv_sec = ms<span class="operator"> / </span><span class="number">1000</span> ;\</span><br><span class="line">         delay.tv_nsec = ((ms % <span class="number">1000</span>)*<span class="number">1000000</span>) ;\</span><br><span class="line">         nanosleep(&amp;delay,NULL) ;\</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">#define  <span class="constructor">INSERT_MAIN_TASK_INTO_QUEUE(<span class="params">pAgent</span>, <span class="params">pMainTask</span>)</span> {\</span><br><span class="line">          pthread<span class="constructor">_mutex_lock(&amp;<span class="params">siAgentTaskMutex</span>)</span>;\</span><br><span class="line">          pAgent-&gt;<span class="constructor">InsertMainTaskIntoQueue(<span class="params">pAgent</span>, <span class="params">pMainTask</span>)</span>;\</span><br><span class="line">          pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">siAgentTaskMutex</span>)</span>;\</span><br><span class="line">          <span class="constructor">SIAGENT_THREAD_SLEEP(SIAGENT_THREAD_SLEEP_TIME)</span>;\</span><br><span class="line">         }</span><br></pre></td></tr></tbody></table></figure>

<p>看看是怎么设置pMainTask：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentStateMachine.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">MAIN_TASK_P <span class="title">SiAgent_SM_GenMainTask_ScanCh</span><span class="params">( TABLE_TREE_TS_LAYER_P tsAddr )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MAIN_TASK_P pMainTask ;</span><br><span class="line"></span><br><span class="line">    pMainTask = (MAIN_TASK_P) SM_MALLOC( <span class="keyword">sizeof</span>(MAIN_TASK_T) ) ;</span><br><span class="line">    <span class="keyword">if</span>(pMainTask!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(pMainTask,<span class="number">0</span>,<span class="keyword">sizeof</span>(MAIN_TASK_T) ) ;</span><br><span class="line">        pMainTask-&gt;stateNumber = START_EXEC_TASK ;</span><br><span class="line">        pMainTask-&gt;lastStateNumber = NO_PREVIOUS_STATE ;</span><br><span class="line">        pMainTask-&gt;StateMachineFunction = SiAgent_SM_Main_ScanCh ;</span><br><span class="line">        pMainTask-&gt;pFilterTaskPool = <span class="literal">NULL</span> ;</span><br><span class="line">        pMainTask-&gt;argScanCh.tsAddr = tsAddr ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pMainTask ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>主要是要设置StateMachineFunction这个，看看它指向的SiAgent_SM_Main_ScanCh，同时请注意，此刻pFilterTaskPool是设置为空的：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentStateMachine.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiAgent_SM_Main_ScanCh</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, MAIN_TASK_P pMainTask)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> noWaitCount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> execCount = <span class="number">1</span> ;</span><br><span class="line">    PROGRAMS_INFO_P pProgramsInfo ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pmtCount,neeToWaitCAT=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(  ; execCount &gt; <span class="number">0</span> ; execCount -- )</span><br><span class="line">    {</span><br><span class="line">        MAIN_SM_STATE_MSG( pSiAgentObj, pMainTask, <span class="string">"MainTask-ScanCH"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(pMainTask-&gt;stateNumber)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> SM_MAIN_SCANCH_ST_START:</span><br><span class="line">            <span class="comment">//Reset Bean Packer</span></span><br><span class="line">            SiAgtFW_ResetBeanPacker( pSiAgentObj, TRUE);</span><br><span class="line">            pMainTask-&gt;pFilterTaskPool = SiAgent_GenScanChGetPatFtp( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr );</span><br><span class="line">            pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_WAIT_GET_PAT ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> SM_MAIN_SCANCH_ST_END:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool != <span class="literal">NULL</span> )</span><br><span class="line">            {</span><br><span class="line">                SiAgent_StopAllFilterTasks( pSiAgentObj, pMainTask-&gt;pFilterTaskPool );</span><br><span class="line">                SM_FREE( pMainTask-&gt;pFilterTaskPool );</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> SM_MAIN_SCANCH_ST_WAIT_GET_PAT:</span><br><span class="line">            NULL_CHECK(pMainTask-&gt;pFilterTaskPool,pMainTask-&gt;stateNumber);</span><br><span class="line">            NULL_CHECK(pMainTask-&gt;pFilterTaskPool-&gt;filterTask,pMainTask-&gt;stateNumber);</span><br><span class="line">            <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber == pMainTask-&gt;pFilterTaskPool-&gt;doneFilterTaskNumber ||</span><br><span class="line">                    pMainTask-&gt;pFilterTaskPool-&gt;filterTask[<span class="number">0</span>].filterTaskState == FILTER_TASK_STATE_DONE)</span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[<span class="number">0</span>].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_TIMEOUT )&amp;&amp;</span><br><span class="line">                    (!SI_IS_SCAN_CH_SKIP_PAT_INVALID(pSiAgentObj-&gt;si)))</span><br><span class="line">                {   <span class="comment">//No PAT</span></span><br><span class="line">                    SM_FREE( pMainTask-&gt;pFilterTaskPool );</span><br><span class="line">                    pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_END ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG_SIAGENT_SM_</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No PAT\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_DEBUG_SIAGENT_SM_</span></span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Msg to AP : No VC in TS (No PAT) !!!!!!!!!!!!!</span></span><br><span class="line">                    <span class="keyword">if</span>(pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL] != <span class="literal">NULL</span>)</span><br><span class="line">                    {</span><br><span class="line">                        pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si,  <span class="literal">NULL</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    BOOL bOpenPMT=TRUE;</span><br><span class="line">                    <span class="comment">//Got PAT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">                    <span class="keyword">if</span>(pSiAgentObj-&gt;si-&gt;eScanBase == SI_SCAN_SDT_BASE &amp;&amp; pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber&gt;<span class="number">1</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(pMainTask-&gt;pFilterTaskPool-&gt;filterTask[<span class="number">1</span>].filterTaskState != FILTER_TASK_STATE_DONE)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG_SIAGENT_SM_</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Got PAT\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_DEBUG_SIAGENT_SM_</span></span></span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber; i++) {</span><br><span class="line">                        <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_TIMEOUT) {</span><br><span class="line">                            <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].chkTableReceiveFunction == CHK_TABLE_RECEIVE_FUNC_A_NIT) {</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"No NIT.\n"</span>);</span><br><span class="line">                            } <span class="keyword">else</span> <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].chkTableReceiveFunction == CHK_TABLE_RECEIVE_FUNC_A_SDT) {</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"No SDT.\n"</span>);</span><br><span class="line">                            }</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].chkTableReceiveFunction == CHK_TABLE_RECEIVE_FUNC_A_NIT) {</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"Got NIT.\n"</span>);</span><br><span class="line">                            } <span class="keyword">else</span> <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].chkTableReceiveFunction == CHK_TABLE_RECEIVE_FUNC_A_SDT) {</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">"Got SDT.\n"</span>);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(<span class="comment">/*SI_IS_UNITYMEDIA(*/</span>pSiAgentObj-&gt;si-&gt;bSkipPMT<span class="comment">/*)*/</span>&amp;&amp;(SI_HAS_STATE(pSiAgentObj-&gt;si-&gt;state, SI_STATE_AUTOSCAN)</span><br><span class="line">                                            ||SI_HAS_STATE(pSiAgentObj-&gt;si-&gt;state, SI_STATE_NETWORKSCAN)))</span><br><span class="line">                    {</span><br><span class="line">                        bOpenPMT=FALSE;</span><br><span class="line">                    }</span><br><span class="line">                    SM_FREE( pMainTask-&gt;pFilterTaskPool );</span><br><span class="line">                    pProgramsInfo = SiAgtFW_GetProgramsInfo( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr );</span><br><span class="line">                    pMainTask-&gt;pFilterTaskPool = SiAgent_GenScanChGetTablesFtp( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr, pProgramsInfo , <span class="comment">/*pSiAgentObj-&gt;si-&gt;eScanBase == SI_SCAN_SDT_BASE ? FALSE :*/</span> TRUE,bOpenPMT);</span><br><span class="line">                    SiAgtFW_FreeProgramsInfo(pSiAgentObj, &amp;pProgramsInfo );</span><br><span class="line">                    pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_WAIT_GET_TABLES ;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> SM_MAIN_SCANCH_ST_WAIT_GET_TABLES:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ENABLE_NEW_DVB<span class="comment">//why need CAT in NO CA project</span></span></span><br><span class="line">            neeToWaitCAT=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            noWaitCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( SI_HAS_STATE(pSiAgentObj-&gt;si-&gt;state, SI_STATE_AUTOSCAN)  &amp;&amp; (<span class="comment">/*SI_IS_SATELLITE(pSiAgentObj-&gt;si)||*/</span>SI_IS_CABLE(pSiAgentObj-&gt;si)) &amp;&amp; SiAgtFW_CheckPatExist( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr ) == TRUE</span><br><span class="line">                    &amp;&amp; SiAgtFW_CheckActualSdtReceive( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr ,TRUE)==TRUE</span><br><span class="line">                    &amp;&amp; SiAgtFW_CheckActualNitReceive( pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr,<span class="literal">NULL</span>) == FALSE</span><br><span class="line">                    &amp;&amp; SiAgtFW_DuplicateNit(pSiAgentObj,pMainTask-&gt;argScanCh.tsAddr )==TRUE)</span><br><span class="line">            {</span><br><span class="line">                noWaitCount++;</span><br><span class="line">            }</span><br><span class="line">            NULL_CHECK(pMainTask-&gt;pFilterTaskPool,pMainTask-&gt;stateNumber);</span><br><span class="line">            NULL_CHECK(pMainTask-&gt;pFilterTaskPool-&gt;filterTask,pMainTask-&gt;stateNumber);</span><br><span class="line">            <span class="keyword">if</span> ((pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber<span class="number">-1</span>)==pMainTask-&gt;pFilterTaskPool-&gt;doneFilterTaskNumber) {</span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber; i++) {</span><br><span class="line">                    <span class="keyword">if</span>(i==SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_CAT)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.closedReason==FILTER_TASK_CLOSED_REASON_RECEIVED) {</span><br><span class="line">                        count++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ENABLE_NIKE_CUNCUNTONG</span></span><br><span class="line">                <span class="keyword">if</span>(SI_IS_KABEL_DEUTSCHLAND(pSiAgentObj-&gt;si))</span><br><span class="line">                {</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (SI_ENABLE_BAT_6100(pSiAgentObj-&gt;si)==FALSE &amp;&amp;</span><br><span class="line">                         pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_BAT_6100].typeTimeoutClosed.closedReason==FILTER_TASK_CLOSED_REASON_TIMEOUT) {</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ENABLE_NEW_DVB<span class="comment">//why need CAT in NO CA project</span></span></span><br><span class="line">                <span class="keyword">if</span> ((count+<span class="number">1</span>)==pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber) {</span><br><span class="line">                    neeToWaitCAT=SiAgtFW_NeedToQueryCAT(pSiAgentObj, pMainTask-&gt;argScanCh.tsAddr);</span><br><span class="line">                }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( ((pMainTask-&gt;pFilterTaskPool-&gt;doneFilterTaskNumber+noWaitCount) &gt;= pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber ) ||</span><br><span class="line">                    ((pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber<span class="number">-1</span>)==pMainTask-&gt;pFilterTaskPool-&gt;doneFilterTaskNumber &amp;&amp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_NEW_DVB<span class="comment">//why need CAT in NO CA project</span></span></span><br><span class="line">                     pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_CAT].filterTaskState==FILTER_TASK_STATE_DOING</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                     neeToWaitCAT==<span class="number">0</span> &amp;&amp;</span><br><span class="line">                     pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_CAT].typeTimeoutClosed.closedReason!=FILTER_TASK_CLOSED_REASON_RECEIVED</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    ) )</span><br><span class="line">            {</span><br><span class="line">                pmtCount = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//if( pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber &gt; SI_AGENT_FILTER_GET_SCAN_CH_TABLE_PREFIX )//for empty PAT</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>( i =<span class="number">0</span>; i &lt; pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber ; i ++ )</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].chkTableReceiveFunction == CHK_TABLE_RECEIVE_FUNC_PMT</span><br><span class="line">                                &amp;&amp; pMainTask-&gt;pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED )</span><br><span class="line">                        {</span><br><span class="line">                            pmtCount ++ ;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( pmtCount &gt; <span class="number">0</span> || pSiAgentObj-&gt;si-&gt;eScanBase == SI_SCAN_SDT_BASE || pSiAgentObj-&gt;si-&gt;eScanBase == SI_SCAN_NIT_BASE)</span><br><span class="line">                {   <span class="comment">//Got PMT</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Got PMT[%d],fail:%d.\n"</span>,pmtCount,(pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber-SI_AGENT_FILTER_GET_SCAN_CH_TABLE_PREFIX-pmtCount));</span><br><span class="line">                    <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_NIT].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED ) {</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Got NIT.\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GET_SCAN_PARAM_FROM_NIT</span></span><br><span class="line">                        pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_GET_NIT](pSiAgentObj-&gt;si, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_SDT].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED ) {</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Got SDT.\n"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_CAT].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED ) {</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Got CAT.\n"</span>);</span><br><span class="line">                    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_NIKE_CUNCUNTONG</span></span><br><span class="line">                    <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_BAT_6000].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Got BAT_0x6000.\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    <span class="keyword">if</span> (SI_ENABLE_BAT_6100(pSiAgentObj-&gt;si)) {</span><br><span class="line">                        <span class="keyword">if</span>( pMainTask-&gt;pFilterTaskPool-&gt;filterTask[SI_AGENT_FILTER_GET_SCAN_CH_TABLE_INDEX_BAT_6100].typeTimeoutClosed.closedReason == FILTER_TASK_CLOSED_REASON_RECEIVED ) {</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"Got BAT[0x6100].\n"</span>);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">"Fail BAT[0x6100].\n"</span>);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    SM_FREE( pMainTask-&gt;pFilterTaskPool );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">                    <span class="keyword">if</span>(SI_IS_HD_PLUS<span class="comment">/*SI_IS_SATELLITE*/</span>(pSiAgentObj-&gt;si) &amp;&amp; !SiAgtFW_IsSgtExist(pSiAgentObj))</span><br><span class="line">                    {</span><br><span class="line">                        pMainTask-&gt;pFilterTaskPool=SiAgent_GenScanSgtFtp(pSiAgentObj,pMainTask-&gt;argScanCh.tsAddr);</span><br><span class="line">                        <span class="keyword">if</span>(pMainTask-&gt;pFilterTaskPool!=<span class="literal">NULL</span>)</span><br><span class="line">                        {</span><br><span class="line">                            pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_WAIT_SGT_TABLES;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_END ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Msg to AP : Some VCs in TS !!!!!!!!!!!!!</span></span><br><span class="line">                    <span class="keyword">if</span>(pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL] != <span class="literal">NULL</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si, (void*)1);</span></span><br><span class="line">                        pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si, pMainTask-&gt;argScanCh.tsAddr);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {   <span class="comment">//No PMT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG_SIAGENT_SM_</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No PMT\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//_DEBUG_SIAGENT_SM_</span></span></span><br><span class="line"></span><br><span class="line">                    SM_FREE( pMainTask-&gt;pFilterTaskPool );</span><br><span class="line">                    pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_END ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//Msg to AP : No VC in TS (No PMT) !!!!!!!!!!!!!</span></span><br><span class="line">                    <span class="keyword">if</span>(pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL] != <span class="literal">NULL</span>)</span><br><span class="line">                    {</span><br><span class="line">                        pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si, <span class="literal">NULL</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">case</span> SM_MAIN_SCANCH_ST_WAIT_SGT_TABLES:</span><br><span class="line">            NULL_CHECK(pMainTask-&gt;pFilterTaskPool,pMainTask-&gt;stateNumber);</span><br><span class="line">            <span class="keyword">if</span> (pMainTask-&gt;pFilterTaskPool-&gt;totalFilterTaskNumber==pMainTask-&gt;pFilterTaskPool-&gt;doneFilterTaskNumber)</span><br><span class="line">            {</span><br><span class="line">                pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_END ;</span><br><span class="line">                <span class="keyword">if</span>(pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL] != <span class="literal">NULL</span>)</span><br><span class="line">                {</span><br><span class="line">                    pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si, pMainTask-&gt;argScanCh.tsAddr);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SM_DBG_MSG(DBG_MSG_LEVEL_ERROR, <span class="string">"[SiAgent-%s]:'Main Task - Scan Channel' has unknown state(%d)."</span>,pSiAgentObj-&gt;agentObjectName, pMainTask-&gt;stateNumber);</span><br><span class="line">            pMainTask-&gt;stateNumber = SM_MAIN_SCANCH_ST_END ;</span><br><span class="line">            execCount ++ ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    MAIN_TASK_ENDING_MSG( pSiAgentObj, pMainTask, <span class="string">"MainTask-ScanCH"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，当拿到<code>PMT</code>时，调用</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_SCAN_CHANNEL](pSiAgentObj-&gt;si, pMainTask-&gt;argScanCh.tsAddr);</span><br></pre></td></tr></tbody></table></figure>

<p>也就是前面注册的回调函数SI_Callback_ScanChannel。</p>
</li>
</ul>
<p>至此，ScanStart()跑完，然后RunStateProc状态机状态被更新为FREQ_SCAN_STATE_CHECK_SI。</p>
<h4 id="RunStateProc-FREQ-SCAN-STATE-CHECK-SI"><a href="#RunStateProc-FREQ-SCAN-STATE-CHECK-SI" class="headerlink" title="RunStateProc FREQ_SCAN_STATE_CHECK_SI"></a>RunStateProc FREQ_SCAN_STATE_CHECK_SI</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Channel/Scan/DtvFreqDetector.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDtvFreqDetector::xStageCheckSi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	DTV_STACK::TunerMgr* tuner = DTV_STACK::TunerMgr::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">RETRY:</span><br><span class="line">	<span class="keyword">if</span> (m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">ScanIsDone</span>(&amp;m_bIsGetService) == <span class="literal">false</span>)</span><br><span class="line">	{</span><br><span class="line">		m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetSignalInfo</span>(tuner-&gt;<span class="built_in">getRFStrength</span>(), tuner-&gt;<span class="built_in">getSignalSNR</span>());</span><br><span class="line">		<span class="built_in">usleep</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">		<span class="keyword">if</span>(m_curLoHz != <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(!m_bCancelScan)</span><br><span class="line">				<span class="keyword">goto</span> RETRY;</span><br><span class="line">		}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Terrestrial case :</span></span><br><span class="line">	<span class="comment">// We should check if we need to check current frequency again with different parameters</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">HasHandleCurFreqAgainInDvbT</span>())</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill modulation to each channel to prevent error when playing channel</span></span><br><span class="line">	m_pIDtvMedia-&gt;<span class="built_in">GetSiMgr</span>()-&gt;<span class="built_in">SetModulation</span>(m_curFreq, m_modulation);</span><br><span class="line">	m_scanState = FREQ_SCAN_STATE_END_FREQ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SUPPORT_DVB_S</span></span><br><span class="line">	<span class="keyword">if</span>(m_curLoHz != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">UpdateChInfo</span>();</span><br><span class="line">		<span class="built_in">SendEvent</span>(RT_SCAN_EVENT_FREQ_DONE, m_curFreq);</span><br><span class="line">		m_scanState = FREQ_SCAN_STATE_BLIND_SCAN_TP;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关注这个ScanIsDone：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* MediaControl/Component/Si/DvbSiMgr.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CDvbSiMgr::ScanIsDone</span><span class="params">(<span class="keyword">bool</span> *bGetCh)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_MESSAGE message;</span><br><span class="line">    UINT32 data = <span class="number">0</span>;</span><br><span class="line">    DriverBasedDtvApp *pDvbApp = m_pTvMedia-&gt;<span class="built_in">GetDtvFlow</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDvbApp-&gt;<span class="built_in">GetSiMessage</span>(&amp;message, &amp;data) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == SI_MESSAGE_RESET_CHANNEL &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xResetChannel</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(message == SI_MESSAGE_CHANNEL_UPDATE &amp;&amp; data&gt;<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">xUpdateChannelMgr</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_CH_INFO_READY)</span><br><span class="line">    {</span><br><span class="line">    	<span class="built_in">ALOGD</span>(<span class="string">"[%s %d] SI_MESSAGE_CH_INFO_READY\n"</span>,__func__,__LINE__);</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = data == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == SI_MESSAGE_SSU_SW_NOT_FOUND||message == SI_MESSAGE_SSU_SWINFO_READY)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(bGetCh!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            *bGetCh = message == SI_MESSAGE_SSU_SWINFO_READY ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">/* if (message != SI_MESSAGE_CH_INFO_READY)*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>收到这个SI_MESSAGE_CH_INFO_READY消息，就认为Check SI完成，这个消息就是回调函数SI_Callback_ScanChannel发出来的。然后接着跑RunStateProc的剩余流程。</p>
<h3 id="SI-AGENT-STATUS-RUNNING"><a href="#SI-AGENT-STATUS-RUNNING" class="headerlink" title="SI_AGENT_STATUS_RUNNING"></a>SI_AGENT_STATUS_RUNNING</h3><p>上面讲到，SiAgent_SM_Main_ScanCh的时候，如果拿到<code>PMT</code>，就认为扫到台，接着会跑SI_Callback_ScanChannel这个回调函数，但是SiAgent_SM_Main_ScanCh什么时候才会被调用呢？SiAgent_SM_GenMainTask_ScanCh只是设置了pMainTask-&gt;StateMachineFunction，但是还没有执行，什么时候执行？</p>
<h4 id="RunStateProc-FREQ-SCAN-STATE-CHECK-FRONTEND-1"><a href="#RunStateProc-FREQ-SCAN-STATE-CHECK-FRONTEND-1" class="headerlink" title="RunStateProc FREQ_SCAN_STATE_CHECK_FRONTEND"></a>RunStateProc FREQ_SCAN_STATE_CHECK_FRONTEND</h4><p>别忘了，si_agent_threadfuntion这个线程里，SI_Agent_CollectSection函数还卡着呢，什么时候才跑进所需的流程？要看SI_AGENT_STATUS这个状态，根据前面的分析，在Check Frontend阶段，状态被更新为SI_AGENT_STATUS_RUNNING。</p>
<p>好戏开场了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(agent-&gt;status == SI_AGENT_STATUS_RUNNING)</span><br><span class="line">{</span><br><span class="line">    SiAgtIF_Run(agent-&gt;agentObjHandle);</span><br><span class="line">    SI_Collector_CollectSection(agent-&gt;collector, agent-&gt;db, agent-&gt;tp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先讲SiAgtIF_Run：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentInterface.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiAgtIF_Run</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    pSiAgentObj-&gt;Run( pSiAgentObj );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentObject.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiAgentObj_Run</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pSiAgentObj-&gt;ExecMainTaskSM( pSiAgentObj );</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SUB_TASK_QUEUE_NUMBER; i++) {</span><br><span class="line">        pSiAgentObj-&gt;ExecSubTaskSM( pSiAgentObj, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_MONITOR_TICK] != <span class="literal">NULL</span>) {</span><br><span class="line">        pSiAgentObj-&gt;siAgentCBFs[SI_AGENT_CBF_TYPE_MONITOR_TICK](pSiAgentObj-&gt;si,<span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的ExecMainTaskSM就是SiAgentObj_ExecMainTaskSM，由最开始CH_SCAN_STATE_INIT阶段初始化的，现在终于派上用场：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentObject.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiAgentObj_ExecMainTaskSM</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    BOOL result ;</span><br><span class="line">    MAIN_TASK_INFO_P pExecMainTaskInfo = &amp;(pSiAgentObj-&gt;execMainTaskInfo) ;</span><br><span class="line"></span><br><span class="line">    CHECK_MAIN_TASK_IN_QUEUE( pSiAgentObj, &amp;result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( result == TRUE )</span><br><span class="line">    {   <span class="comment">//New Task in Queue</span></span><br><span class="line">        <span class="keyword">if</span>( pExecMainTaskInfo-&gt;pExecMainTask != <span class="literal">NULL</span> )</span><br><span class="line">        {   <span class="comment">//Finish Current Task</span></span><br><span class="line">            pExecMainTaskInfo-&gt;pExecMainTask-&gt;stateNumber = STOP_EXEC_TASK ;</span><br><span class="line">            pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask )  ;</span><br><span class="line">            AGENTOBJ_FREE(pExecMainTaskInfo-&gt;pExecMainTask);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//Load New Task into State Machine</span></span><br><span class="line">        GET_MAIN_TASK_FROM_QUEUE( pSiAgentObj, &amp;(pExecMainTaskInfo-&gt;pExecMainTask));</span><br><span class="line"></span><br><span class="line">        pExecMainTaskInfo-&gt;pExecMainTask-&gt;lastTaskIsChgCh = pExecMainTaskInfo-&gt;lastTaskIsChgCh ;</span><br><span class="line">        pExecMainTaskInfo-&gt;pExecMainTask-&gt;lastTsAddr      = pExecMainTaskInfo-&gt;lastTsAddr ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction == SiAgent_SM_Main_ChangeCh) ||</span><br><span class="line">                (pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction == SiAgent_SM_Main_RecordPrg) )</span><br><span class="line">        {</span><br><span class="line">            pExecMainTaskInfo-&gt;lastTaskIsChgCh = TRUE ;</span><br><span class="line">            pExecMainTaskInfo-&gt;lastTsAddr  =  pExecMainTaskInfo-&gt;pExecMainTask-&gt;argChangeCh.tsAddr ;<span class="comment">//argChangeCh==argRecordPrg</span></span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction == SiAgent_SM_Main_ChgChSsuDecode)</span><br><span class="line">        {</span><br><span class="line">            pExecMainTaskInfo-&gt;lastTaskIsChgCh = TRUE ;</span><br><span class="line">            pExecMainTaskInfo-&gt;lastTsAddr  =  pExecMainTaskInfo-&gt;pExecMainTask-&gt;argChgChSsuDcr.tsAddr ;<span class="comment">//argChangeCh==argRecordPrg</span></span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction!=SiAgent_SM_Main_Stop)</span><br><span class="line">        {</span><br><span class="line">            pExecMainTaskInfo-&gt;lastTaskIsChgCh = FALSE ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pExecMainTaskInfo-&gt;pExecMainTask != <span class="literal">NULL</span> )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>( pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool != <span class="literal">NULL</span> )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//Update Filter Task State</span></span><br><span class="line">            SiAgent_UpdateFilterTaskState( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//EXEC TASK</span></span><br><span class="line">        pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask )   ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool != <span class="literal">NULL</span> )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//EXEC Filter Task</span></span><br><span class="line">            SiAgent_ExecuteFilterTask( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pExecMainTaskInfo-&gt;pExecMainTask-&gt;stateNumber == STOP_EXEC_TASK )</span><br><span class="line">        {</span><br><span class="line">            AGENTOBJ_FREE(pExecMainTaskInfo-&gt;pExecMainTask);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>前面流程，SI_AGENT_STATUS_RUNNING在Check Frontend阶段被设置了，这个时候，si_agent_threadfuntion线程可以进以下流程：</p>
<blockquote>
<p>si_agent_threadfuntion()</p>
<blockquote>
<p>SI_Agent_CollectSection(agent)</p>
<blockquote>
<p>SiAgtIF_Run(agent-&gt;agentObjHandle)</p>
<p>SiAgentObj_Run(SIAGENT_OBJECT_P pSiAgentObj)</p>
<blockquote>
<p>pSiAgentObj-&gt;ExecMainTaskSM(pSiAgentObj)</p>
<p>SiAgentObj_ExecMainTaskSM( SIAGENT_OBJECT_P pSiAgentObj )</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>前面把MainTask放入队列的时候，线程延迟1毫秒，让出CPU使用权，现在SiAgentObj_ExecMainTaskSM CHECK_MAIN_TASK_IN_QUEUE( pSiAgentObj, &amp;result)，也是同样的做法：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line">#define  <span class="constructor">CHECK_MAIN_TASK_IN_QUEUE(<span class="params">pAgent</span>, <span class="params">pResult</span>)</span> {\</span><br><span class="line">          pthread<span class="constructor">_mutex_lock(&amp;<span class="params">siAgentTaskMutex</span>)</span>;\</span><br><span class="line">          pAgent-&gt;<span class="constructor">CheckMainTaskInQueue(<span class="params">pAgent</span>, <span class="params">pResult</span>)</span>;\</span><br><span class="line">          pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">siAgentTaskMutex</span>)</span>;\</span><br><span class="line">          <span class="constructor">SIAGENT_THREAD_SLEEP(SIAGENT_THREAD_SLEEP_TIME)</span>;\</span><br><span class="line">         }</span><br></pre></td></tr></tbody></table></figure>

<p>所以，这个有什么用？不知道。反正SiAgentObj_ExecMainTaskSM里面的执行时机搞不懂。<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>然后再讲SI_Collector_CollectSection：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/collector/SI_Collector.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Collector_CollectSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_COLLECTOR *pCollector,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_DATABASE	*pDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>		*tp</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pCollector-&gt;beanQueueNum; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//省略代码段</span></span><br><span class="line">        <span class="comment">// get bean queue and beanQLen from tp or something</span></span><br><span class="line">        SI_TPInterface_GetBeanQueue(tp, i, &amp;beanQueueLen, &amp;beanQueue);</span><br><span class="line">        <span class="keyword">if</span>(!beanQueueLen)</span><br><span class="line">        {   <span class="comment">//beanQueueLen = 0</span></span><br><span class="line">            <span class="keyword">if</span>(beanQueue)</span><br><span class="line">            {</span><br><span class="line">                SI_TPInterface_DropBeanQueue(tp, beanQueue);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        beanQueueToParseLen = beanQueueLen + pCollector-&gt;beanCtrlInfo[i].surplusLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//kjw: todo</span></span><br><span class="line">        <span class="comment">//if beanQueueToParseLen == beanQueueLen, we don't need to dup beanQueueToParse again...</span></span><br><span class="line"></span><br><span class="line">        beanQueueToParse = SI_COLLECTOR_MALLOC(beanQueueToParseLen);</span><br><span class="line">        <span class="keyword">if</span> (beanQueueToParse==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pCollector-&gt;beanCtrlInfo[i].allocatedAddr)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">memcpy</span>(beanQueueToParse, pCollector-&gt;beanCtrlInfo[i].surplusAddr, pCollector-&gt;beanCtrlInfo[i].surplusLength);</span><br><span class="line">            SI_COLLECTOR_FREE(pCollector-&gt;beanCtrlInfo[i].allocatedAddr);</span><br><span class="line">            pCollector-&gt;beanCtrlInfo[i].allocatedAddr = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">memcpy</span>(beanQueueToParse+pCollector-&gt;beanCtrlInfo[i].surplusLength, beanQueue, beanQueueLen);</span><br><span class="line"></span><br><span class="line">        SI_TPInterface_DropBeanQueue(tp, beanQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        surplusLen = beanQueueToParseLen;</span><br><span class="line">        pthread_mutex_lock(&amp;pCollector-&gt;mutexSectionFilter);<span class="comment">//#ifdef ENABLE_MHEG5, fix not thread safe</span></span><br><span class="line">        si_collector_insert_to_database(pCollector, pDatabase, &amp;surplusLen, beanQueueToParse);</span><br><span class="line">        pthread_mutex_unlock(&amp;pCollector-&gt;mutexSectionFilter);<span class="comment">//#ifdef ENABLE_MHEG5, fix not thread safe</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略代码段</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SI_COLLECTOR_RETURN(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里应该是从SI_TPInterface_GetBeanQueue拿ts packet，加打印信息，continue关键字会一直拦截后面的语句，所以这里的作用单纯是拿ts packet？</p>
<h4 id="RunStateProc-FREQ-SCAN-STATE-CHECK-SI-1"><a href="#RunStateProc-FREQ-SCAN-STATE-CHECK-SI-1" class="headerlink" title="RunStateProc FREQ_SCAN_STATE_CHECK_SI"></a>RunStateProc FREQ_SCAN_STATE_CHECK_SI</h4><p>再绕回来讲SiAgentObj_ExecMainTaskSM执行时机，其实没得讲，因为不知道。总之，Check SI的时候，SiAgentObj_ExecMainTaskSM会跑进以下3个流程：</p>
<blockquote>
<p>SiAgent_UpdateFilterTaskState( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool );</p>
<p>pExecMainTaskInfo-&gt;pExecMainTask-&gt;StateMachineFunction( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask )   ;</p>
<p>SiAgent_ExecuteFilterTask( pSiAgentObj, pExecMainTaskInfo-&gt;pExecMainTask-&gt;pFilterTaskPool );</p>
</blockquote>
<p>SiAgent_UpdateFilterTaskState这个是更新Filter状态的，比如说Receive到某个Table之后就把closedReason更新为FILTER_TASK_CLOSED_REASON_RECEIVED，并关掉对应的Filter；</p>
<p>StateMachineFunction这个，也就是对应扫台的SiAgent_SM_Main_ScanCh，用来设置Filter的，也通过Filter的closedReason判断是否拿到<code>PMT，</code>如果是FILTER_TASK_CLOSED_REASON_RECEIVED，则拿到；</p>
<p>SiAgent_ExecuteFilterTask是用来实际执行Filter的：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentFilterTaskExecutor.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SiAgent_ExecuteFilterTask</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, FILTER_TASK_POOL_P pFilterTaskPool )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> totalFilterTaskNumber ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i ;</span><br><span class="line">    <span class="keyword">time_t</span> targetCurrentTime ;</span><br><span class="line">    BOOL bCreate;</span><br><span class="line"></span><br><span class="line">    FTE_DBG_MSG(DBG_MSG_LEVEL_INFO, <span class="string">"[SiAgent-%s]:Execute Filter Task."</span>,pSiAgentObj-&gt;agentObjectName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pFilterTaskPool-&gt;doingFilterTaskNumber &lt; pFilterTaskPool-&gt;maxSecFilterNumber )</span><br><span class="line">    {</span><br><span class="line">        targetCurrentTime = SiAgent_GetTime(pSiAgentObj);</span><br><span class="line"></span><br><span class="line">        pFilterTaskPool-&gt;targetCurrentTime = targetCurrentTime ;</span><br><span class="line"></span><br><span class="line">        totalFilterTaskNumber = pFilterTaskPool-&gt;totalFilterTaskNumber ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; totalFilterTaskNumber ; i ++ )</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>( pFilterTaskPool-&gt;filterTask[i].filterTaskState == FILTER_TASK_STATE_TO_DO )</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>( pFilterTaskPool-&gt;doingFilterTaskNumber &lt; pFilterTaskPool-&gt;maxSecFilterNumber )</span><br><span class="line">                {</span><br><span class="line">                    bCreate=TRUE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span>( pFilterTaskPool-&gt;filterTask[i].filterTaskType )</span><br><span class="line">                    {</span><br><span class="line">                    <span class="keyword">case</span> FILTER_TASK_TYPE_TIMEOUT_AUTO_CLOSED:</span><br><span class="line">                        <span class="keyword">if</span>(pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.endingTime&gt;<span class="number">0</span>)</span><br><span class="line">                        {</span><br><span class="line">                            bCreate=SiAgent_FTE_EnableSecFilter( pSiAgentObj, &amp;(pFilterTaskPool-&gt;filterTask[i]) );</span><br><span class="line">                            <span class="keyword">if</span>(bCreate)</span><br><span class="line">                            {</span><br><span class="line">                                pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.timeout=pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.endingTime;</span><br><span class="line">                                pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.endingTime += (targetCurrentTime+<span class="number">1</span>) ;<span class="comment">//fix incorrect timeout ,0.99999~1</span></span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            pFilterTaskPool-&gt;filterTask[i].filterTaskState = FILTER_TASK_STATE_DOING;</span><br><span class="line">                            pFilterTaskPool-&gt;todoFilterTaskNumber -- ;</span><br><span class="line">                            bCreate=FALSE;</span><br><span class="line">                            pFilterTaskPool-&gt;doneFilterTaskNumber  ++ ;</span><br><span class="line">                            pFilterTaskPool-&gt;filterTask[i].typeTimeoutClosed.closedReason = FILTER_TASK_CLOSED_REASON_TIMEOUT ;</span><br><span class="line">                            pFilterTaskPool-&gt;filterTask[i].filterTaskState = FILTER_TASK_STATE_DONE ;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    <span class="keyword">case</span> FILTER_TASK_TYPE_RECEIVE_AUTO_CLOSED:</span><br><span class="line">                    <span class="keyword">case</span> FILTER_TASK_TYPE_OPEN_CONTINUOUSLY  :</span><br><span class="line">                        bCreate=SiAgent_FTE_EnableSecFilter( pSiAgentObj, &amp;(pFilterTaskPool-&gt;filterTask[i]) );</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    <span class="keyword">default</span> :</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(bCreate)</span><br><span class="line">                    {</span><br><span class="line">                        pFilterTaskPool-&gt;filterTask[i].filterTaskState = FILTER_TASK_STATE_DOING;</span><br><span class="line">                        pFilterTaskPool-&gt;todoFilterTaskNumber -- ;</span><br><span class="line">                        pFilterTaskPool-&gt;doingFilterTaskNumber ++ ;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentFilterTaskExecutor.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SiAgent_FTE_EnableSecFilter</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, FILTER_TASK_P pFilterTask )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    FTE_DBG_MSG(DBG_MSG_LEVEL_INFO, <span class="string">"[SiAgent-%s]:Enable Virtual Section Filter."</span>,pSiAgentObj-&gt;agentObjectName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>( pFilterTask-&gt;secFilterFunction )</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_GET_TABLE      :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_GetTableFilter( pSiAgentObj, pFilterTask-&gt;argGetTable.pid, pFilterTask-&gt;argGetTable.tid ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_MONITOR_PAT    :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_MonitorPatFilter( pSiAgentObj, pFilterTask-&gt;argMonitorPat.pid, pFilterTask-&gt;argMonitorPat.tid, pFilterTask-&gt;argMonitorPat.tsid, pFilterTask-&gt;argMonitorPat.version ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_GET_PMT        :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_GetPmtFilter( pSiAgentObj, pFilterTask-&gt;argGetPmt.pid, pFilterTask-&gt;argGetPmt.tid, pFilterTask-&gt;argGetPmt.programNumber ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_MONITOR_PMT    :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_MonitorPmtFilter( pSiAgentObj, pFilterTask-&gt;argMonitorPmt.pid, pFilterTask-&gt;argMonitorPmt.tid, pFilterTask-&gt;argMonitorPmt.programNumber, pFilterTask-&gt;argMonitorPmt.version ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_MONITOR_TABLE  :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_MonitorTableFilter( pSiAgentObj, pFilterTask-&gt;argMonitorTable.pid, pFilterTask-&gt;argMonitorTable.tid, pFilterTask-&gt;argMonitorTable.version ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_GET_APF_EIT    :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_GetApfEitFilter( pSiAgentObj, pFilterTask-&gt;argGetApfEit.pid, pFilterTask-&gt;argGetApfEit.tid, pFilterTask-&gt;argGetApfEit.serviceId, pFilterTask-&gt;argGetApfEit.sectionNumber ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_MONITOR_APF_EIT:</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_MonitorApfEitFilter( pSiAgentObj, pFilterTask-&gt;argMonitorApfEit.pid, pFilterTask-&gt;argMonitorApfEit.tid, pFilterTask-&gt;argMonitorApfEit.serviceId, pFilterTask-&gt;argMonitorApfEit.sectionNumber, pFilterTask-&gt;argMonitorApfEit.version ) ;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_GET_DXI        :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_GetDxiFilter(pSiAgentObj, pFilterTask-&gt;argGetDxi.pid, pFilterTask-&gt;argGetDxi.tid, pFilterTask-&gt;argGetDxi.id );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_MONITOR_DXI    :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_MonitorDxiFilter(pSiAgentObj, pFilterTask-&gt;argMonitorDxi.pid, pFilterTask-&gt;argMonitorDxi.tid, pFilterTask-&gt;argMonitorDxi.id, pFilterTask-&gt;argMonitorDxi.versionFlag );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SEC_FLTR_FUNC_GET_SSU_DDB    :</span><br><span class="line">        <span class="keyword">return</span> SiAgent_Enable_GetSsuDdbFilter(pSiAgentObj, pFilterTask-&gt;argGetSsuDdb.pid, pFilterTask-&gt;argGetSsuDdb.tid, pFilterTask-&gt;argGetSsuDdb.moduleIdMsb );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span></span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里，要拿<code>PMT</code>，要依次跑SEC_FLTR_FUNC_GET_TABLE、SEC_FLTR_FUNC_GET_PMT，</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentVirSecFilterMgr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SiAgent_Enable_GetTableFilter</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, <span class="keyword">unsigned</span> <span class="keyword">short</span> pid, <span class="keyword">unsigned</span> <span class="keyword">char</span> tid )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PID_LAYER_P pPidLayer ;</span><br><span class="line">    SEC_FILTER_LAYER_P pSecFilterLayer = <span class="literal">NULL</span>;	<span class="comment">// FIXED_CID_14323</span></span><br><span class="line">    SEC_FILTER_LAYER_T argSecFilter ;</span><br><span class="line">    SEC_FILTER_LAYER_P pSecFilterLinkList ;</span><br><span class="line">    BOOL ret=FALSE;</span><br><span class="line"></span><br><span class="line">    VSFM_LOCK(pSiAgentObj);</span><br><span class="line"></span><br><span class="line">    pPidLayer = SiAgent_VSFM_SearchPidLayer( pSiAgentObj, pid ) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pPidLayer == <span class="literal">NULL</span> )</span><br><span class="line">    {</span><br><span class="line">        pPidLayer = SiAgent_VSFM_CreatePidLayer( pSiAgentObj, pid ) ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    argSecFilter.secFilterFunction = SEC_FLTR_FUNC_GET_TABLE ;</span><br><span class="line">    argSecFilter.argGetTable.pid = pid ;</span><br><span class="line">    argSecFilter.argGetTable.tid = tid ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pPidLayer != <span class="literal">NULL</span> )</span><br><span class="line">    {</span><br><span class="line">        pSecFilterLayer = SiAgent_VSFM_SearchSecFilterLayer( pSiAgentObj, pPidLayer, &amp;argSecFilter ) ;</span><br><span class="line">        <span class="keyword">if</span>( pSecFilterLayer == <span class="literal">NULL</span> )</span><br><span class="line">        {</span><br><span class="line">            pSecFilterLayer = (SEC_FILTER_LAYER_P) VSFM_MALLOC( <span class="keyword">sizeof</span>(SEC_FILTER_LAYER_T) ) ;</span><br><span class="line">            <span class="keyword">if</span>(pSecFilterLayer!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">memset</span>(pSecFilterLayer,<span class="number">0</span>,<span class="keyword">sizeof</span>(SEC_FILTER_LAYER_T));</span><br><span class="line">                VSFM_FILTER_SET_OWNER(pSecFilterLayer-&gt;owner, SF_OWNER_AGENT);</span><br><span class="line"></span><br><span class="line">                pSecFilterLayer-&gt;referenceCount = <span class="number">1</span> ;</span><br><span class="line">                pSecFilterLayer-&gt;secFilterFunction = SEC_FLTR_FUNC_GET_TABLE ;</span><br><span class="line">                pSecFilterLayer-&gt;argGetTable.pid = pid ;</span><br><span class="line">                pSecFilterLayer-&gt;argGetTable.tid = tid ;</span><br><span class="line"></span><br><span class="line">                pSecFilterLinkList = (SEC_FILTER_LAYER_P) &amp;(pPidLayer-&gt;secFilterLinkList) ;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( pSecFilterLinkList-&gt;fd == pSecFilterLinkList )</span><br><span class="line">                {</span><br><span class="line">                    pSecFilterLinkList-&gt;fd = pSecFilterLayer ;</span><br><span class="line">                    pSecFilterLinkList-&gt;bk = pSecFilterLayer ;</span><br><span class="line">                    pSecFilterLayer-&gt;fd    = pSecFilterLinkList ;</span><br><span class="line">                    pSecFilterLayer-&gt;bk    = pSecFilterLinkList ;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    pSecFilterLinkList-&gt;bk-&gt;fd = pSecFilterLayer ;</span><br><span class="line">                    pSecFilterLayer-&gt;bk = pSecFilterLinkList-&gt;bk ;</span><br><span class="line">                    pSecFilterLayer-&gt;fd    = pSecFilterLinkList ;</span><br><span class="line">                    pSecFilterLinkList-&gt;bk = pSecFilterLayer ;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                SIAGENT_VSFM_DBG_MSG(DBG_MSG_LEVEL_INFO, <span class="string">"[SiAgent-%s]:SiAgent_Enable_GetTableFilter(pid:0x%04x,tid:0x%02x) - refcnt:%d"</span>,pSiAgentObj-&gt;agentObjectName,pid,tid,pSecFilterLayer-&gt;referenceCount);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            pSecFilterLayer-&gt;referenceCount ++ ;</span><br><span class="line">            SIAGENT_VSFM_DBG_MSG(DBG_MSG_LEVEL_INFO, <span class="string">"[SiAgent-%s]:SiAgent_Enable_GetTableFilter(pid:0x%04x,tid:0x%02x) - refcnt:%d"</span>,pSiAgentObj-&gt;agentObjectName,pid,tid,pSecFilterLayer-&gt;referenceCount);</span><br><span class="line">        }</span><br><span class="line">        ret=TRUE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VSFM_UNLOCK(pSiAgentObj);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>无论哪个secFilterFunction，都会跑SiAgent_VSFM_CreatePidLayer：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siAgentVirSecFilterMgr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PID_LAYER_P <span class="title">SiAgent_VSFM_CreatePidLayer</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, <span class="keyword">unsigned</span> <span class="keyword">short</span> pid )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    PID_LAYER_P pPidLinkList = (PID_LAYER_P) &amp;(pSiAgentObj-&gt;pidLinkList) ;</span><br><span class="line">    PID_LAYER_P pPidLayer ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pPidLayer = (PID_LAYER_P) VSFM_MALLOC( <span class="keyword">sizeof</span>(PID_LAYER_T) ) ;</span><br><span class="line">    <span class="keyword">if</span>(pPidLayer!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!SiAgtFW_EnablePidFilter( pSiAgentObj, pid ))</span><br><span class="line">        {</span><br><span class="line">            VSFM_FREE(pPidLayer);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pPidLayer-&gt;pid = pid ;</span><br><span class="line">        pPidLayer-&gt;secFilterLinkList.fd = &amp;(pPidLayer-&gt;secFilterLinkList) ;</span><br><span class="line">        pPidLayer-&gt;secFilterLinkList.bk = &amp;(pPidLayer-&gt;secFilterLinkList) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pPidLinkList-&gt;fd == pPidLinkList )</span><br><span class="line">        {</span><br><span class="line">            pPidLinkList-&gt;fd = pPidLayer ;</span><br><span class="line">            pPidLinkList-&gt;bk = pPidLayer ;</span><br><span class="line">            pPidLayer-&gt;fd    = pPidLinkList ;</span><br><span class="line">            pPidLayer-&gt;bk    = pPidLinkList ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            pPidLinkList-&gt;bk-&gt;fd = pPidLayer ;</span><br><span class="line">            pPidLayer-&gt;bk = pPidLinkList-&gt;bk ;</span><br><span class="line">            pPidLayer-&gt;fd    = pPidLinkList ;</span><br><span class="line">            pPidLinkList-&gt;bk = pPidLayer ;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        SiAgtFW_CreateSectionBuffer( pSiAgentObj, pid );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pPidLayer ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/agent/siagent2_dvr/siFunctionWrapper.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SiAgtFW_EnablePidFilter</span><span class="params">( SIAGENT_OBJECT_P pSiAgentObj, <span class="keyword">unsigned</span> <span class="keyword">short</span> pid )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(pSiAgentObj-&gt;handleDemuxer)</span><br><span class="line">        <span class="keyword">return</span> SI_TPInterface_SetFilter(pSiAgentObj-&gt;handleDemuxer, pid, SI_FILTER_SI, SI_CODEC_OTHERS) == SI_TP_ERR_OK ? TRUE :FALSE;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/tpInterface/PVR/tp.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_TPInterface_SetFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>								*tp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						pid,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_FILTER_TYPE						type,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_CODEC_TYPE						codecType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(type==SI_FILTER_SI)</span><br><span class="line">    {</span><br><span class="line">        ret=SI_BeanGen_EnablePid( _tp-&gt;bgHandle,  pid</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_USE_SDEC</span></span><br><span class="line">                                  ,_tp-&gt;siHandle,_tp-&gt;sdecChannel</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                                );</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    filter.pid			= pid;</span><br><span class="line">    filter.bActive		= <span class="number">1</span>;</span><br><span class="line">    filter.type 		= type;</span><br><span class="line">    filter.codecType	= codecType;</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    _tp-&gt;tsFuncs.InsertFilterList(_tp-&gt;navHandle, count, &amp;filter);</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/tpInterface/PVR/siBeanGen.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_BeanGen_EnablePid</span><span class="params">(BEAN_GENERATOR *pBeanGen,<span class="keyword">unsigned</span> <span class="keyword">int</span> pid</span></span></span><br><span class="line"><span class="params"><span class="function">#ifdef SI_USE_SDEC</span></span></span><br><span class="line"><span class="params"><span class="function">                             ,<span class="keyword">unsigned</span> <span class="keyword">int</span> transaction_id,<span class="keyword">int</span> ch</span></span></span><br><span class="line"><span class="params"><span class="function">#endif</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                            )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BEANGEN_FILTERINFO *bgfInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;BEANGEN_FILTERNUM; i++)</span><br><span class="line">    {</span><br><span class="line">        bgfInfo = pBeanGen-&gt;filterInfo+i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bgfInfo-&gt;pid==pid)</span><br><span class="line">        {</span><br><span class="line">            SI_BEAN_LOG(SI_BEAN_LEVEL_WARNING, <span class="string">"SI_BeanGen_EnablePid re-enable 0x%04x\n"</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> SI_TP_ERR_OK;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;BEANGEN_FILTERNUM; i++)</span><br><span class="line">    {</span><br><span class="line">        bgfInfo = pBeanGen-&gt;filterInfo+i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bgfInfo-&gt;pid&gt;<span class="number">0x1fFF</span>)</span><br><span class="line">        {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_USE_SDEC</span></span><br><span class="line">            bgfInfo-&gt;SecfIndex=<span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span>(ch!=SDEC_CH_MAX)</span><br><span class="line">            {</span><br><span class="line">                SDEC_SECTION_FILTER_T filter;<span class="comment">//={0};</span></span><br><span class="line">                <span class="built_in">memset</span>(&amp;filter,<span class="number">0</span>,<span class="keyword">sizeof</span>(filter));</span><br><span class="line">                filter.pid=pid;</span><br><span class="line">                filter.transaction_id=transaction_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_USE_HW_CRC</span></span><br><span class="line">                <span class="keyword">if</span>(PID_TDT!=pid)filter.crc_chksum=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">if</span>(RHAL_SDEC_RequestSection(ch, &amp;filter, &amp;bgfInfo-&gt;SecfIndex, <span class="number">0</span>, fnSDECDataHandlingCB)!=API_OK)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> SI_TP_ERR_BEAN_PID_FULL;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            bgfInfo-&gt;pid = pid;</span><br><span class="line">            bgfInfo-&gt;tid = <span class="number">0xff</span>;</span><br><span class="line">            bgfInfo-&gt;remainedSecLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            SI_BEAN_LOG(SI_BEAN_LEVEL_INFO, <span class="string">"SI_BeanGen_EnablePid first-enable 0x%04x\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SI_TP_ERR_OK;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    SI_BEAN_LOG(SI_BEAN_LEVEL_WARNING, <span class="string">"warn!! SI_BeanGen_EnablePid  not enable 0x%04x\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SI_TP_ERR_BEAN_PID_FULL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>RHAL_SDEC_RequestSection参数传入了fnSDECDataHandlingCB：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* hal_src/hal/src/sdec/rhal_sdec.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">DTV_STATUS_T <span class="title">RHAL_SDEC_RequestSection</span><span class="params">(SDEC_CHANNEL_T ch, SDEC_SECTION_FILTER_T *pSectionFilter, UINT8 *pSecfIndex, UINT32 gpbSize, pfnSDECDataHandlingCB pfnCallBack)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SECTION_CALL_DEBUG(RTD_LOG_MODULE_SDEC) ;</span><br><span class="line">    <span class="function">CAutoLock <span class="title">AutoLock</span><span class="params">(&amp;Sdec_CritSec)</span> </span>;</span><br><span class="line">    <span class="function">CAutoLock <span class="title">AutoLockCB</span><span class="params">(&amp;Sdec_CritSecForCB)</span> </span>;</span><br><span class="line">    CHECK_SDEC_MODULE_INIT(<span class="number">0</span>) ;</span><br><span class="line">    CHECK_CH_PARAM_VALID(ch) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pSectionFilter || !pSecfIndex || !pfnCallBack) <span class="keyword">return</span> INVALID_PARAMS ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DTV_STATUS_T ret ;</span><br><span class="line">    DEMUX_ADD_SEC_FILTER_T secFilter ;</span><br><span class="line">    UINT8 posVal[<span class="number">10</span>]={<span class="number">0</span>}, posMsk[<span class="number">10</span>]={<span class="number">0</span>}, negVal[<span class="number">10</span>]={<span class="number">0</span>}, negMsk[<span class="number">10</span>]={<span class="number">0</span>} ;</span><br><span class="line">    SINT32 secfIndex ;</span><br><span class="line">    UINT8 filterID, i ;</span><br><span class="line">    UINT8 *virAddr ;</span><br><span class="line"></span><br><span class="line">    SECTION_DEBUG(RTD_LOG_MODULE_SDEC, <span class="string">"pid = %d, gpbSize = %d\n"</span>, pSectionFilter-&gt;pid, gpbSize) ;</span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "transaction_id                    = %d\n", pSectionFilter-&gt;transaction_id) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "pid                               = %d\n", pSectionFilter-&gt;pid) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "table_id                          = %d\n", pSectionFilter-&gt;table_id) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "section_syntax_indicator          = %d\n", pSectionFilter-&gt;section_syntax_indicator) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "table_id_extension                = %d\n", pSectionFilter-&gt;table_id_extension) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "version_number                  = %d\n", pSectionFilter-&gt;version_number) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "current_next_indicator            = %d\n", pSectionFilter-&gt;current_next_indicator) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "last_section_number               = %d\n", pSectionFilter-&gt;last_section_number) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "protocol_version                  = %d\n", pSectionFilter-&gt;protocol_version) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "table_id_filter_mask              = %d\n", pSectionFilter-&gt;table_id_filter_mask) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "table_id_extension_filter_mask    = %d\n", pSectionFilter-&gt;table_id_extension_filter_mask) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "section_syntax_indicator_filter   = %d\n", pSectionFilter-&gt;section_syntax_indicator_filter) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "version_number_filter             = %d\n", pSectionFilter-&gt;version_number_filter) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "not_version_number_filter          = %d\n", pSectionFilter-&gt;not_version_number_filter) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "current_next_indicator_filter     = %d\n", pSectionFilter-&gt;current_next_indicator_filter) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "last_section_number_filter        = %d\n", pSectionFilter-&gt;last_section_number_filter) ;</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "protocol_version_filter          = %d\n", pSectionFilter-&gt;protocol_version_filter) ;</span></span><br><span class="line"></span><br><span class="line">    posVal[<span class="number">0</span>] = pSectionFilter-&gt;table_id ;</span><br><span class="line">    posVal[<span class="number">1</span>] = pSectionFilter-&gt;section_syntax_indicator &lt;&lt; <span class="number">7</span> ;</span><br><span class="line">    posVal[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">    posVal[<span class="number">3</span>] = pSectionFilter-&gt;table_id_extension &gt;&gt; <span class="number">8</span> ;</span><br><span class="line">    posVal[<span class="number">4</span>] = pSectionFilter-&gt;table_id_extension &amp; <span class="number">0xFF</span> ;</span><br><span class="line">    posVal[<span class="number">5</span>] = pSectionFilter-&gt;version_number &lt;&lt; <span class="number">1</span> | pSectionFilter-&gt;current_next_indicator ;</span><br><span class="line">    posVal[<span class="number">6</span>] = <span class="number">0</span> ; <span class="comment">// map to section_number</span></span><br><span class="line">    posVal[<span class="number">7</span>] = pSectionFilter-&gt;last_section_number ; <span class="comment">// map to last_section_number</span></span><br><span class="line">    posVal[<span class="number">8</span>] = pSectionFilter-&gt;protocol_version ;</span><br><span class="line"></span><br><span class="line">    posMsk[<span class="number">0</span>] = pSectionFilter-&gt;table_id_filter_mask;</span><br><span class="line">    posMsk[<span class="number">1</span>] = (pSectionFilter-&gt;section_syntax_indicator_filter) ? <span class="number">0x80</span> : <span class="number">0x00</span> ;</span><br><span class="line">    posMsk[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    posMsk[<span class="number">3</span>] = pSectionFilter-&gt;table_id_extension_filter_mask &gt;&gt; <span class="number">8</span> ;</span><br><span class="line">    posMsk[<span class="number">4</span>] = pSectionFilter-&gt;table_id_extension_filter_mask &amp; <span class="number">0xFF</span> ;</span><br><span class="line">    posMsk[<span class="number">5</span>] = (((pSectionFilter-&gt;version_number_filter) ? <span class="number">0x1F</span> : <span class="number">0x0</span>) &lt;&lt; <span class="number">1</span>) | ((pSectionFilter-&gt;current_next_indicator_filter) ? <span class="number">0x1</span> : <span class="number">0x0</span>) ;</span><br><span class="line">    posMsk[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    posMsk[<span class="number">7</span>] = (pSectionFilter-&gt;last_section_number_filter) ? <span class="number">0xFF</span> : <span class="number">0x00</span> ;</span><br><span class="line">    posMsk[<span class="number">8</span>] = (pSectionFilter-&gt;protocol_version_filter) ? <span class="number">0xFF</span>: <span class="number">0x00</span> ;</span><br><span class="line"></span><br><span class="line">    negVal[<span class="number">5</span>] = pSectionFilter-&gt;version_number &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    negMsk[<span class="number">5</span>] = (pSectionFilter-&gt;not_version_number_filter ? <span class="number">0x1F</span> : <span class="number">0x0</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    secFilter.ch = MAP_TO_DEMUX_CH(ch) ;</span><br><span class="line">    secFilter.param.PID = pSectionFilter-&gt;pid ;</span><br><span class="line">    secFilter.param.crc_en = pSectionFilter-&gt;crc_chksum ;    <span class="comment">// 1: crc; 2: checksum</span></span><br><span class="line">    secFilter.param.one_shoot = pSectionFilter-&gt;once_flag == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span> ;  <span class="comment">// To get section data only once,"1" should be set.</span></span><br><span class="line">    secFilter.param.toggle_mode_en = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; 10 ; i++)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "func %s, line %d, posVal[%d] = 0x%x\n", __func__, __LINE__, i, posVal[i]) ;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; 10 ; i++)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "func %s, line %d, posMsk[%d] = 0x%x\n", __func__, __LINE__, i, posMsk[i]) ;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, "pid %d, crc_chksum %d, once_flag %d\n", pSectionFilter-&gt;pid, pSectionFilter-&gt;crc_chksum, pSectionFilter-&gt;once_flag) ;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;secFilter.param.PosVal, posVal, <span class="keyword">sizeof</span>(secFilter.param.PosVal)) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;secFilter.param.PosMsk, posMsk, <span class="keyword">sizeof</span>(secFilter.param.PosMsk)) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;secFilter.param.NegVal, negVal, <span class="keyword">sizeof</span>(secFilter.param.NegVal)) ;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;secFilter.param.NegMsk, negMsk, <span class="keyword">sizeof</span>(secFilter.param.NegMsk)) ;</span><br><span class="line"></span><br><span class="line">    secFilter.size = gpbSize; <span class="comment">/* decide how many size of buffer for this section */</span></span><br><span class="line"></span><br><span class="line">    CHECK_IOCTL_RESULT(KADP_SDEC_SetGetProperty(DEMUX_PROPERTY_ADD_SECTION_FILTER, (<span class="keyword">void</span> *)&amp;secFilter, &amp;secfIndex)) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SDEC_CALLBACK_T *pSec        = &amp;Sdec_Info.stSection[MAP_TO_DEMUX_CH(ch)][secfIndex] ;</span><br><span class="line">    RINGBUFFER_HEADER *pHeader = (RINGBUFFER_HEADER *)(Sdec_Info.bufferHeaderPoll.virAddr + (secFilter.headerPhyAddr - (UINT32)Sdec_Info.bufferHeaderPoll.phyAddr));</span><br><span class="line"></span><br><span class="line">    pSec-&gt;phyAddrOffset = Sdec_Info.secBufferInfo.phyAddrOffset;</span><br><span class="line">    pSec-&gt;pWrPtr        = &amp;pHeader-&gt;writePtr;</span><br><span class="line">    pSec-&gt;pRdPtr        = &amp;pHeader-&gt;readPtr[<span class="number">0</span>];</span><br><span class="line">    pSec-&gt;pRdTmpPtr     = &amp;pHeader-&gt;readPtr[<span class="number">1</span>];</span><br><span class="line">    pSec-&gt;pBufferLower  = (UINT8 *)pHeader-&gt;beginAddr;</span><br><span class="line">    pSec-&gt;pBufferUpper  = pSec-&gt;pBufferLower + pHeader-&gt;size;</span><br><span class="line"></span><br><span class="line">    pSec-&gt;pfnCallBack           = pfnCallBack ;</span><br><span class="line">    pSec-&gt;msgType.msgId         = <span class="number">0x67301</span> ;   <span class="comment">//  MSG_SDEC2SIPSIP_SECTION_ACQUIRED ;</span></span><br><span class="line">    pSec-&gt;msgType.channel       = ch ;</span><br><span class="line">    pSec-&gt;msgType.filterId      = secfIndex ;</span><br><span class="line">    pSec-&gt;msgType.pid           = pSectionFilter-&gt;pid ;</span><br><span class="line">    pSec-&gt;msgType.transactionId = pSectionFilter-&gt;transaction_id ;</span><br><span class="line">    pSec-&gt;msgType.pData         = <span class="number">0</span> ;</span><br><span class="line">    pSec-&gt;msgType.dataLen       = <span class="number">0</span> ;</span><br><span class="line">    pSec-&gt;msgType.tableType     = pSectionFilter-&gt;table_id ;   <span class="comment">// ONLY for PSIP</span></span><br><span class="line">    pSec-&gt;msgType.entryId       = <span class="number">0</span> ;   <span class="comment">// ONLY for PSIP</span></span><br><span class="line">    pSec-&gt;msgType.bufLower      = (UINT32)pSec-&gt;pBufferLower + pSec-&gt;phyAddrOffset;</span><br><span class="line">    pSec-&gt;msgType.bufUpper      = pSec-&gt;msgType.bufLower + pHeader-&gt;size;</span><br><span class="line">    *pSecfIndex                 = secfIndex ;</span><br><span class="line">    pSec-&gt;used                  = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    SECTION_DEBUG(RTD_LOG_MODULE_SDEC, <span class="string">"phyAddrOfSet 0x%x, pWrPtr 0x%x, pRdPtr 0x%x\n"</span>, pSec-&gt;phyAddrOffset, pSec-&gt;pWrPtr, pSec-&gt;pRdPtr) ;</span><br><span class="line">    SECTION_DEBUG(RTD_LOG_MODULE_SDEC, <span class="string">"*pWrPtr 0x%x, *pRdPtr 0x%x, *pRdTmpPtr 0x%x\n"</span>, *pSec-&gt;pWrPtr, *pSec-&gt;pRdPtr, *pSec-&gt;pRdTmpPtr) ;</span><br><span class="line">    SECTION_DEBUG(RTD_LOG_MODULE_SDEC, <span class="string">"pBufferLower 0x%x, pBufferUpper 0x%x, gpbSize %d\n"</span>, pSec-&gt;pBufferLower, pSec-&gt;pBufferUpper, gpbSize) ;</span><br><span class="line">    SECTION_DEBUG(RTD_LOG_MODULE_SDEC, <span class="string">"secfIndex = %d\n"</span>, secfIndex) ;</span><br><span class="line">    <span class="keyword">return</span> API_OK ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到这里好像就没了？<code>PMT</code>信息好像还是没有拿到呢？</p>
<h2 id="SDEC-Thread"><a href="#SDEC-Thread" class="headerlink" title="_SDEC_Thread"></a>_SDEC_Thread</h2><p>小<span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>汁还是太年轻了，这里有另外一个线程_SDEC_Thread要说明一下。</p>
<p>从TVservice启动的时候开始：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/services/ \</span></span><br><span class="line"><span class="comment">* tvservice/main_tvservice.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __attribute__((unused)), <span class="keyword">char</span> **argv __attribute__((unused)))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    BootManager::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">Initial</span>();</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* BootManager/BootManager.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootManager::Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> m_pBootManagerImpl-&gt;<span class="built_in">Initial</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* BootManager/BootManagerImpl.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootManagerImpl::Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="built_in">RegisterInitFunc</span>();</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BootManagerImpl::RegisterInitFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    m_pInitFuncImplMgr-&gt;<span class="built_in">RegisterInitFunc</span>(&amp;BootManagerImpl::InitDTV, INIT_PRIORITY_3, INIT_MODULE_DTV);</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BootManagerImpl::InitDTV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">DUMP_TRACE_LOG</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_TUNNERCHECK</span></span><br><span class="line">	<span class="keyword">if</span> (m_bWithTuner)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	{</span><br><span class="line">		m_pHalModulesInit = <span class="keyword">new</span> <span class="built_in">HalModulesInit</span>();</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* hal_src/hal/src/hal_module_manager/HalModulesInit.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">HalModulesInit::<span class="built_in">HalModulesInit</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">RHAL_SDEC_InitializeModule</span>()!=API_OK)</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">"[%s %d] RHAL_SDEC_InitializeModule fails\n"</span>, __func__, __LINE__);</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/rtkhal/ \</span></span><br><span class="line"><span class="comment">* hal_src/hal/src/sdec/rhal_sdec.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">DTV_STATUS_T <span class="title">RHAL_SDEC_InitializeModule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">RTD_LOGGER_CALL</span>(RTD_LOG_MODULE_SDEC) ;</span><br><span class="line">    <span class="keyword">return</span> _Initiallize() ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> DTV_STATUS_T _Initiallize()</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="comment">// Create SDEC thread</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(&amp;_sdec_thread_id, <span class="literal">NULL</span>, _SDEC_Thread, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">RTD_LOG_ERROR</span>(RTD_LOG_MODULE_SDEC, <span class="string">"[%s %d] %s - SDEC thread creation failed\n"</span>, __FILE__, __LINE__, __func__) ;</span><br><span class="line">        <span class="keyword">return</span> API_NOT_OK ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _isRunSdecThread = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    Sdec_IsInit = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> API_OK ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_SDEC_Thread(<span class="keyword">void</span>*)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// check error for debug</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID(index, size, buffer_info, msg)     \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (index &gt;= Sdec_Info.secBufferInfo.maxIndex || size &gt; MAX_SECTION_SIZE)              \</span></span><br><span class="line"><span class="meta">    {                                                                                      \</span></span><br><span class="line"><span class="meta">        RTD_LOG_ERROR(RTD_LOG_MODULE_SDEC,<span class="meta-string">"func %s, line %d, Please Debug !! index %d, size %d\n"</span>, __func__, __LINE__, (index), (size));                                                                                           \</span></span><br><span class="line"><span class="meta">        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, <span class="meta-string">"Before clean section buffer : TmpRd 0x%x, Wr 0x%x, pLower 0x%x, pUpper 0x%x\n"</span>, (buffer_info).pRdTmpPtr,(buffer_info).pWrPtr, (buffer_info).pBufferLower, (buffer_info).pBufferUpper); \</span></span><br><span class="line"><span class="meta">        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, <span class="meta-string">"Before clean section buffer : Sectiondata    CH: %d PID:0x%x - tid:0x%x \n"</span>, (msg).channel, (msg).pid, (msg).tableType);                                                               \</span></span><br><span class="line"><span class="meta">        (buffer_info).pRdTmpPtr = (buffer_info).pWrPtr;                                    \</span></span><br><span class="line"><span class="meta">        (buffer_info).pRdPtr    = (buffer_info).pWrPtr;                                    \</span></span><br><span class="line"><span class="meta">        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, <span class="meta-string">"After clean section buffer : TmpRd 0x%x, Wr 0x%x, pLower 0x%x, pUpper 0x%x\n"</span>, (buffer_info).pRdTmpPtr,(buffer_info).pWrPtr, (buffer_info).pBufferLower, (buffer_info).pBufferUpper);  \</span></span><br><span class="line"><span class="meta">        RTD_LOG_DEBUG(RTD_LOG_MODULE_SDEC, <span class="meta-string">"After clean section buffer : Sectiondata     CH: %d PID:0x%x - tid:0x%x \n"</span>, (msg).channel, (msg).pid, (msg).tableType);                                                               \</span></span><br><span class="line"><span class="meta">        Sdec_CritSecForCB.Unlock();                                                        \</span></span><br><span class="line"><span class="meta">        continue;                                                                          \</span></span><br><span class="line"><span class="meta">    }</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* threadName = <span class="string">"SdecThread"</span>;</span><br><span class="line">    <span class="built_in">pli_setThreadName</span>((<span class="keyword">char</span>*)threadName) ;</span><br><span class="line">    SDEC_MSG_TYPE_T msgType ;</span><br><span class="line">    SINT32 i, j, index, size;</span><br><span class="line">    UINT32 r;</span><br><span class="line">    UINT8 *ptr, *pVirAddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span> ;</span></span><br><span class="line">    SDEC_CALLBACK_T *pCB;</span><br><span class="line">    fds.fd = Sdec_Info.fd ;</span><br><span class="line">    fds.events = POLLIN ; <span class="comment">// the input event</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msgType, <span class="number">0x0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(SDEC_MSG_TYPE_T)) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">poll</span>(&amp;fds, <span class="number">1</span>, POLL_INTERVAL) &gt; <span class="number">0</span>)  <span class="comment">// wait POLL_INTERVAL ms</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (fds.revents &amp; POLLIN) <span class="comment">// the output event</span></span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Section */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; DEMUX_CH_NUM ; i++)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; MAX_SECTION_NUM ; j++)</span><br><span class="line">                    {</span><br><span class="line">                        pCB = &amp;Sdec_Info.stSection[i][j] ;</span><br><span class="line">                        Sdec_CritSecForCB.<span class="built_in">Lock</span>();</span><br><span class="line">                        <span class="comment">/* check if new section is coming */</span></span><br><span class="line">                        <span class="keyword">if</span> (pCB-&gt;used &amp;&amp; pCB-&gt;pRdPtr &amp;&amp; <span class="built_in">BS_DISTANCE_TO_READ</span>(*pCB-&gt;pRdTmpPtr, *pCB-&gt;pWrPtr, pCB-&gt;pBufferLower, pCB-&gt;pBufferUpper) &gt; <span class="number">4</span>)</span><br><span class="line">                        {</span><br><span class="line">                            ptr = (UINT8 *)(*pCB-&gt;pRdTmpPtr);</span><br><span class="line">                            pVirAddr = ptr + pCB-&gt;phyAddrOffset;</span><br><span class="line">                            r = *(UINT32 *)pVirAddr ;</span><br><span class="line">                            index = r &gt;&gt; <span class="number">16</span> ;        <span class="comment">/* the section data belong to number of section chunk */</span></span><br><span class="line">                            size  = r &amp; <span class="number">0xffff</span> ;     <span class="comment">/* section data size, if size is 0, index indicates its location */</span></span><br><span class="line"><span class="comment">//                            RTD_LOG_ERROR(RTD_LOG_MODULE_SDEC,"func %s, line %d, ptr 0x%x, index %d, size %d\n", __func__, __LINE__, ptr, index, size) ;</span></span><br><span class="line"></span><br><span class="line">                            <span class="built_in">CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID</span>(index, size, *pCB, msgType);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!size) <span class="comment">/* jump to next index */</span></span><br><span class="line">                            {</span><br><span class="line">                                ptr      = Sdec_Info.secBufferInfo.phyAddr + SDEC_EACH_SEC_UNIT_SIZE*index ; <span class="comment">/* physical address */</span></span><br><span class="line">                                pVirAddr = ptr + pCB-&gt;phyAddrOffset ; <span class="comment">/* virtual address */</span></span><br><span class="line">                                size     = (*(UINT32 *)pVirAddr) &amp; <span class="number">0xffff</span> ;</span><br><span class="line">                                index    = (*(UINT32 *)pVirAddr) &gt;&gt; <span class="number">16</span> ;</span><br><span class="line"><span class="comment">//                                RTD_LOG_ERROR(RTD_LOG_MODULE_SDEC,"func %s, line %d, ptr 0x%x, index %d, size %d\n", __func__, __LINE__, ptr, index, size) ;</span></span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID</span>(index, size, *pCB, msgType);</span><br><span class="line"></span><br><span class="line">                            ptr +=<span class="number">4</span> ; <span class="comment">/* move to data address, first 4 bytes is (index, size) */</span></span><br><span class="line">                            <span class="built_in">memcpy</span>(&amp;msgType, &amp;pCB-&gt;msgType, <span class="built_in"><span class="keyword">sizeof</span></span>(SDEC_MSG_TYPE_T)) ;</span><br><span class="line">                            msgType.pData = ptr + Sdec_Info.secBufferInfo.phyAddrOffset;</span><br><span class="line">                            msgType.dataLen = size ;</span><br><span class="line">                           *pCB-&gt;pRdTmpPtr = ((ULONG)(ptr) + size + <span class="number">3</span>) &amp; ~<span class="number">0x3</span> ; <span class="comment">/* move to next section */</span></span><br><span class="line">                            <span class="built_in">SECTION_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"[%s %d] %s - section filter id_%d callback\n"</span>, __FILE__, __LINE__, __func__, msgType.filterId) ;</span><br><span class="line">                            <span class="built_in">KADP_SDEC_DEBUG_INFO</span>(msgType.pid,SDEC_DEBUG_LOG_CONTROL_CALLBACK, <span class="string">"Sectiondata1     CH: %d    PID:0x%x - tid:0x%x, [0x%x](%s) DataLen:%d\n"</span>, msgType.channel, msgType.pid, msgType.tableType, <span class="number">0</span>,<span class="string">"------"</span> ,msgType.dataLen);</span><br><span class="line">                            Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">                            pCB-&gt;<span class="built_in">pfnCallBack</span>(&amp;msgType) ;</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pCB-&gt;used &amp;&amp; msgType.pData &amp;&amp; pCB-&gt;msgType.msgId==<span class="number">0x67401</span>&amp;&amp;j==MAX_SECTION_NUM<span class="number">-1</span>){</span><br><span class="line">                            <span class="built_in">memcpy</span>(&amp;msgType, &amp;pCB-&gt;msgType, <span class="built_in"><span class="keyword">sizeof</span></span>(SDEC_MSG_TYPE_T)) ;</span><br><span class="line">                            <span class="keyword">int</span> ret = <span class="built_in">KADP_SDEC_GetPCRAdaptionField</span>((DEMUX_CHANNEL_T)msgType.channel,msgType.pid,msgType.pData,&amp;msgType.dataLen);</span><br><span class="line">                            Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line">                            <span class="built_in">RTD_LOG_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"_SDEC_Thread get pcr ret=%d\n"</span>, ret); </span><br><span class="line">                            <span class="keyword">if</span>(ret ==<span class="number">0</span>){</span><br><span class="line">                                <span class="built_in">RTD_LOG_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"_SDEC_Thread get pcr dataLen=%d data=%02x %02x %02x %02x  \n"</span>, msgType.dataLen,msgType.pData[<span class="number">0</span>],msgType.pData[<span class="number">1</span>],msgType.pData[<span class="number">2</span>],msgType.pData[<span class="number">3</span>]); </span><br><span class="line">                                pCB-&gt;<span class="built_in">pfnCallBack</span>(&amp;msgType) ;</span><br><span class="line">                            }</span><br><span class="line">                        }<span class="keyword">else</span>{</span><br><span class="line">                            Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* PES */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; DEMUX_CH_NUM ; i++)</span><br><span class="line">                        {</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; MAX_PES_NUM ; j++)</span><br><span class="line">                            {</span><br><span class="line">                        pCB = &amp;Sdec_Info.stPes[i][j];</span><br><span class="line">                        Sdec_CritSecForCB.<span class="built_in">Lock</span>();</span><br><span class="line">                        <span class="keyword">if</span> (pCB-&gt;used &amp;&amp; pCB-&gt;status == DEMUX_PESBUFFER_OP_PENDING_FOR_INIT){</span><br><span class="line">                            <span class="keyword">if</span> (*(pCB-&gt;pReserved2)==DEMUX_PESBUFFER_OP_INITIALIZED){</span><br><span class="line">                                pCB-&gt;status = DEMUX_PESBUFFER_OP_INITIALIZED;</span><br><span class="line"></span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">else</span>{</span><br><span class="line">                                Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (pCB-&gt;pRdPtr)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="built_in">RTD_LOG_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"Rd 0x%x, Wr 0x%x, pLower 0x%x, pUpper 0x%x\n"</span>, *pCB-&gt;pRdTmpPtr, *pCB-&gt;pWrPtr, pCB-&gt;pBufferLower, pCB-&gt;pBufferUpper) ;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* check if new PES is coming */</span></span><br><span class="line">                        <span class="keyword">if</span> (pCB-&gt;used &amp;&amp; pCB-&gt;pRdPtr &amp;&amp; <span class="built_in">BS_DISTANCE_TO_READ</span>(*pCB-&gt;pRdTmpPtr, *pCB-&gt;pWrPtr, pCB-&gt;pBufferLower, pCB-&gt;pBufferUpper) &gt; <span class="number">4</span>)</span><br><span class="line">                        {</span><br><span class="line">                            ptr = (UINT8 *)(*pCB-&gt;pRdTmpPtr);</span><br><span class="line">                            pVirAddr = ptr + pCB-&gt;phyAddrOffset;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">memcpy</span>(&amp;msgType, &amp;pCB-&gt;msgType, <span class="built_in"><span class="keyword">sizeof</span></span>(SDEC_MSG_TYPE_T)) ;</span><br><span class="line">                            <span class="comment">/* get PES size */</span></span><br><span class="line">                            UINT8 *pPesStart = ptr;</span><br><span class="line">                            size = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DEMUX_PESDATA_PREFIX_PESLENGTH; i++)</span><br><span class="line">                            {</span><br><span class="line">                                size += *(pPesStart + pCB-&gt;phyAddrOffset) &lt;&lt; (i &lt;&lt; <span class="number">3</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((pPesStart + <span class="number">1</span>) &gt;= pCB-&gt;pBufferUpper) <span class="comment">/* move to base */</span></span><br><span class="line">                                    pPesStart = pCB-&gt;pBufferLower;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    pPesStart++;</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* move to data address (first DEMUX_PESDATA_PREFIX_PESLENGTH bytes is size) */</span></span><br><span class="line"></span><br><span class="line">                            ptr +=DEMUX_PESDATA_PREFIX_PESLENGTH;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (ptr &gt;= pCB-&gt;pBufferUpper)</span><br><span class="line">                            {</span><br><span class="line">                                ptr -= (pCB-&gt;pBufferUpper - pCB-&gt;pBufferLower);</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                            msgType.pData = ptr + pCB-&gt;phyAddrOffset;</span><br><span class="line">                            msgType.dataLen = size ;</span><br><span class="line"></span><br><span class="line">                            ptr += size; <span class="comment">/* move to next PES */</span></span><br><span class="line">                            <span class="keyword">if</span> (ptr &gt;= pCB-&gt;pBufferUpper)</span><br><span class="line">                            {</span><br><span class="line">                                ptr -= (pCB-&gt;pBufferUpper - pCB-&gt;pBufferLower);</span><br><span class="line">                            }</span><br><span class="line">                           *pCB-&gt;pRdTmpPtr = (ULONG)(ptr) ; <span class="comment">/* move to next PES */</span></span><br><span class="line"></span><br><span class="line">                            <span class="built_in">RTD_LOG_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"[%s %d] %s - pes filter id_%d callback, ptr 0x%x, size %d\n"</span>, __FILE__, __LINE__, __func__, msgType.filterId, msgType.pData, msgType.dataLen) ;</span><br><span class="line">                            <span class="built_in">KADP_SDEC_DEBUG_INFO</span>(msgType.pid,SDEC_DEBUG_LOG_CONTROL_CALLBACK, <span class="string">"PESdata          CH: %d    PID:0x%x -tid: 0x%x, [0x%x](%s) DataLen:%d\n"</span>,</span><br><span class="line">                                msgType.channel, msgType.pid, <span class="number">0</span>, <span class="number">0</span>, <span class="string">"------"</span> ,msgType.dataLen);</span><br><span class="line"></span><br><span class="line">                            Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line">                            pCB-&gt;<span class="built_in">pfnCallBack</span>(&amp;msgType) ;</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            Sdec_CritSecForCB.<span class="built_in">Unlock</span>();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!_isRunSdecThread)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">RTD_LOG_DEBUG</span>(RTD_LOG_MODULE_SDEC, <span class="string">"[%s %d] %s - Exit _SDEC_Thread\n"</span>, __FILE__, __LINE__, __func__) ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CONTINUE_LOOP_IF_SECTION_BUFFER_INFO_IS_INVALID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>开机之后，TVservice就有一个_SDEC_Thread在跑，其中的while(1)循环里Section部分，会check if new section is coming。_</p>
<p>前面分析，扫台线程ScanThread Check SI的时候，也就是si_agent_threadfuntion SI_AGENT_STATUS_RUNNING的时候，最后行为是在RHAL_SDEC_RequestSection，其中的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pSec-&gt;pfnCallBack           = pfnCallBack ;</span><br></pre></td></tr></tbody></table></figure>

<p>声明了函数指针。</p>
<p>所以这个_SDEC_Thread检测到有section来临时，会跑这个回调函数咯：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pCB-&gt;<span class="built_in">pfnCallBack</span>(&amp;msgType) ;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/collector/SI_Collector.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">DTV_STATUS_T <span class="title">fnSDECDataHandlingCB</span><span class="params">(SDEC_MSG_TYPE_T *pMsg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(pMsg!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        SI *pSI=(SI*)pMsg-&gt;transactionId;</span><br><span class="line">        <span class="keyword">if</span>(pSI!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span>	section[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">if</span>(pMsg-&gt;dataLen&lt;=<span class="number">4096</span>)</span><br><span class="line">            {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SI_SDEC_SIMULATE</span></span><br><span class="line">                si_collector_copy_section(pSI-&gt;collector,pSI-&gt;db,pMsg-&gt;dataLen,pMsg-&gt;pData,pMsg-&gt;pid);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">                RHAL_SDEC_CopySectionData(pMsg-&gt;channel,pMsg-&gt;filterId,pMsg-&gt;pid,section,pMsg-&gt;pData,pMsg-&gt;dataLen);</span><br><span class="line">                <span class="comment">//RHAL_SDEC_ReturnSectionBuffer(pMsg-&gt;channel, pMsg-&gt;filterId, pMsg-&gt;pid, pMsg-&gt;pData, pMsg-&gt;dataLen);</span></span><br><span class="line">                pthread_mutex_lock(&amp;pSI-&gt;collector-&gt;mutexSectionFilter);<span class="comment">//#ifdef ENABLE_MHEG5, fix not thread safe</span></span><br><span class="line">                si_collector_copy_section(pSI-&gt;collector,pSI-&gt;db,pMsg-&gt;dataLen,section,pMsg-&gt;pid);</span><br><span class="line">                pthread_mutex_unlock(&amp;pSI-&gt;collector-&gt;mutexSectionFilter);<span class="comment">//#ifdef ENABLE_MHEG5, fix not thread safe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> API_OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">si_collector_copy_section</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_COLLECTOR							*pCollector,</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_DATABASE							*pDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						sectionLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span>						*sectionBuf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> pid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> tid = sectionBuf[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> tidEx;</span><br><span class="line">        SI_Database_Lock(pDatabase);</span><br><span class="line">        SI_Database_InsertSection(pDatabase, sectionLength, sectionBuf, pid);</span><br><span class="line">        SI_Database_Unlock(pDatabase);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _SI_EXPORT_SECTION_FILTER</span></span><br><span class="line">        <span class="keyword">if</span>( err != SI_ERR_CRC_ERROR ) {</span><br><span class="line">            <span class="comment">//ps. SI_Callback_Section "should" check crc when send it out</span></span><br><span class="line">            <span class="keyword">if</span>( pCollector-&gt;sectionCB[SI_SECTIONCOLLECTOR_CBF_TYPE_CUSTOMIZED_SECTION] != <span class="literal">NULL</span>)</span><br><span class="line">                pCollector-&gt;sectionCB[SI_SECTIONCOLLECTOR_CBF_TYPE_CUSTOMIZED_SECTION](pDatabase, sectionLength, &amp;sectionBuf, pid);</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//_SI_EXPORT_SECTION_FILTER</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span><br><span class="line">        <span class="comment">//kjw ssu todo: need to check crc</span></span><br><span class="line">        <span class="keyword">if</span>( tid == SI_TID_DSM_DXI || tid == SI_TID_DSM_DDB || tid == SI_SSU_UNT)</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pCollector-&gt;sectionCB[SI_SECTIONCOLLECTOR_CBF_TYPE_SSU_SECTION])</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(sectionLength &gt;=<span class="number">30</span>)</span><br><span class="line">                {   <span class="comment">// min length of ddb,dXi is 30</span></span><br><span class="line">                    <span class="comment">//crc is checked in individual table</span></span><br><span class="line">                    pCollector-&gt;sectionCB[SI_SECTIONCOLLECTOR_CBF_TYPE_SSU_SECTION](pDatabase, sectionLength, &amp;sectionBuf, pid);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">//ENABLE_SYSTEM_SOFTWARE_UPDATE</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                if (pCollector-&gt;sorted_sectionFilterCb==0) {</span></span><br><span class="line"><span class="comment">                    //sort callback pointer by desc.</span></span><br><span class="line"><span class="comment">                    qsort(pCollector-&gt;sectionFilterCb, SI_COLLECTION_CALLBACK_MAX, sizeof(SI_COLLECTOR_SECTION_FILTER_CALLBACK), compare_SI_COLLECTOR_SECTION_FILTER_CALLBACK);</span></span><br><span class="line"><span class="comment">                    pCollector-&gt;sorted_sectionFilterCb=1;</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SI_COLLECTION_CALLBACK_MAX; i++) {</span><br><span class="line">            SI_COLLECTOR_SECTION_FILTER_CALLBACK *pSectionFilterCb;</span><br><span class="line">            SI_Collector_SectionCallbackEx pCallback;</span><br><span class="line">            SI_Collector_SectionCallbackEx_userdata pCallback_userdata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            pSectionFilterCb=&amp;pCollector-&gt;sectionFilterCb[i];</span><br><span class="line">            <span class="keyword">if</span> (pSectionFilterCb-&gt;pCallback==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pid!=pSectionFilterCb-&gt;pid)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pSectionFilterCb-&gt;pid==pid &amp;&amp;</span><br><span class="line">                    ((pSectionFilterCb-&gt;tid==(<span class="keyword">unsigned</span> <span class="keyword">short</span>)<span class="number">-1</span>) || ((pSectionFilterCb-&gt;tid&amp;pSectionFilterCb-&gt;tidMask)==(tid&amp;pSectionFilterCb-&gt;tidMask))) <span class="comment">//#ifdef ENABLE_MHEG5, for OB SSF api(for receive 0x3B/0x3C/0x3D data in one section filter)</span></span><br><span class="line">               ) {</span><br><span class="line">                <span class="keyword">if</span> (pSectionFilterCb-&gt;tidEx!=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)<span class="number">-1</span> &amp;&amp;</span><br><span class="line">                        SI_IS_ISDB_T(pDatabase-&gt;si) &amp;&amp;</span><br><span class="line">                        (tid==SI_TID_DSM_DDB ||</span><br><span class="line">                         tid==SI_TID_DSM_DXI||</span><br><span class="line">                         tid==SI_TID_DSM_3E ||</span><br><span class="line">                         tid==SI_TID_DSM_3D||</span><br><span class="line">                         tid==SI_TID_DSM_3A||</span><br><span class="line">                         tid==SI_TID_DSM_3F )</span><br><span class="line">                   ) {</span><br><span class="line">                    <span class="comment">//ETSI TR 101 202 V1.2.1 Table B.1</span></span><br><span class="line">                    <span class="keyword">if</span> (sectionLength&gt;=<span class="number">5</span>) {</span><br><span class="line">                        tidEx = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)((<span class="keyword">unsigned</span> <span class="keyword">short</span>)(sectionBuf[<span class="number">3</span>])&lt;&lt;<span class="number">8</span>|sectionBuf[<span class="number">4</span>]);</span><br><span class="line">                        <span class="keyword">if</span> (tidEx==pSectionFilterCb-&gt;tidEx) {</span><br><span class="line">                            <span class="keyword">if</span> (pSectionFilterCb-&gt;callback_index==SI_Collector_SectionCallbackEx_INDEX_0)</span><br><span class="line">                            {</span><br><span class="line">                                pCallback=pSectionFilterCb-&gt;pCallback;</span><br><span class="line">                                pthread_mutex_unlock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                                pCallback(pSectionFilterCb-&gt;user_data, sectionLength, &amp;sectionBuf, pid,tid,tidEx,<span class="literal">false</span>);</span><br><span class="line">                                pthread_mutex_lock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line"></span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            {</span><br><span class="line">                                pCallback_userdata=pSectionFilterCb-&gt;pCallback_userdata;</span><br><span class="line">                                pthread_mutex_unlock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                                pCallback_userdata(pSectionFilterCb-&gt;user_data, sectionLength, &amp;sectionBuf, pid,tid,tidEx,<span class="literal">false</span>,pSectionFilterCb-&gt;user_data_len);</span><br><span class="line">                                pthread_mutex_lock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    tidEx=<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(pSectionFilterCb-&gt;tidEx!=(<span class="keyword">unsigned</span> <span class="keyword">short</span>)<span class="number">-1</span> &amp;&amp; sectionLength&gt;=<span class="number">5</span>)</span><br><span class="line">                    {</span><br><span class="line">                        tidEx = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)((<span class="keyword">unsigned</span> <span class="keyword">short</span>)(sectionBuf[<span class="number">3</span>])&lt;&lt;<span class="number">8</span>|sectionBuf[<span class="number">4</span>]);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(pSectionFilterCb-&gt;tidEx == tidEx)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span> (pSectionFilterCb-&gt;callback_index==SI_Collector_SectionCallbackEx_INDEX_0)</span><br><span class="line">                        {</span><br><span class="line">                            pCallback=pSectionFilterCb-&gt;pCallback;</span><br><span class="line">                            pthread_mutex_unlock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                            pCallback(pSectionFilterCb-&gt;user_data, sectionLength, &amp;sectionBuf, pid,tid,tidEx,<span class="literal">false</span>);</span><br><span class="line">                            pthread_mutex_lock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            pCallback_userdata=pSectionFilterCb-&gt;pCallback_userdata;</span><br><span class="line">                            pthread_mutex_unlock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                            pCallback_userdata(pSectionFilterCb-&gt;user_data, sectionLength, &amp;sectionBuf, pid,tid,tidEx,<span class="literal">false</span>,pSectionFilterCb-&gt;user_data_len);</span><br><span class="line">                            pthread_mutex_lock(&amp;pCollector-&gt;mutexSectionFilter);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* vendor/realtek/frameworks/native/appclass/ \</span></span><br><span class="line"><span class="comment">* Si/liveTV_SiDvb/librtd/si4/database/SI_DatabaseSection.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ErrCode <span class="title">SI_Database_InsertSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_DATABASE							*pDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						sectionLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span>						*sectionRawBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 						pid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    <span class="keyword">switch</span>(tid)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> SI_TID_PAT:</span><br><span class="line">        <span class="keyword">if</span> (pid==PID_PAT)</span><br><span class="line">            err = si_database_insert_pat(pDatabase, sectionLength, sectionRawBuffer);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SI_TID_CAT:</span><br><span class="line">        <span class="keyword">if</span> (pid==PID_CAT)</span><br><span class="line">            err = si_database_insert_cat(pDatabase, sectionLength, sectionRawBuffer);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SI_TID_PMT:</span><br><span class="line">        err = si_database_insert_pmt(pDatabase, sectionLength, sectionRawBuffer,pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//省略代码段</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err = SI_ERR_SECTION_NOT_CHECKED;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//省略代码段</span></span><br><span class="line">    SI_DB_RETURN(err);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ErrCode <span class="title">si_database_insert_pmt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SI_DATABASE							*pDatabase,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">int</span>						sectionLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">char</span>						*sectionRawBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">short</span> pid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    SI_DATABASE_TS_NODE *ts=<span class="literal">NULL</span>;</span><br><span class="line">    SI_DATABASE_VC_NODE *vc=<span class="literal">NULL</span>;</span><br><span class="line">    SI_DATABASE_SECTION *pmt=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> programNumber;</span><br><span class="line">    <span class="comment">//int dataLen, infoLen;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> secNo=<span class="number">0</span>,secNoLast=<span class="number">0</span>,ver;</span><br><span class="line"></span><br><span class="line">    SI_DB_BEGIN();</span><br><span class="line">    <span class="comment">//---- check length ----</span></span><br><span class="line">    <span class="keyword">if</span>(sectionLength &lt; <span class="number">16</span>)</span><br><span class="line">        SI_DB_RETURN(SI_ERR_SECTION_TOO_SHORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((((<span class="keyword">unsigned</span> <span class="keyword">int</span>)sectionRawBuffer[<span class="number">1</span>]&amp;<span class="number">0x0F</span>)&lt;&lt;<span class="number">8</span>) + sectionRawBuffer[<span class="number">2</span>] + <span class="number">3</span> != sectionLength)</span><br><span class="line">        SI_DB_RETURN(SI_ERR_INVALIDSECTIONLENGTH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(si_database_check_crc(sectionRawBuffer, sectionLength))</span><br><span class="line">        SI_DB_RETURN(SI_ERR_CRC_ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line">    ts = pDatabase-&gt;currentTS;</span><br><span class="line">    SI_ASSERT(ts);</span><br><span class="line">    secNo=sectionRawBuffer[<span class="number">6</span>];</span><br><span class="line">    secNoLast=sectionRawBuffer[<span class="number">7</span>];</span><br><span class="line">    ver = (sectionRawBuffer[<span class="number">5</span>]&amp;<span class="number">0x3F</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get programNum and it's associated vc</span></span><br><span class="line">    SI_DB_GET_TABLEEXTENSION(sectionRawBuffer, programNumber);</span><br><span class="line">    SI_DB_GET_VCNODE_ADDR(ts, vc, programNumber);</span><br><span class="line">    <span class="keyword">if</span>(!vc)</span><br><span class="line">        SI_DB_RETURN(SI_ERR_CANNOTINSERT);</span><br><span class="line">    <span class="keyword">if</span>(vc-&gt;pmtPID == PID_NULL_PACKET || vc-&gt;pmtPID == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        vc-&gt;pmtPID=pid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (vc-&gt;pmtPID!=pid) {</span><br><span class="line">        SI_DB_RETURN(SI_ERR_CANNOTINSERT);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secNo&gt;=SI_DB_SECTION_NUM_MAX || secNoLast&gt;=SI_DB_SECTION_NUM_MAX ||</span><br><span class="line">            secNo&gt;secNoLast) {</span><br><span class="line">        SI_DB_RETURN(SI_ERR_INVALIDSECTIONLENGTH);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vc-&gt;pmt.count!=(secNoLast+<span class="number">1</span>)) ||</span><br><span class="line">            ((vc-&gt;pmt.ppSec!=<span class="literal">NULL</span>) &amp;&amp; (vc-&gt;pmt.ver != ver))) {</span><br><span class="line">        SI_Database_DestroyMultiSection(pDatabase,ts,&amp;vc-&gt;pmt,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(vc-&gt;pmt.ppSec==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        SI_Database_CreateMultiSection(&amp;vc-&gt;pmt,secNoLast+<span class="number">1</span>,ver);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(vc-&gt;pmt.ppSec[secNo])</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">        vc-&gt;gotPMT=SI_Database_Is_Got_Mulit_Section(&amp;vc-&gt;pmt);</span><br><span class="line">        <span class="keyword">if</span>(SI_DB_COMPARE_SECOBJ_AND_SECBUF(vc-&gt;pmt.ppSec[secNo], sectionRawBuffer, sectionLength)==<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ait_update.pmt == pid &amp;&amp; ait_update.update)</span><br><span class="line">                <span class="keyword">goto</span> CHECK_AIT;</span><br><span class="line">            SI_DB_RETURN(SI_ERR_DATAALREADYEXIST);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            SI_Database_DestroyMultiSection(pDatabase,ts,&amp;vc-&gt;pmt,<span class="number">0</span>);</span><br><span class="line">            SI_Database_CreateMultiSection(&amp;vc-&gt;pmt,secNoLast+<span class="number">1</span>,ver);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    pmt=si_database_GEN_SECTION(pDatabase,ts, vc,sectionLength, sectionRawBuffer,<span class="number">0</span>);</span><br><span class="line">    vc-&gt;pmt.ppSec[secNo] = pmt;</span><br><span class="line">    vc-&gt;gotPMT=SI_Database_Is_Got_Mulit_Section(&amp;vc-&gt;pmt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vc-&gt;gotPMT=%d,pid=%d %s,%s,%d\n"</span>,vc-&gt;gotPMT,pid,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[1;31m[vv] %s %d freq:%d, ver:%x sid %x\033[m\n"</span>,__FUNCTION__,__LINE__,ts-&gt;frequency,ver,</span><br><span class="line">           programNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vc-&gt;pmt = pmt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1<span class="comment">//def ENABLE_NEW_DVB</span></span></span><br><span class="line">    vc-&gt;PMTParsed=FALSE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    SI_DB_RETURN(SI_ERR_OK);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到si_database_GEN_SECTION这里就算是组段完成了（具体细节没有去看了）？然后vc-&gt;gotPMT被置TRUE认为拿到了<code>PMT</code>。</p>
<p>整理一下_SDEC_Thread线程创建：</p>
<blockquote>
<p>TVservice</p>
<blockquote>
<p>Initial</p>
<blockquote>
<p>RegisterInitFunc</p>
<blockquote>
<p>InitDTV</p>
<blockquote>
<p>HalModulesInit</p>
<blockquote>
<p>RHAL_SDEC_InitializeModule</p>
<blockquote>
<p>_Initiallize</p>
<blockquote>
<p>_SDEC_Thread</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>执行：</p>
<blockquote>
<p>_SDEC_Thread</p>
<blockquote>
<p>fnSDECDataHandlingCB</p>
<blockquote>
<p>si_collector_copy_section</p>
<blockquote>
<p>SI_Database_InsertSection</p>
<blockquote>
<p>si_database_insert_pat</p>
<p>si_database_insert_pmt</p>
<blockquote>
<p>si_database_GEN_SECTION</p>
<p>SI_Database_Is_Got_Mulit_Section</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><strong>总结</strong></p>
<p>不要忘了si_agent_threadfuntion线程，重新整理下：</p>
<blockquote>
<p>si_agent_threadfuntion</p>
<blockquote>
<p>SI_Agent_CollectSection</p>
<blockquote>
<p>SiAgtIF_Run</p>
<blockquote>
<p>SiAgentObj_ExecMainTaskSM</p>
<blockquote>
<p>SiAgent_UpdateFilterTaskState</p>
<blockquote>
<p>SiAgent_FTE_CheckTableReceive</p>
<blockquote>
<p>SiAgtFW_CheckPatReceive</p>
<p>SiAgtFW_CheckPmtReceive</p>
<blockquote>
<p>SI_Database_GetSectionReceiveFlag</p>
</blockquote>
</blockquote>
</blockquote>
<p>SiAgent_SM_Main_ScanCh</p>
<blockquote>
<p>SiAgent_GenScanChGetPatFtp</p>
<p>SiAgent_GenScanChGetTablesFtp</p>
<p>SI_Callback_ScanChannel</p>
<blockquote>
<p>SI_Channel_UpdateChList_Append</p>
<blockquote>
<p>si_channel_get_update_ch_list_in_ts</p>
<blockquote>
<p>si_channel_new_channel_object</p>
<blockquote>
<p>si_channel_fill_ch</p>
<blockquote>
<p>SI_Database_GetChannelInfo</p>
<blockquote>
<p>si_database_get_logical_num_and_onid</p>
<blockquote>
<p>__si_database_get_logical_num_and_onid</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>SiAgent_ExecuteFilterTask</p>
<blockquote>
<p>SiAgent_FTE_EnableSecFilter</p>
<blockquote>
<p>SiAgent_Enable_GetTableFilter</p>
<p>SiAgent_Enable_GetPmtFilter</p>
<blockquote>
<p>SiAgent_VSFM_CreatePidLayer</p>
<blockquote>
<p>SiAgtFW_EnablePidFilter</p>
<blockquote>
<p>SI_TPInterface_SetFilter</p>
<blockquote>
<p>SI_BeanGen_EnablePid</p>
<blockquote>
<p>RHAL_SDEC_RequestSection</p>
<blockquote>
<p>fnSDECDataHandlingCB</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>SI_Collector_CollectSection</p>
<blockquote>
<p>SI_TPInterface_GetBeanQueue</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>在扫台线程ScanThread Check SI，也就是si_agent_threadfuntion SI Agent Running阶段，注册fnSDECDataHandlingCB回调函数，_SDEC_Thread线程在Section来临时，执行这个回调函数，做组段动作，并拿数据和置位相应的状态位，si_agent_threadfuntion 根据这些状态位再更新FilterTaskState，判断扫台成功，再回调SI_Callback_ScanChannel发消息告诉ScanThread线程Check SI成功。</p>
<p>有点多，有点乱，这只是个大概，还有一些Bean、TaskPool的设计和实现细节需要理解。我不理解，我都是瞎写的。<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
]]></content>
      <categories>
        <category>TV</category>
      </categories>
      <tags>
        <tag>tv</tag>
        <tag>dvb</tag>
        <tag>si</tag>
        <tag>2851</tag>
      </tags>
  </entry>
  <entry>
    <title>C++提高编程</title>
    <url>/2021/07/17/cpp-3/</url>
    <content><![CDATA[<p>提高编程  </p>
<span id="more"></span>



<ul>
<li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<p><img src="assets/1547105026929.png" alt="1547105026929"></p>
<p>PPT模板：</p>
<p><img src="assets/1547103297864.png" alt="1547103297864"></p>
<p><img src="assets/1547103359158.png" alt="1547103359158"></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li>
</ul>
<ul>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapDouble</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span> </span>{</span><br><span class="line">	<span class="keyword">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
</ul>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"func 调用"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			{</span><br><span class="line">				max = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="keyword">char</span> charArr[] = <span class="string">"bdcfeagh"</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(charArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="keyword">int</span> intArr[] = { <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> };</span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(intArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"调用的普通函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	cout &lt;&lt; <span class="string">"调用的模板"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	cout &lt;&lt; <span class="string">"调用重载的模板"</span> &lt;&lt; endl; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line">	<span class="keyword">char</span> c2 = <span class="string">'b'</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">   	a = b;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) { ... }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a == b "</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"a != b "</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"p1 == p2 "</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"p1 != p2 "</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">" age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">P1</span>(<span class="string">"孙悟空"</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">" age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// Person p("孙悟空", 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">"孙悟空"</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">"猪八戒"</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person1 show"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Person2 show"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>{ obj.<span class="built_in">showPerson1</span>(); }</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>{ obj.<span class="built_in">showPerson2</span>(); }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">" age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">"孙悟空"</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"T1的类型为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"T2的类型为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">"猪八戒"</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"T的类型为： "</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">"唐僧"</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	T m;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() {</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">" 年龄:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) {</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() {</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">" 年龄:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include "person.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.cpp"</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.hpp"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"Tom"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"类外实现 ---- 姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">" 年龄："</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">"Tom"</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">"Jerry"</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="keyword">int</span> capacity)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) {</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) {</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myArray.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; <span class="string">"array1打印输出："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">"array1的大小："</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"array1的容量："</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">"array2打印输出："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">"array2的大小："</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"array2的容量："</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() {} </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) {</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"孙悟空"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"韩信"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"妲己"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"王昭君"</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"pArray的大小："</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"pArray的容量："</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
<p>​</p>
</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) {</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) {</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="keyword">int</span> mAge;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"eee"</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"eee"</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">" Age:"</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) {</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>                          //创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">"hello world"</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">'a'</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">"hello c++"</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">"hello c++"</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">"str6 = "</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">'x'</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"str7 = "</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string str1 = <span class="string">"我"</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">"爱玩游戏"</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str1 += <span class="string">':'</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">"LOL DNF"</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">"I"</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">" love "</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">"game abcde"</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">"abcdefgde"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">"de"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"未找到"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"pos = "</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">"de"</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"pos = "</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">"abcdefgde"</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"1111"</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">"hello"</span>;</span><br><span class="line">	string s2 = <span class="string">"aello"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1 等于 s2"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1 大于 s2"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1 小于 s2"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string str = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">'x'</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string str = <span class="string">"hello"</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">"abcdefg"</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"subStr = "</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">"hello@sina.com"</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">"@"</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">"username: "</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="assets/clip_image002.jpg" alt="说明: 2015-11-10_151152"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                            //判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                      //容器的容量</p>
</li>
<li><p><code>size();</code>                              //返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"v1为空"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"v1不为空"</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"v1的容量 = "</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"v1的大小 = "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         //尾部插入元素ele</li>
<li><code>pop_back();</code>                                                //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	v1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear  </li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>       //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"v1的第一个元素为： "</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"v1的最后一个元素为： "</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	{</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"互换后"</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) {</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"num:"</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img src="assets/clip_image002-1547547642923.jpg" alt="说明: 2015-11-19_204101"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="assets/clip_image002-1547547896341.jpg" alt="clip_image002-1547547896341"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li>
<li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                       //判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                         //返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"d1为空!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"d1不为空!"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"d1的大小为："</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        //在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   //删除容器最后一个数据</li>
<li><code>pop_front();</code>                 //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                           //清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p>
<p>​</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>      //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) {</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"front:"</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"back:"</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> score)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string nameSeed = <span class="string">"ABCDE"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		string name = <span class="string">"选手"</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; "选手： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 打分： " &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//{</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; " ";</span></span><br><span class="line">		<span class="comment">//}</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		{</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 平均分： "</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; "姓名： " &lt;&lt; (*it).m_Name &lt;&lt; " 分数： " &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p><img src="assets/clip_image002-1547604555425.jpg" alt="说明: 2015-11-15_195707"></p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<p><img src="assets/clip_image002.png" alt="img"></p>
<p><img src="assets/clip_image002-1547605111510.jpg" alt="img"></p>
<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      //向栈顶添加元素</li>
<li><code>pop();</code>                //从栈顶移除第一个元素</li>
<li><code>top(); </code>                //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) {</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"栈顶元素为： "</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; <span class="string">"栈的大小为："</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p><img src="assets/clip_image002-1547606475892.jpg" alt="说明: 2015-11-15_214429"></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<p><img src="assets/1547606785041.png" alt="1547606785041"></p>
<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             //往队尾添加元素</li>
<li><code>pop();</code>                                      //从队头移除第一个元素</li>
<li><code>back();</code>                                    //返回最后一个元素</li>
<li><code>front(); </code>                                  //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"唐僧"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"孙悟空"</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"猪八戒"</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"沙僧"</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">"队头元素-- 姓名： "</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">" 年龄： "</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; <span class="string">"队尾元素-- 姓名： "</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"队列大小为："</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img src="assets/clip_image002-1547608564071.jpg" alt="说明: 2015-11-15_225145"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li>
<li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换前： "</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换后： "</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                             //返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                           //判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>                   ​                        //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"L1为空"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"L1不为空"</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"L1的大小为： "</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        //返回第一个元素。</li>
<li><code>back();</code>         //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"第一个元素为： "</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"最后一个元素为： "</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   //反转链表</li>
<li><code>sort();</code>        //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) {</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Age == p2.m_Age) {</span><br><span class="line">		<span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"曹操"</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"孙权"</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">" 身高： "</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">" 身高： "</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
</ul>
<ul>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1为空"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1不为空"</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"s1的大小为： "</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换前"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换后"</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到了元素 ： "</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"第一次插入成功!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"第一次插入失败!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"第二次插入成功!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"第二次插入失败!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">"Tom"</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt;  p.first &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">"Jerry"</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; p2.first &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{    </span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄： "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"m为空"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"m不为空"</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">"m的大小为： "</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换前"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换后"</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"key = "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value = "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到了元素 key = "</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">" value = "</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"未找到元素"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"key:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Salary;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	string nameSeed = <span class="string">"ABCDEFGHIJ"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">"员工"</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="keyword">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"策划部门："</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="keyword">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"----------------------"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"美术部门： "</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"----------------------"</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"研发部门： "</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"姓名： "</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">" 工资： "</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//{</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 工资： " &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	{</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">"myPrint调用次数为： "</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">"Hello C++"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>{</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"没找到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到:"</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">"----------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) {</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
</ul>
<ul>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     //遍历容器</li>
<li><code>transform</code>   //搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	{</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     //查找元素</li>
<li><code>find_if</code>               //按条件查找元素</li>
<li><code>adjacent_find</code>    //查找相邻重复元素</li>
<li><code>binary_search</code>    //二分查找法</li>
<li><code>count</code>                   //统计元素个数</li>
<li><code>count_if</code>             //按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到:"</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到大于5的数字:"</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) {</span><br><span class="line">		cout &lt;&lt; <span class="string">"找不到!"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> {</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到相邻重复元素为:"</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>// 查找指定的元素，查到 返回true  否则false</p>
<p>// 注意: 在<strong>无序序列中不可用</strong></p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"未找到"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"4的个数为： "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"曹操"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"诸葛亮"</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"大于4的个数为： "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="keyword">int</span> m_Age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"曹操"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">"小于35岁的个数："</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>//  beg    开始迭代器</p>
<p>//  end    结束迭代器</p>
<p>// _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	{</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是<strong>有序的</strong></p>
<p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"反转前： "</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"反转后： "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     // 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg  开始迭代器</p>
<p>// end  结束迭代器</p>
<p>// dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"替换前："</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"替换后："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"替换前："</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"替换后："</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换前： "</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"交换后： "</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      // 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 // 向容器中添加元素</p>
<p>​</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li> 计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) {</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"total = "</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>          // 求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                       // 求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>              // 求两个容器的差集</p>
<p>​</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
<p>​</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">"v1与v2的差集为： "</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"v2与v1的差集为： "</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置  </li>
</ul>
<p>作者：<a href="https://www.bilibili.com/video/BV1et411b73Z">黑马程序员</a>  </p>
<iframe src="//player.bilibili.com/player.html?aid=41559729&amp;bvid=BV1et411b73Z&amp;cid=72978340&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
